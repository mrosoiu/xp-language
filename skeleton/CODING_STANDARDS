Das XP-Framework: Coding Standards
======================================================================
$Id$

Warum Coding Standards?
---------------------------------
<quote>
Code conventions are important to programmers for a number of reasons: 

* 80% of the lifetime cost of a piece of software goes to maintenance. 
* Hardly any software is maintained for its whole life by the original author. 
* Code conventions improve the readability of the software, allowing engineers to 
  understand new code more quickly and thoroughly. 
* If you ship your source code as a product, you need to make sure it is as well 
  packaged and clean as any other product you create. 
* For the conventions to work, every person writing software must conform to the 
  code conventions. Everyone. 
</quote>

Kommentare am Anfang einer Datei:
---------------------------------
Der Kommentar am Anfang einer Datei sollte auf jeden Fall den CVS-Tag enthalten, 
also mindestens $Id$; und eine kurze Beschreibung, was hier vorkommt. Als Stil 
wird der Kommentar in C-Notation vorgeschlagen:

/* 
 * Kurze Beschreibung
 *
 * $Id$
 */

Dieser Kommentar wird ohne Einrückung direkt hinter das erste <?php geschrieben 
und erhält genau die obige Form. Die Kurzbeschreibung bleibt bei genau einer Zeile, 
das CVS-Tag ist vor dem ersten add / commit als $Id$ und nur so zu schreiben.

<?php und ?>
------------
Es wird diese und keine andere Form (z.B. <% %> oder <? ?>) verwendet, <?php ... ?> 
ist XML-konform und daher "zukunftssicher". <? gibt ein "Not well-formed"-Fehler 
aus.

Dateinamen:
-----------
Die Dateinamen sehen wie folgt aus:
1.) Klassen
    Klassennamen heißen gleich wie die Klasse (s.u.) und enthalten immer nur 
    eine Klasse. Das Suffix ist .class.php.

    GenericWizzard.class.php
    GUI.class.php

2.) Includes
    Includes sind, wenn möglich, *nicht* zu verwenden. Stattdessen möchte man 
     über Property-Files oder eine Klasse nachdenken.

3.) "Normale" Seiten
    Diese haben einen prägnanten Namen zum Zweck, welcher durch den Pfad 
    natürlich ergänzt wird. Worttrennung erfolgt durch den Unterstrich (_).
    
    index.php
    edit/mail.php
    edit/mail_notify.php

Einrückung:
-----------
Die Einrückung sollte innerhalb einer Datei einheitlich sein, wobei die Einrückung 
mit zwei Leerzeichen festgelegt wird.

Zeilenlänge:
------------
Zeilen mit mehr als 80 Zeichen sind zu vermeiden. Beispiele für Dokumentationen 
sollten sogar nur 70 Zeichen verwenden (Versand per E-Mail).

Zeilen umbrechen:
-----------------
Wenn ein Ausdruck nicht in eine Zeile passt, sollte sie wie folgt umgebrochen werden:
* Nach einem Komma
* Vor einem Operator
* Die umgebrochenen Zeilen sind einzurücken

Also, als Beispiel:

$r= sprintf('<a href="http://%s:%d/%s/%s.bar" target="%s">%s</a>',
  $host, $port, $path, $file, $target, $anchor
);

$r= sprintf(
  '<a href="http://%s:%d/%s/%s.bar" target="%s">%s</a>',
  $host, 
  $port, 
  $path,
  $file,
  $target,
  $anchor
);

Wenn Klammerausdrücke vorkommen, sollten die geklammerten Ausdrücke in einer Zeile 
stehen bleiben:

$r= $variable0 * ($variable1 + $variable2 - $variable3)
    + 4 * $variable4; // VORZUZIEHEN

$r= $variable0 * ($variable1 + $variable2 - 
		      $variable3) + 4 * $variable4; // WENN MÖGLICH, NICHT

Bei Funktionsdeklarationen stehen evtl. umzubrechende Parameter auf der gleichen 
Höhe wie die anfangende Klammer, es sei denn, dadurch würden die Parameter sehr 
weit nach rechts herausrücken:

function vsprintf($string, $uriRequesterObject,
                  $foobarbaz, $longParamNameNumber4) {
  ...
}

function sehrsehrLangerMethodenName($string, $uriRequesterObject,
	 $foobarbaz, $longParamNameNumber4) {
  ...
}

Lange Bedingungen in einem IF-Statement sollten folgendermaßen eingerückt werden:

if (
    ($REMOTE_ADDR== "172.17.0.27") ||
    ($REMOTE_ADDR== "172.17.0.26") ||
    ($REMOTE_ADDR== "172.17.0.24") ||
   ) {
    $rightGroup= "root";
}

Im Beispiel sind die Bedingungen alle auf gleicher Höhe, sind aber visuell durch 
eine (fast) leere Zeile vom Auszuführenden abgetrennt.

Array-Deklarationen sind bis auf den leeren Array immer umzubrechen:

$list= array();

$list= array(
  'Hallo',
  'Welt'
);

$fasel= array(
  'Bla',
  'Fasel' => array(
    'Cool',
    'Oder?'
  )
);

Für ternäre Ausdrücke gelten folgende zwei Schreibweisen:

$alpha= ($booleanExpression) ? $beta : $gamma;

$alpha= ($booleanExpression) 
        ? $beta 
        : $gamma;

Kommentare:
-----------
In PHP sind dreierlei Kommentare erlaubt: Die C-typischen // und /*, sowohl als 
auch das Perl-Kommentarzeichen #. Aus Java kennen wir den /** ... */ -
Dokumentationskommentar. Diese könnten wir zum Extrahieren der Doku mit einem 
PHPDoc-System benutzen.

Die Raute (#) als solche ist zu vermeiden. Die meisten Kommentare sind als // 
zu schreiben; ansonsten ist eine Auskommentierung eines gesamten Bereiches 
mit /* ... */ nicht mehr einfach möglich. Kommentare sollten nicht in großen 
"Kisten" aus Sternchen oder anderen Zeichen gemalt werden. Ein Kommentar 
steht immer über dem kommentierten. Vor und nach den Kommentarzeichen 
kommt ein Leerzeichen:

// Korrekt
$a= 0; // Auch korrekt, aber hier nur gut und nicht "besser":)
$a= 0;	     // Besser

//Vermeiden!
$a= 0;//Vermeiden!

Block-Kommentare:
-----------------
Block-Kommentare werden ausschließlich zur Beschreibung von Dateien (s.o.: 
Kommentare am Anfang einer Datei) verwendet.

/*
 * Das ist ein Block-Kommentar
 */

Einzeilige Kommentare:
----------------------
Einzeilige Kommentare sind als // zu schreiben. Damit kann ein Code-Block, 
der mehrere solcher Kommentare enthält, durch /* ... */ auskommentiert werden.
Auch einzeilige Kommentare sollten durch eine vorhergehende Leerzeile vom 
Rest des Codes abgetrennt werden. Außerdem sollten sie sich auf der gleichen 
Einrückung befinden:

if ($condition) {

  // Hier hole ich mir die Daten 
  ...
}

Wenn mehr als eine Zeile Text oder Kommentare auskommentiert weden sollen, 
sei folgende Notation zu empfehlen:

if ($condition) {
   ...

   // // Das hier ist zum Debuggen
   // $debug= TRUE;
   // fsockopen("debug-srv", 0x9282);
   // ...
}

Bei einem noch größeren Block seien die /* */ nur beim Entwickeln oder 
in Sonderfällen (temporäre Außerbetriebnahme, ...) gestattet. Vor dem Commit 
rauslöschen, dafür ist schließlich CVS da.

Kommentare am Ende einer Zeile:
-------------------------------
Auch diese Kommentare sind aus gleichen Gründen wie oben genannt als // 
zu schreiben. Sind mehrere Kommentare dieser Form in einem Code-Block, so 
sollten sie die gleiche Einrückung haben.

if ($condition) {
  return FALSE;	// Begründung
}

if ($condition) {
  $alpha= FALSE;				// Begründung
} else {
  $alpha= substr($beta, 0, strlen($gamma));	// Warum auch immer
}

Dokumentations-Kommentare:
--------------------------
Ob wir einmal Doku zu unserem Source schreiben, ist fraglich, wäre aber 
sicher wünschenswert. Man könnte immerhin anfangen und Doku-Kommentare 
verwenden (es ist ja nur ein * mehr:)). Mit Dokumentationskommentaren würde 
man bspw. Klassen und Methoden einer Klasse dokumentieren; denn gerade hier 
ist es unerläßlich, etwas über die Aufrufparameter zu verraten.
Das erste /* ist auf der gleichen Höhe (=> Einrückung) wie das, was dokumentiert 
wird. Die Sternchen bilden eine vertikale "Linie".

/**
 * Die Techauftrag-Klasse...
 */
  class Techauftrag {
    ...

  /**
   * Gibt die Domains zu einem Techauftrag zurück
   * 
   * @access  public
   * @param   int mode default TA_DOMAIN_ALL
   *          TA_DOMAIN_ALL: Alle Daten zur Domain
   *          TA_DOMAIN_LIST: Liste: domain_id => domainname
   * @throws  SQLException
   * @return  array Domains
   */
  function getDomains($mode= TA_DOMAIN_ALL) {
    ...
  }

  ...
}

Die vier @-Angaben innerhalb des Doku-Kommentars sind ebenso für das 
automatische Dokusystem gedacht. 

@access definiert den Zugriff auf die Klassenmethode, da es in PHP 
        keine Unterscheidung diesbezüglich gibt. 
        
@param  dokumentiert die Verwendung der Parameter und deren evtl. 
        Defaultwerte; 
        
@return den zu erwartenden Return-Wert. 

@throws gibt an, dass bei einem Fehler nicht der erwartete Array 
        zurückkommt (und nur dann ist ein @throws nötig), sondern eine 
        Exception. Hier nochmal die Liste:

@access  public|private
@param   <paramType> <paramName> [default <default>] [description]
@return  (<returnType>) [description]
@throws  <exceptionName>
@see     (<url>|#<method>|<class>#<method>)

Die Reihenfolge spielt keine Rolle. Die Keywords und deren Werte sollen
wie im Beispiel oben auf der gleichen Höhe stehen. Wird umgebrochen, so
sieht fängt die Folgezeile auf der gleichen Höhe an:

@param   <paramType> <paramName> [default <default>] [description...
         ...]

Die Dokumentationskommentare stehen über der Methode/Klasse und werden 
niemals innerhalb einer solchen verwendet. Sie enthalten keine 
Leerzeilen (bzw. solche mit \s+\*) am Anfang oder am Ende (wohl aber nach 
der Beschreibung, zum Abtrennen), also nicht:

/**
 *
 * Generiert ein Bar
 *
 * @access  public
 */

oder

/**
 * Generiert ein Bar
 * @access  public
 *
 */

,sondern:

/**
 * Generiert ein Bar
 *
 * @access  public
 */

Der @see-Parameter ist optional und kann entweder eine URL, 
#methodenName, ein Klassenname oder Klassenname:#methodenName sein. 
#methodenName ist dabei eine Methode innerhalb der gleichen Klasse, 
Klassenname der gleiche String, der in uses() verwendet wird, also
beispielsweise 'net.http.HTTPConnection' (nicht der Dateiname).

Spezielle Kommentare
Ein FIXME: oder TODO:  gleich nach einem Kommentar soll heißen, dass 
es hier noch nicht ganz ausgegoren ist:

// FIXME: Hier könnte evtl. noch ein Datenbank-Fehler auftauchen
// TODO: Besseres Backchecking einbauen

<quote>
Note:The frequency of comments sometimes reflects poor quality of 
code. When you feel compelled to add a comment, consider rewriting 
the code to make it clearer. 
</quote>

Deklarationen:
--------------
Deklarationen sind innerhalb PHP eigentlich nicht nötig, sind aber 
"schöner" und eigentlich auch ein guter Stil. Zumindest innerhalb Klassen 
sollten die Klassenattribute deklariert werden.

class Foo {
  var $anywhere;

  var 
    $parent,
    $child;

  var
    $encoding= ENC_ISO_8859_1;

  function Foo() {
    ...
  }
}

Die Klassenmethoden oder der Konstruktor hat eine Zeile Abstand zu den Deklarationen.

Statements:
-----------
Eine Zeile sollte höchstens ein Statement enthalten:

$a++;			// Korrekt
$b++;			// Korrekt
$a--; $b--;		// Nicht gut

Blöcke:
-------
Blöcke sind in { und } eingeschlossen. Dabei gilt:
* Blöcke werden eingerückt
* Die öffnenden geschweifte Klammer steht am Ende der Zeile, die den Block 
  beginnt
* Die schließende geschweifte Klammer sollte am Anfang einer neuen Zeile 
  stehen und die gleiche Einrückung wie der Anfang des Blocks haben.
* Jeder Block wird immer in geschweiften Klammern geschrieben, obwohl man 
  es für Single-Statements auch weglassen könnte. Das verringert die Gefahr, 
  dass man Code dazufügt, der dann nicht ausgeführt wird, weil eben die 
  Klammerung fehlt. Ausnahme: In Verbindung mit Return (s.u.)

  $result= $dbo->select('baz from bar where foo= NULL');
  if(!$result) return FALSE;

  if (FALSE === $result= $dbo->select('baz from bar where foo= NULL')) return FALSE;

Return:
-------
Ein Return-Statement sollte nur Klammerung benutzen, wenn diese nötig sind 
oder der besseren Lesbarkeit (Gruppierung) dienen.

return TRUE;
return $dbo->query('set rowcount 0');
return (isset($size) 
  ? $size 
  : $defaultSize
);

if, if-else, if else-if else Statements:
----------------------------------------
Die if-else-Klassen von Statements sollten folgende Form haben:

if ($condition) {
  imageSize(...);
}

if ($condition) {
  imageSize(...);
} else {
  imageCreate(...);
}

if ($condition) {
  imageSize(...);
} elseif ($condition2) {
  imageCreate(...);
} else {
  imageDispose(...);
}

for-Statements:
---------------
Ein for-Statement sollte folgende Form haben:

for ($init; $condition; $update) {
  doSomething();
}

while-Statements:
-----------------
Ein while-Statement sollte folgende Form haben:

while ($condition) {
  doSomething();
}

do {
  doSomething();
} while ($condition);

switch-Statements:
------------------
Ein switch-Statement sollte folgende Form haben:

switch ($condition) {
  case ENC_ISO_8859_1:
    $output= 'bla';
    $needsParsing= FALSE;

  case ENC_ISO_8859_2:
    $output= 'foo';
    break;

  default:
    statement();
    break;
}

Nach dem ersten case empfiehlt sich ein Kommentar // Fallthrough, damit 
ersichtlich ist, dass hier kein break; vergessen wurde:

  case ENC_ISO_8859_1:
    $output= 'bla';
    $needsParsing= FALSE;

    // Fallthrough
  case ENC_ISO_8859_2:

try/catch-Blöcke:
-----------------
Ein try/catch-Block soll folgende Form haben:

// Zend Engine 1:
try(); {
  doSomethinWhichMightRaiseAnException();
} if (catch('WhatEverException', $e)) {
  handleException();
} if (catch('Exception', $e)) {
  handleException();
}

// Zend Engine 2
try {
  doSomethinWhichMightRaiseAnException();
} catch(WhatEverException $e)) {
  handleException();
} catch(Exception $e)) {
  handleException();
}

throw:
------
Throw wirft immer Objekte, die von der Basisklasse "Exception" abstammen.

// Zend Engine 1
if (FALSE === ($dbh= sybase_connect([...])) return throw(new SQLException(
  'unable to connect'
));

// Zend Engine 2
if (FALSE === ($dbh= sybase_connect([...])) throw(new SQLException(
  'unable to connect'
));

Whitespace:
----------
1.) Leerzeilen
    Leerzeilen erhöhen die Lesbarkeit des Codes. Eine Leerzeile gehört an folgende Punkte:
    * Zwischen Methoden (Funktionen)
    * Zwischen dem global/static-Statement innerhalb einer Funktion und der ersten 
      Zeile Code dieser Funktion
    * Vor einem einzeiligen Kommentar oder einem Block-Kommentar
    * Nach dem Kommentar am Dokument-Anfang
    * Zwischen logischen Abschnitten innerhalb einer Methode, um die Lesbarkeit 
      zu erhöhen und die Zusammengehörigkeit zu "demonstrieren"

2.) Leerzeichen
    Leerzeichen sollten an folgenden Stellen verwendet werden:
    * Ein Keyword (if, else, while, for, ...), gefolgt von einer Klammer, sollte 
      durch ein Leerzeichen abgetrennt werden

      while (TRUE) {
          ...
      }

      Hinweis: Nach einerm Funktionsaufruf und den Klammern kommt kein Leerzeichen. 
      Das hilft, Keywords und Funktionsaufrufe voneinander zu unterscheiden
      
    * Nach einem Komma in einer Liste von Argumenten.
    * Eine Array-Key-Value-Zuweisung wird durch ein Leerzeichen vor dem => und 
      eines danach abgetrennt
    * Die Klasseninstanz und die Klassenmethode bzw. das Klassenatribut werden 
      durch -> getrennt, aber auf gar keinen Fall durch irgendwelche Leerzeichen 
      zwischendrin.

      $this->foo	// OK
      $this -> bar	// Unnötig

    * Runde Klammern werden nicht durch Leerzeichen voneinander abgetrennt

      while (($a > 0) && ($b < 1)) ...	 // Korrekt
      while ( ($a > 0) && ($b < 1) ) ... // Unnötig

    * Alle Operatoren aus (+ - * / % & | ~ && < > <= >= != == || etc.) sollten 
      durch Leerzeichen zu beiden Seiten abgetrennt werden.
    * Alle Operatoren aus (++ -- etc.) haben kein vorangestelltes Leerzeichen
    * Der String-Concatenation-Operator (.) hat zu keiner Seite ein Leerzeichen
    * In einem for-Statement werden die einzelnen Ausdrücke durch Leerzeichen getrennt.

      for($init; $condition; $update)...

    * Type-Casting hat kein Leerzeichen zur rechten Seite hin, sondern liegt direkt 
      an der Variable "an", welche gecastet wird.

      myMethod((int)$a, (array)$this);

Namenskonventionen:
-------------------
1.) Klassen
    Klassennamen fangen mit einem Großbuchstaben an. Jedes folgende Wort hat wieder 
    einen Großbuchstaben ("Studly Caps"). Klassennamen sind so kurz wie möglich zu 
    halten, sollen aber trotzdem signifikant für das stehen, was sie tun. Bei 
    Datenbanknamen oder Abkürzungen (GUI, HTML) sollen Großbuchstaben verwendet 
    werden.

    class TOGAL;
    class MyTemplate;
    class Raster;
    class GenericGUI;

2.) Kostruktoren von Klassen
    Der Konstruktor einer Klasse heißt __construct() . Er muss, wenn er überschrieben 
    wird, denn Destruktor der Parent-Klasse aufrufen (parent::__construct();).

3.) Destruktoren von Klassen
    Der Destruktor einer Klasse heißt __destruct() und erwartet keine Parameter. Er 
    muss, wenn er überschrieben wird, denn Destruktor der Parent-Klasse aufrufen 
    (parent::__destruct();).

4.) Methoden
    Methoden (Funktionen) sollten Verben sein, der erste Buchstabe klein. Jedes 
    folgende Wort hat wieder einen Großbuchstaben am Anfang:

    function run();
    function runBackground();
    function getMessage();
    function makeInstallation();

5.) Private/Public
    Private Methoden innerhalb einer Klasse (da es auch sowas in PHP nicht gibt) fangen 
    mit einem Unterstrich an:

    function _myPrivateMethod();

6.) Variabeln
    Variabelnnamen sollten kurz und prägnant sein und aussagen, was sie tun. Zu 
    vermeiden sind Variabeln wie $foo, $bar, $baz, $ficken und Variabelnnamen mit 
    weniger als zwei Zeichen. Ausnahme: Temporäre "Wegwerf"-Variabeln wie i,j,k,m,n 
    (für Integer) und c,d,e (für Char), z.B. als Zählvariable. Namen in Variabeln 
    sind entweder durch gemixte Groß- und Kleinschreibung oder durch Unterstrich 
    (_) getrennt. Variabeln, die per GET übermittelt werden, fangen mit zwei 
    Unterstrichen an (sicherheitsrelevant).

    $myWidth;
    $i;
    $message_id;
    $__page;

7.) Konstanten
    Konstanten werden komplett in Großbuchstaben geschrieben.

    define('TA_NOTFOUND',   0x0001);
    define('TA_OKAY',       0x0002);

    Wenn möglich, defines nur als Integer und dort präferablerweise als 
    hexadezimale Darstellung.  Mehrere Defines untereinander halten den rechten 
    Teil auf der gleichen Höhe.

8.) Misc:
    Konstanten statt Integer oder Character-Return, wo möglich
    Anstatt den Returnwert einer Funktion mit return 1, return "foo" oder return 
    -55 zu setzen, sind, wo möglich, Konstanten zu verwenden. Diese werden noch 
    vor allem anderen in einer Datei (gleich nach dem anfänglichen Kommentar) 
    definiert. Ausnahme sei TRUE / FALSE, die auch als 0 und 1 geschrieben werden 
    können (das hat sich eingebürgert und ist für jeden verständlich).

Klammerung:
-----------
1. "and und or ersetzen Klammern" - also:

   if ($stage_server and $this->debug)
   if (($i < 0) || ($a > $c))

2. eine Negation braucht keine Extra-Klammer - also:

   if (!(is_null($foo)))         // Unnötig
   if (!is_null($foo))           // Besser

3. Klamern werden zusammengeschrieben und enthalten kein Whitespace (s.o.)

4. Auch Sprachkonstrukte wie require, include, require_once und include_once 
   erhalten Klammern.

    require_once("Project.class.php");
    include("stop.inc");

Variabelnzuweisung und Vergleiche:
----------------------------------
Zwischen einer Zuweisung einer Variabeln und dem Wert steht auf der rechten Seite 
ein Leerzeichen, bei einem Vergleich auf beiden Seiten. Dadurch können Fehler wie 
if ($a = 1) vermieden werden, da es schon vom Aussehen her anders wirkt.
Bei Arrays sind die Keys und Values gleich einzurücken.

$a= 'hello';
if ($a == 'hello') ...

// Noch besser, um auch hier Tippfehler zu vermeiden. Bei Zeile eins würde
// der Compiler bereits meckern.
if ('http://' = substr($uri, 0, 7)) ...
if ('http://' == substr($uri, 0, 7)) ...

$array= array(
  IT_STRING     => '<input type="text" value="%s"/>',
  IT_TEXTAREA   => '<textarea>%s</textarea>'
);

Referenzzeichen stehen direkt vor dem, was die Referenz ist.

function &domains() {
  return $this->domains;
}
...
$domains= &$techauftrag->domains();

$a= &$b;

function selectByName(&$dbo) ...

Return:
-------
Return springt immer sofort aus einer Funktion heraus, daher ist statt:

function foo($file) {
    if ($fd= fopen($file, "r")) {
        ...
    } else {
      return 0;
    }
}

zu schreiben:

function foo($file) {
    if (!$fd= fopen($file, "r")) return 0;
    ...
}

Ähnliches gilt für continue:

while ($entry= $dir->read()) {
    if('.' == $entry or '..' == $entry) continue;
    ...
}

Der ternäre Operator ist, soweit möglich, einem if-else-Konstrukt vorzuziehen:

// Aufwändig und unnötig
if ($condition == NULL) {
  return FALSE;
} else {
  return TRUE;
}

// Besser
return ($condition == NULL) ? FALSE : TRUE;

// Noch besser
return ($condition != NULL);

Wenn ein binärer Operator (z.B. >=, <=, ==, etc.) in einem ternären Operator 
auftaucht, so sollte dies geklammert werden.

PHP-Start- und Endtags:
-----------------------
Nach den Start-und-Endtags ist eine Einrückung von zwei Zeichen vorzunehmen:

<?php
  class Foo {
    var $x= NULL;
  }
?>

Sauberes Programmieren in PHP:
------------------------------
1.) Error-Reporting
    Dies ist auf E_ALL zu halten.

2.) Bei Funktionen, deren Warnings man geflissentlich ignorieren möchte, ist 
    der @-Operator zu verwenden.

    // Lesbar und klar, was es macht
    $dbh= @sybase_connect(...);

    // Zu vermeiden, sowieso unnötig
    $e= error_reporting(0);
    $dbh= sybase_connect(...);
    error_reporting($e);

3.) Checks
    Anstatt Variabeln mit dem Negationsoperator auf Nichtexistenz zu prüfen, 
    sollte isset() verwendet werden. Der erste Fall führt zu einer Notice vom 
    Compiler und validiert außerdem auf NULL, die Zahl Null, leere Strings und 
    das booleansche FALSE. empty() erfüllt die Bedingung isset und 
    (NULL || 0 | "" | FALSE).

4.) Mischung von HTML und PHP
    Ist natürlich verlockend und außerdem richtig fix. Trotzdem verstößt es gegen 
    die Richtlinie, Design und Programmierung zu trennen, außerdem macht es den 
    Code absolut unlesbar, zumal HTML wahrscheinlich anders eingerückt wird 
    als der Code.

String Concatenation vs. zeilenübergreifende Strings
----------------------------------------------------
Gerade bei SQL ist es richtig schick, dass es auf Zeilenumbrüche und Leerzeichen 
nicht ankommt.

$result= $dbo->query('
  select * from foo, bar
  where baz= 2
  and foo.i= bar.i
');

zum Beispiel ist einfach zu erweitern und vor allem auch einfach gegen etwas 
anderes auszutauschen oder in ein SQSH-Fenster zu kopieren (hier ist eine 
zusätzliche Einrückung von zwei Zeichen zu empfehlen).

$result= $dbo->query('select * from foo, bar '.
                     'where baz= 2 '.
                     'and foo.i= bar.i ');

halte ich dagegen für unlesbar und schlecht wiederverwendbar. Zudem ist es 
anfällig, wenn man hinten noch Leerzeichen vergisst (=> Syntax Error von DBMS).

Variabeln in Strings:
---------------------
Sind, falls möglich, zu vermeiden, aber keine Schandtat.

Regular Expressions:
--------------------
Sind bei Eingabeprüfungen fast unabdingbar. Allerdings sollten hier statt den 
ereg_* Funktionen die preg_* -Funktionen benutzt werden. Diese sind schneller 
und haben einen weit höheren Funktionsumfang (siehe Manual). Die Match-und 
Replace-Strings sind in einfachen Quotes zu schreiben, das erübrigt unnötiges 
Zeichenquoting.

Array-Indizes:
--------------
Sind immer in Quote-Zeichen zu schreiben.

echo $arr[helptext_domain_name];	// "undefined constant, assuming string"
echo $arr['helptext_domain_name'];	// Hier ist der Parser glücklich

JavaScript hat mit der Funktionalität nichts verloren:
------------------------------------------------------
Eine Seite muss auch immer ohne funktionieren. Nicht aus sicherheitstechnischen 
Gründen oder weil es nicht genügend Browser gibt, die es unterstützen, aber auf 
JavaScript ist kein Verlass. Es findet auch keine clientseitige Validierung der 
Eingabefelder statt; das ist ohne Dikussion.

Klassen:
--------
Jede Klasse vererbt entweder die Klasse "Object" oder eine Klasse, die Object
vererbt. Nur dadurch ist eine Klasse dem Framework konform.

Ein Klassenname muss (im gesamten Framework) unique sein. Das ist eine 
Einschränkung, die durch die Zend Engine 1 vorgegeben ist. In der Zend
Engine 2 können Klassenname mit Namespaces versehen werden:

class XML::Tree extends XML::XML {
  [...]
}

...und über die import-Funktion einfach angesprochen werden:

import Tree from XML;
$tree= new Tree();

Für den Moment (in der Zend Engine 1) müssen die Klassennamen bspw.
XMLTree und XMLNode heißen (Namespaces werden über den Namen realisiert
bzw. wie in Sybase einfach weggelassen).

Die Sybase-Klasse wird in Zukunft [ZE2] bspw. RDBMS::Sybase heißen, usw.

Beispiel:
---------
<?php
/* This class is part of the XP framework
 * 
 * $Id$
 */

  uses('lang.SystemException');
  
  /**
   * Die System-Klasse
   * Betriebssystem/Umgebungsspezifisches
   * 
   * @access  static
   */
  class System extends Object {

    /**
     * System-Infos
     *
     * @access  public
     * @return  array Properties
     */
    function getInfo() {
      $prop= array();
      
      // PHP-spezifisches
      $prop['php.version']= phpversion();
      $prop['php.api']= php_sapi_name();

      // Betriebssystem
      $prop['os.name']= (getenv('OSTYPE')== '') 
        ? getenv('OS') 
        : getenv('OSTYPE');

      // Host
      $prop['host.name']= (getenv('HOSTNAME')== '') 
        ? getenv('COMPUTERNAME') 
        : getenv('HOSTNAME');
      $prop['host.arch']= (getenv('HOSTTYPE')== '') 
        ? getenv('PROCESSOR_ARCHITECTURE')
        : getenv('HOSTTYPE');

      // User
      $prop['user.home']= str_replace('\\', '/', (getenv('HOME')== '') 
        ? getenv('HOMEPATH') 
        : getenv('HOME'));
      $prop['user.name']= (getenv('USER')== '') 
        ? getenv('USERNAME') 
        : getenv('USER');
      
      return $prop;
    }
    
    /**
     * Setzt eine Umgebungsvariable
     *
     * @access  public
     * @param   string name
     * @param   mixed var
     * @return  bool success
     */
    function putEnv($name, $var) {
      return putenv($name.'='.$var);
    }
    
    /**
     * Liest eine Umgebungsvariable. Gibt es diese nicht, wird NULL zurückgegeben
     *
     * @access  public
     * @param   string name
     * @return  mixed var
     */
    function getEnv($name) {
      $val= getenv($name);
      return ('' == $val) ? NULL : $val;
    }

    /** 
     * Ein Programm ausführen
     * 
     * Zum Exit-Code, aus der Bash-Manpage:
     * <pre>
     * EXIT STATUS
     * For  the  shell's  purposes,  a command which exits with a
     * zero exit status has succeeded.  An exit  status  of  zero
     * indicates success.  A non-zero exit status indicates fail­
     * ure.  When a command terminates on a fatal signal N,  bash
     * uses the value of 128+N as the exit status.
     *
     * If  a  command  is not found, the child process created to
     * execute it returns a status of 127.  If a command is found
     * but is not executable, the return status is 126.
     *
     * If a command fails because of an error during expansion or
     * redirection, the exit status is greater than zero.
     *
     * Shell builtin commands return a status of 0 (true) if suc­
     * cessful,  and  non-zero  (false)  if an error occurs while
     * they execute.  All builtins return an exit status of 2  to
     * indicate incorrect usage.
     *
     * Bash  itself  returns  the exit status of the last command
     * executed, unless a syntax error occurs, in which  case  it
     * exits  with  a  non-zero value.  See also the exit builtin
     * command below.
     * </pre>
     *
     * @param	string cmdLine  Der auszuführende Befehl
     * @param   string redirect Ausgabe-Umleitung. Per Default wird STDERR auf STDOUT gemappt.
     * @param   bool background Im Hintergrund ausführen?
     * @return  array lines Die einzelnen Zeilen der Rückgabe als Array
     * @throws  Exception wenn Retcode != 0
     * @see     http://www.php.net/manual/en/function.exec.php#contrib
     */
    function exec($cmdLine, $redirect= '2>&1', $background= FALSE) {
      $cmdLine= escapeshellcmd($cmdLine).' '.$redirect.($background ? ' &' : '');
      
      if (!($pd= popen($cmdLine, 'r'))) return throw(new Exception(
        'cannot execute "'.$cmdLine.'"'
      ));
      $buf= array();
      while (
        (!feof($pd)) && 
        (FALSE !== ($line= fgets($pd, 4096)))
      ) {
        $buf[]= $line;
      }
      $retCode= (pclose($pd) >> 8) & 0xFF;
      
      if ($retCode != 0) throw(new SystemException(
        'System.exec('.$cmdLine.') err #'.$retCode.' ['.implode('', $buf).']',
        $retCode
      ));
      return $buf;
    }
  }  
?>


_______________________________________________________________
Material
	http://java.sun.com/docs/codeconv
	http://java.sun.com/j2se/javadoc/writingdoccomments/index.html
	http://dclp-faq.de/

Direkt und umodifiziert aus den jeweiligen Material entnommener Text ist 
in <quote></quote> eingeschlossen

<EOF>
