<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::Development::Tips::Performance">
  <main>
    <content>
      <title>Performance</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>What can be done to improve performance?</caption>
        <text>
          This document suggests a number of tweaks in common situations.
        </text>
      </para>
      <para>
        <caption>Traversing numeric arrays</caption>
        <text>
          Although the <tt>foreach</tt> keyword exists and is a
          short and sexy form of traversing lists, there is also
          a downside: the elements are copied, thus resulting in
          an unneccessary memory overhead.
          <br/><br/>
          This is the suggested code template:
          <code><![CDATA[  for ($i= 0, $s= sizeof($list); $i < $s; $i++) {
    // ...
  }
]]></code>
          The <tt>sizeof</tt> calculation is moved to the initialization
          part of the <tt>for</tt> statement to avoid recalculation on 
          every run. Of course, if your array changes its size during 
          the loop, you can't do this.
          In some situations <tt>foreach</tt> is wished, so one can use the
          following construct:
          <code><![CDATA[  foreach (array_keys($objects) as $idx) {
    $o= &$objects[$idx];
    $o->doSomething();
    
    // Alternatively, without the need for a temporary variable
    $objects[$idx]->doSomething();
  }
]]></code>          
        </text>
      </para>
      <para>
        <caption>Trimming trailing set of characters off a string</caption>
        <text>
          Often, it can be necessary to get rid of extraneous characters at the
          end of a string. In particular, when concatenating directories and
          filenames, where the directory's name may or may not contain a trailing
          slash, and <tt>//</tt> should not appear (though it will work), the 
          following tip may come in handy:
          <code><![CDATA[  // Don't do this:
  while (substr($str, -1) == '/') $str= substr($str, 0, -1);
  
  // Instead, use the following:
  $str= rtrim($str, '/');
]]></code>
        </text>
      </para>
      <para>
        <caption>Regular expressions vs. string functions</caption>
        <text>
          Rule: Always prefer string functions over regular expressions.
          <code><![CDATA[  // Don't do this:
  if (preg_match('/^www/', $str)) { ... }
  
  // Instead, use the following:
  if ('www' == substr($str, 0, 3)) { ... }
]]></code>
          Only use regular expressions if there is no other elegant way.
          <br/><br/>
          You might also want to have a look at <tt>sscanf</tt> and its
          possibility of using <b>%[...]</b> and <b>%[^...]</b>.
        </text>
      </para>
      <para>
        <caption>Finding elements</caption>
        <text>
          If you're considering to have some sort of hashtable, consider
          putting what you're searching for into the key:
          
          <code><![CDATA[  // Consider replacing:
  $a= array(
    array('domainname' => 'thekid.de', 'owner' => 'Timm Friebe', ...), 
    array('domainname' => 'binford6100.info', 'owner' => 'Binford Inc.', ...)
  );
  
  // ...with...
  $a= array(
    'thekid.de'         => array('owner' => 'Timm Friebe', ...), 
    'binford6100.info'  => array('owner' => 'Binford Inc.', ...)
  );]]></code>
          Hash key lookups are always faster than traversing and comparing.
        </text>
      </para>
      <para>
        <caption>Objects (relevant only for PHP4)</caption>
        <text>
          Rule: Always pass objects by reference in PHP4. This avoids
          unintentional copies and therefore produces a smaller memory footprint.
          
          <code><![CDATA[  // Don't do this:
  class Foo {
    function addObject($object) {
      $this->objects[]= $object;
    }

    function objectAt($i) {
      return $this->objects[$i];
    }
  }
  
  $foo= new Foo();
  $foo->addObject(new Object());
  $o= $foo->objectAt(0);
  
  // Always write 
  class Foo {
    function addObject(&$object) {
      $this->objects[]= &$object;
    }
    
    function &objectAt($i) {
      return $this->objects[$i];
    }
  }
  
  $foo= &new Foo();
  $foo->addObject(new Object());
  $o= &$foo->objectAt(0);
]]></code>
          This "annoyance" is solved in the Zend Engine 2.
          <br/><br/>
          <b>Note:</b> Do <i>not</i> include an ampersand (<b>&amp;</b>) in method calls
          such as <code><![CDATA[  addObject(&$object); ]]></code>
          This produces a warning and is deprecated!
        </text>
      </para>
    </content>
    <references>
      <ref link="../devel/index">Overview</ref>
      <ref type="ext" link="http://www.php-faq.de/ch/ch-code.html">PHP-FAQ: Guter Code</ref>
    </references>
  </main>
</document>
