<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::Tasks::GUI applications::Using Glade to build interfaces">
  <main>
    <references>
      <ref link="tasks">Common Tasks</ref>
      <ref type="ext" link="http://glade.gnome.org/">Glade Homepage</ref>
      <ref type="ext" link="http://glade.gnome.org/screenshots.html">Glade Screenshots</ref>
      <ref type="ext" link="http://glade.gnome.org/features.html">Glade Features</ref>
      <ref type="ext" link="http://www.adapower.net/gtkada/">Glade for Win32</ref>
    </references>
    <content>
      <title>Using Glade to build interfaces</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>What is Glade?</caption>
        <text>
          Glade is a UI design tool such as Visual C++, Delphi or even Microsoft Word's
          Visual Basic for Applications (aka "dialogue editor"). It aids you in designing
          an application window's layout via click, drag and drop.
          Unlike most other interface builders, glade saves all of the widgets to an XML,
          thus keeping it human readable (and modifyable, if you wish to).
        </text>
      </para>
      <para>
        <caption>Example application</caption>
        <text>          
          Let's keep to the second example (the window containing the button, closing
          it on click). This is the XML generated by Glade:
          <pre><![CDATA[
<?xml version="1.0"?>
<GTK-Interface>

<project>
  <name>Test</name>
  <program_name>test</program_name>
  <directory></directory>
  <source_directory>src</source_directory>
  <pixmaps_directory>pixmaps</pixmaps_directory>
  <language>C</language>
  <gnome_support>False</gnome_support>
  <gettext_support>False</gettext_support>
</project>

<widget>
  <class>GtkWindow</class>
  <name>window1</name>
  <title>window1</title>
  <type>GTK_WINDOW_TOPLEVEL</type>
  <position>GTK_WIN_POS_NONE</position>
  <modal>False</modal>
  <allow_shrink>False</allow_shrink>
  <allow_grow>True</allow_grow>
  <auto_shrink>False</auto_shrink>

  <widget>
    <class>GtkButton</class>
    <name>button1</name>
    <can_focus>True</can_focus>
    <label>button1</label>
    <relief>GTK_RELIEF_NORMAL</relief>
  </widget>
</widget>

</GTK-Interface>
]]></pre>
          To use the power of Glade in the XP framework, simply change the second example from
          the introduction to the following:
          <code><![CDATA[  class MyGladeApp extends GTKGladeApplication {
    function __construct(&$paramstring) {
    
      // Assume the .glade file is in the same directory as this class
      parent::__construct($paramstring, 'Hello', dirname(__FILE__).'/hello.glade');
    }
    
    function init() {
      parent::init();
      $button= &$this->widget('button1');
      $button->connect('clicked', array(&$this, 'done'));
    }  
  }]]></code>
        </text>
      </para>
      <para>
        <caption>Using the widget utility class</caption>
        <text>
          As you can see in the above example, widgets have to be "loaded" via the "widget"
          method. Due to the limitations of the Zend Engine 1 and PHP-GTK not being ported to
          Zend Engine 2 yet, we'll always have to use temporary variables instead of being
          able to dereference:
          <code><![CDATA[  // Would be possible with Zend Engine 2:
  $this->widget('button1')->connect('clicked', array($this, 'done')); 
  
  // Zend Engine 1
  $b= &$this->widget('button1');
  $b->connect('clicked', array(&$this, 'done'));]]></code>
          Therefore a simple - static - <ref type="api:class" link="gui.gtk.util.GTKWidgetUtil">
          utility class</ref> has been introduced. It accomplishes the task of connecting one 
          or more widgets to multiple signals with one call (nicely wrapped to four lines in
          the following example):
          
          <code><![CDATA[  // Connect a widget to multiple signals
  // We would need a temporary variable in Zend Engine 2 for this, too
  GTKWidgetUtil::connect($this->widget('button1'), array(
    'after:button_press_event' => array(&$this, 'onButtonPressed'),
    ':clicked'                 => array(&$this, 'onButtonClicked', &$data)
  ));
  
  // Connect all of the toolbar's children to multiple signals
  GTKWidgetUtil::connectChildren($this->widget('toolbar1'), array(
    'after:button_press_event' => array(&$this, 'onButtonPressed'),
    ':clicked'                 => array(&$this, 'onButtonClicked', &$data)
  ));]]></code>
          
          As seen in the second line of both examples, we can even connect any type of data
          to a signal from within the same call.
        </text>
      </para>
      <para>
        <caption>Using the pixmap loader class</caption>
        <text>
          To make your application even nicer looking, you might want to add some art to lists,
          buttons and so on. For everything that is "static", simply assign a picture using
          Glade. For dynamically calculated pixmaps, there is another 
          <ref type="api:class" link="gui.gtk.util.GTKPixmapLoader">helper class</ref> at
          your service. It simplifies the usage of pixmaps (since they're usually needed as
          pixmap and mask and is able to load a whole bunch of such at a time.
          <br/>
          Example:
          <code><![CDATA[  // Load art from channel.xpm, person.xpm and server.xpm
  // in the same directory as the file this sourcecode is in:
  $p= &new GTKPixmapLoader($this->window->window, dirname(__FILE__));
  $this->pixmaps= &$p->load(array(
    'channel',
    'person',
    'server'
  ));
  $p->__destruct();
  
  // ... Later on ...
  $this->ctree->insert_node(
    NULL,
    NULL,
    array('Column 1', 'Column 2'),
    4,
    $this->pixmaps['p:server'],
    $this->pixmaps['m:server'],
    $this->pixmaps['p:server'],
    $this->pixmaps['m:server'],
    FALSE,
    TRUE
  );]]></code>
          <!-- TBD: more text? -->
        </text>
        <advanced>
          <ref type="api:collection" link="gui.gtk">Collection overview: gui.gtk</ref>
        </advanced>
      </para>
    </content>
  </main>
</document>
