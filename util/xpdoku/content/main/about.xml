<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::About::Introduction">
  <main>
    <content>
      <title>An introduction</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>What does "XP" mean?</caption>
        <text>"XP" stands for "Extension framework for PHP".</text>
      </para>
      <para>
        <caption>What is the XP framework?</caption>
        <text>
          The XP framework:
          <ul>
            <li>is a collection of sourcecode that wraps often used
                constructs into easy-to-use classes,
            </li>
            <li>contains an implementations of a XML/XSL concept [PUSTEFIX] with which
                it is possible to completely separate programming and design from each other,
            </li>
            <li>has been programmed with the Zend Engine 2 [ZE2] in mind and will once use
                it as soon as ZE2 is stable.
                (A high priority lies on an easy portability onto ZE2 - this can be
                done with three regular expressions and the adoption of a single file)
                and
            </li>
            <li>has been made for any kind of application: commandline programs,
                applications with GUI [GTK-PHP], web applications with XML/XSL or
                just simple HTML.
            </li>
          </ul>
        </text>
      </para>              
      <para>
        <caption>What is the XP framework's licence?</caption>
        <text>
          The XP framework is published under a BSD-style licence. Its text reads:
          <pre><![CDATA[
Copyright (c) 2001-2006, XP-Framework Team
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of the XP-Framework nor the names of its
  contributors may be used to endorse or promote products derived 
  from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]></pre>          
        </text>
      </para>              
      <para>
        <caption>Idea</caption>
        <text>
          The idea of a completely object-oriented framework is not new. There exist
          some frameworks like CPAN for Perl or PEAR in PHP. This implementation is
          heavily based on the structure of Java, in whose CLASS_PATH exist several
          directores ("lang", "io", "net", etc.). For non-standardized extensions the
          domainname has been chosen as unique directory: classes specific to
          Schlund+Partner AG reside in ~/de/schlund/, classes specific to Apache reside
          in ~/org/apache/.
          <br/><br/>
          All the classes can be loaded by using the keyword import,
          while the exact location of the class in the filesystem has not to be known 
          to the program. The separation char has been chosen '.' instead of '/' or '\'.
          In the XP framework it is handled the same way, by the little difference that
          instead of "import" we use "uses" (import already is a language-keyword in
          ZE2).
          <br/><br/>
          The original motivation for the creation of such a framework was the change
          of the design on hosting.1und1.com (formely puretec.de). The code should
          be reuseable, independent and where possible multi-purposed (this includes
          the whole backend which is realised in crons). A simple implementation à la
          sybase_connect([...]) or die ('Database not available') was not an option.
          Errors like that have to be caught and handled by the application.
        </text>
      </para>              
      <para>
        <caption>Basics</caption>
        <text>
          The XP framework offers some advantages as basis:
          <ul>
            <li>An implementation of exceptions for the Zend Engine 1
                This will be obsoleted in ZE2, but they will work
                identically in ZE2.
            </li>
            <li>Unified constructors and destructors
                This is also contained in ZE2 and will be obsoleted after
                an update to PHP5.
            </li>
            <li>A function uses() which knows where to find the classes
            </li>
          </ul>

          A PHP script using the XP framework will have to start with the following
          line of code:

          <code><![CDATA[  require('lang.base.php'); ]]></code>

          The file included by this command contains the basics for the framework.
          It is recommended to change the include path in php.ini, so the
          path need not to be set by every script.
        </text>
      </para>              
      <para>
        <caption>An example</caption>
        <text>
          Let's have a look at the following script:

          <code><![CDATA[  // {{{ main
  require('lang.base.php');
  uses('io.File');

  $file= &new File('/file_does_not_exist.txt');
  printf("Trying to read %s...\n", $file->filename);
  try(); {
    $file->open(FILE_MODE_READ);
    $str= $file->readLine();
    $file->close();
  } if (catch('FileNotFoundException', $e)) {
  
    // File was not found
    $e->printStackTrace();
    exit(-1);
  } if (catch('IOException', $e)) {
  
    // Sone other I/O exception occured (e.g. "Permission denied")
    $e->printStackTrace();
    exit(-1);
  } 
  printf("Success: line is '%s'\n", $str);
  // }}}]]></code>

          In line three the class /path/to/skeleton/io/File.class.php is included. It
          wraps the PHP-functions that handle files (fopen, fread, ...) and embeds
          exceptions into the functions. 

          The syntax of <tt>uses</tt> is much more sexy than using something like 
          <tt>require_once($DOCUMENT_ROOT."/../includes/io/File.class.php")</tt> - 
          
          <ul>
            <li><tt>uses</tt> knows where the classes are, </li>
            <li>we have a unified path separator and </li>
            <li>we can ommit the standardized .class.php at the end.</li>
          </ul>

          Sure - this also works with include_path, but it is not allowed to everyone
          to change the include path (mass hosting). Further, the uses()-function allows
          to include multiple classes at one. E.g.:

          <code><![CDATA[  uses('io.File', 'util.Date'); ]]></code>

          Afterwards a block of code (line eight to eleven) is included in a try/catch
          block, Within this block, multiple errors could occur:

          <ul>
            <li>The file is not found</li>
            <li>The file cannot be opened (is exclusively locked by another process)</li>
            <li>While reading the file, an error occurs (quite unlikely but possible)</li>
            <li>While closing the file, an error can occur (which is even more unlikely
                but nevertheless possible).</li>
          </ul>

          In case one of the functions fail, it throws a typed exception which we can
          catch with catch(). In line twelve we test whether the error already occured
          while opening the file. Line 14 checks the more unlikely case (error when
          reading or closing the file).

          A sample output for case 1 (file not found) looks like this:

          <pre><![CDATA[
Trying to read file_does_not_exist.txt...
Exception io.FileNotFoundException (/file_does_not_exist.txt)
  at io.FileNotFoundException::__construct((0x28)'/file_does_not_exist.txt') 
  [line 87 of StackTraceElement.class.php] 
  at io.File::open((0x2)'rb') [line 8 of exception.php] 
          ]]></pre>

          Does the file exists, but cannot be read, the output could look like this:

          <pre><![CDATA[
Trying to read file_does_not_exist.txt...
Exception io.IOException (Cannot open /file_does_not_exist.txt mode rb)
  at io.IOException::__construct((0x3c)'Cannot open /file_does_not_exist.txt mode rb') 
  [line 87 of StackTraceElement.class.php] 
  at io.File::open((0x2)'rb') [line 8 of exception.php] 
  at io.File::<main>() [line 137 of File.class.php] fopen(/file_does_not_exist.txt): 
  failed to open stream: Permission denied
          ]]></pre>

          As you can see, in opposite to Java, ZE2 or any other programming language
          that implements an exception model, the code within the try-block is executed
          completely "due to limitations of Zend Engine 1". This is somewhat a dirty
          fact which will change with ZE2. Uncaught exceptions lead to the abortion
          of the program.
          <br/><br/>
          This example also shows the ease-of-use of the file object.
        </text>
      </para>              
      <para>
        <caption>Code</caption>
        <text>
          The code follows strict guidelines:
          <ul>
            <li>the style "Studly Caps"</li>
            <li>an indenting depth of 2 chars</li>
            <li>the burden to not to output any warnings or notices at an error reporting level 
              of E_ALL (most verbose)</li>
          </ul>
          You can find the complete coding standards <ref type="devel" link="coding">here</ref>.
        </text>
      </para>              
      <para>
        <caption>Documentation</caption>
        <text>
          We have always put much effort into a good documentation: all of its classes
          have their methods documented in PHPDoc-style (which was obviously adapted
          from JavaDoc), to be able to automatically create an API documentation out
          of the source code. An example:

          <code><![CDATA[
  /**
   * String-Representation of a date
   *
   * @see     php://date
   * @param   string format default 'r' Format string
   * @return  string The formatted date
   */
  function toString($format= 'r') {
    return date($format, $this->_utime);
  }]]></code>

          You can find a detailled description of the <ref type="devel" link="documentation">documentation guidelines here</ref>.
        </text>
      </para>              
      <para>
        <caption>Object hierarchy</caption>
        <text>
          All objects are instances of class "Object" or of a class, that inherits
          from that class. The only exception is class "Object" itself (as self-inheritance
          is not yet invented :).
        </text>
      </para>
      <para>
        <caption>Interfaces</caption>
        <text>
          An introduction to interfaces is given at:<br/>
          <ref type="ext" link="http://java.sun.com/docs/books/tutorial/java/interpack/interfaces.html"/>
          <br/><br/>
          <quote>
            "An interface defines a protocol of behavior that can be implemented
            by any class anywhere in the class hierarchy. An interface defines
            a set of methods but does not implement them. A class that implements
            the interface agrees to implement all the methods defined in the
            interface, thereby agreeing to certain behavior."
          </quote>
          <br/><br/>
          As interfaces are not a core feature of PHP4, the way this is handled
          within the XP framework differs a bit from what it is in Java (or will
          become in PHP5). The basic syntax is:

          <ul>
            <li>The interface itself:<code><![CDATA[  class Iterator extends Interface {
    function &next() { }
    function hasNext() { }
  }]]></code></li>
            <li>A class implementing this interface:<code><![CDATA[  class ListIterator extends Object {
    function &next() {
      // ...
    }

    function hasNext() {
      // ...
    }
  } implements(__FILE__, 'Iterator');]]></code></li>
          </ul>
          <br/>
          Interfaces may extend each other:
          <ul>
            <li>Base interface:<code><![CDATA[  class Command extends Interface {
    function invoke() { }
  }]]></code></li>
            <li>Child interface:<code><![CDATA[  class PublishCommand extends Command {
  }]]></code></li>
            <li>Implementing class:<code><![CDATA[  class TestCommand extends Object {
    function invoke() {
      // ...
    }
  } implements(__FILE__, 'PublishCommand');]]></code></li>
          </ul>
          In case PublishCommand were to define additional methods, the implementing
          class would, of course, have to implement those, too.          
          <box caption="Note">
            Failure to implement an interface fully will result in a fatal error.
          </box>
        </text>
      </para>
      <para>
        <caption>SAPIs</caption>
        <text>
          "SAPI" stands for "Server API". This name was chosen due to the fact
          that PHP also uses it within its source, e.g. sapi/cli or sapi/apache2
          <br/><br/>
          SAPIs should provide the common needs for a script intended for a
          designated purpose, e.g. the CLI (command line interface) SAPI will
          automatically provide the classes util.cmd.ParamString and util.cmd.
          Console for the user's convenience. It also sets up and output handler
          so fatal errors can be caught (which also captures all output, so make
          sure to use Console::write* instead of echo, printf etc.!) and
          displayed as a lang.Error with a stack trace printed to STDERR.
          <br/><br/>
          Another SAPI (TBI) called "soapservice" could set the fatal error
          handler to something which sends a SOAP-Fault as XML so these kinds
          of errors can be handled gracefully.
          <br/><br/>
          To make use of the new SAPI model, simply put a line such as:
          <code>  xp::sapi('cli');</code>
          directly beneath the line in which you require() the XP framework's
          core, lang.base.php.
          <br/><br/>
          As SAPI loading may *not* fail, you will have a fatal error in case
          the SAPI specified does not exist (xp::sapi('cli') tries to require_once()
          the file <tt>sapi/$name.sapi.php</tt>). The syntax for SAPIs in subdirectories
          is equal to that of uses(), e.g. xp::sapi('compat.4_2') will try to
          require_once('sapi/compat/4_2.sapi.php').
          <br/><br/>
          Note: SAPIs are not classes and therefore not to be found in the APIdoc
          overview! The coding standards for SAPI modules are also slightly different:
          SAPI modules' filenames are all in lowercase letters.
          SAPI modules may contain classes but only in lowercase letters and with
          the prefix <tt>"sapi&#183;"</tt> (the middle dot is generated by pressing Alt-Gr+.)
          SAPI modules may contain any sourcecode besides a class. This sourcecode
          will execute as soon as the file is require()`d. The documentation of any
          functions and/or classes contained in a SAPI module follows the way the
          functions and classes in lang.base.php are documented (Using // {{{ as
          the beginning of a documentation comment and // }}} as the end of it).
          Insiders will know this style from the way documentation comments are
          written within the C sourcecode of PHP).
        </text>
      </para>
      <para>
        <caption>Global functions of the framework</caption>
        <text>
          <ul>
            <li><pre>void uses(string class [, string class [, ...]])</pre>Requires one or more classes
                <code><![CDATA[  uses('io.File');
  uses('io.Folder', 'lang.System');]]></code>
                <i>Note: Failure to load a class will result in a fatal error</i>
            </li>
            <li><pre>void try(void)</pre>Begins a try/catch-block</li>
            <li><pre>bool catch(string exception, &amp;lang.Throwable e)</pre>Catches exceptions</li>
            <li><pre>null throw(lang.Throwable e)</pre>Throws an exception
                <code><![CDATA[  if (!$fd) throw(new IOException('Cannot open file'));]]></code>
            </li>
            <li><pre>void finally(void)</pre>Finally block syntactic sugar
                <code><![CDATA[  try(); {
    // ...
  } if (catch('FormatException', $e)) {
    $e->printStackTrace();
  } finally(); {
    $file->close();
    $e && exit(-1);
  }]]></code>
            </li>
            <li><pre>void implements(__FILE__, string interface [, string interface [, ...]])</pre>
                Denotes the class in this file implements the specified interface(s).
                <code><![CDATA[  class ListIterator extends Object {
    // ...
  } implements(__FILE__, 'util.Iterator');]]></code>
            </li>
            <li><pre>bool is(string class, &amp;lang.Object object)</pre>
                Checks whether a given object is of the class, a subclass or implements an interface
                <code><![CDATA[  // TRUE, Object is of class object
  is('lang.Object', new Object());
  
  // TRUE, Exception is a subclass of Throwable
  is('lang.Throwable', new Exception());
  
  // TRUE, ListIterator implements Iterator
  is('util.Iterator', new ListIterator());
  
  // FALSE
  is('text.String', new Date());]]></code>
            </li>
            <li><pre>&amp;mixed cast(&amp;mixed var [, string type= NULL])</pre>Casts a variable "NULL-safe"
                <code><![CDATA[  cast('hello', 'string') := 'hello';
  cast(NULL, 'string') := NULL]]></code>
            </li>
            <li><pre>void delete(&amp;lang.Object object)</pre>Destroys an object and calls its destructor
                <code><![CDATA[  $object= &new Object();
  delete($object);]]></code>
            </li>
            <li><pre>proto lang.Object &amp;clone(lang.Object object)</pre>Clones an object
                <code><![CDATA[  $a= &new Object();
  $b= &clone($a);]]></code>
            </li>
          </ul>
        </text>
      </para>              
      <para>
        <caption>Additional functions of the framework</caption>
        <text>
          <ul>
            <li><pre>string xp::nameOf(string name)</pre>
                Returns fully qualified class name for a PHP classname
                <code><![CDATA[  uses('io.File');
  var_dump(xp::nameOf('file')); // Outputs "io.File"]]></code>
            </li>
            <li><pre>string xp::typeOf(&amp;mixed arg)</pre>
                Returns fully qualified class name for any object or the simple type's name
                using <tt>gettype()</tt>.
                <code><![CDATA[  var_dump(xp::typeOf(new String())); // Outputs "text.String"
  var_dump(xp::typeOf(NULL));         // Outputs "NULL"]]></code>
            </li>
            <li><pre>string xp::stringOf(&amp;mixed arg)</pre>
                Returns a string representation of the given argument. Calls <tt>toString()</tt>
                for anything that extends <tt>lang.Object</tt>, <tt>var_export()</tt> otherwise.
            </li>
            <li><pre>void xp::gc(void)</pre>
                Runs the garbage collector. Only use in long-running applications and never
                inside of a try / catch block.
            </li>
            <li><pre>bool xp::errorAt(string file [, int line])</pre>
                Returns whether an error occured at the specified position
            </li>
            <li><pre>void xp::sapi(string name [, string sapi [, ... ]])</pre>
                Sets one or more SAPIs.
                <code><![CDATA[  // Loads the CGI sapi and the 4.2.x compatibility
  xp::sapi('cgi', 'compat.version4_2');]]></code>
            </li>
          </ul>
        </text>
      </para>              
    </content>
    <references>
      <ref link="tasks">Common Tasks</ref>
      <ref link="examples">Examples</ref>
      <ref link="about.future">The future of XP</ref>
      <ref link="about.install">Installation</ref>
      <ref type="ext" link="http://pear.php.net/">PEAR</ref>
      <ref type="ext" link="http://cpan.org/">CPAN</ref>
    </references>
  </main>
</document>
