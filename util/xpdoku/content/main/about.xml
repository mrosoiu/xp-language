<?xml version="1.0" encoding="iso-8859-1"?>
<document title="XP::About::Introduction">
  <main>
    <content>
      <title>An introduction</title>
      <editor>$Id$</editor>
      
      <para>
        <caption>What does "XP" mean?</caption>
        <text>"XP" stands for XML-PHP. XP is far more than that</text>
      </para>
      <para>
        <caption>What is the XP framework?</caption>
        <text>
          The XP framework:
          <ul>
            <li>is a collection of sourcecode that wraps often used
                constructs into easy-to-use classes,
            </li>
            <li>contains an implementations of a XML/XSL concept [PUSTEFIX] with which
                it is possible to completely separate programming and design from each other,
            </li>
            <li>has been programmed with the Zend Engine 2 [ZE2] in mind and will once use
                it as soon as ZE2 is stable.
                (A high priority lies on an easy portability onto ZE2 - this can be
                done with three regular expressions and the adoption of a single file)
                and
            </li>
            <li>has been made for any kind of application: commandline programs,
                applications with GUI [GTK-PGP], web applications with XML/XSL or
                just simple HTML.
            </li>
          </ul>
        </text>
      </para>              
      <para>
        <caption>Idea</caption>
        <text>
          The idea of a completely object-oriented framework is not new. There exist
          some frameworks like CPAN for Perl or PEAR in PHP. This implementation is
          heavily based on the structure of Java, in whose CLASS_PATH exist several
          directores ("lang", "io", "net", etc.). For non standardised extensions the
          domainname has been chosen as unique directory: classes specific to
          Schlund+Partner AG reside in ~/de/schlund/, classes specific to Apache reside
          in ~/org/apache/. All the classes can be loaded by using the keyword import,
          while the exact location of the class in the filesystem has not to be known 
          to the program. The separation char has been chosen '.' instead of '/' or '\'.
          In the XP framework i is handled the same way, by the little difference that
          instead of "import" we use "uses" (import already is a language-keyword in
          ZE2).
          
          The original motivation for the creation of such a framework was the change
          of the design on hosting.1und1.com (formely puretec.de). The code should
          be reuseable, independent and where possible multi-purposed (this includes
          the whole backend which is realised in crons). A simple implementation à la
          sybase_connect([...]) or die ('Database not available') was not an option.
          Errors like that have to be catched and handled by the application.
        </text>
      </para>              
      <para>
        <caption>Basics:</caption>
        <text>
          The XP framework offers some advantages as basis:
          <ul>
            <li>An implementation of exceptions for the Zend Engine 1
                This will be obsoleted in ZE2, but they will work
                identically in ZE2.
            </li>
            <li>Unified constructors and destructors
                This is also contained in ZE2 and will be obsoleted after
                an update to PHP5.
            </li>
            <li>A function uses() which knows where to find the classes
            </li>
          </ul>

          A PHP script which utilizes the XP framework, has to start with the following
          line of code:

          <code><![CDATA[  require('lang.base.php'); ]]></code>

          The file included by this command contains the basics for the framework.
          Thus it is recommended to change the Include-path in the php.ini, so the
          path need not to be set by every script.
        </text>
      </para>              
      <para>
        <caption>An example:</caption>
        <text>
          Sehen wir uns einmal folgendes Skript an:

          <code><![CDATA[  // {{{ main
  require('lang.base.php');
  uses('io.File');

  $file= &new File('file_does_not_exist.txt');
  printf("Trying to read %s...\n", $file->filename);
  try(); {
    $file->open(FILE_MODE_READ);
    $str= $file->readLine();
    $file->close();
  } if (catch('FileNotFoundException', $e)) {
  
    // File was not found
    die($e->printStackTrace());
  } if (catch('IOException', $e)) {
  
    // Sone other I/O exception occured (e.g. "Permission denied")
    die($e->printStackTrace());
  } 
  printf("Success: line ist '%s'\n", $str);
  // }}}]]></code>

          In line three the class /path/to/skeleton/io/File.class.php is included. It
          wraps the PHP-functions, that handle files (fopen, fread, ...) and embeds
          exceptions into the functions. 

          The syntax of <tt>uses</tt> is much more sexy than using something like 
          <tt>require_once($DOCUMENT_ROOT."/../includes/io/File.class.php")</tt> - 
          
          a) <tt>uses</tt> knows where the classes are, 
          b) we have a unified path separator and 
          c) we can ommit the standardized .class.php at the end.

          Sure - this also works with include_path, but it is not allowed to everyone
          to change the include path (mass hosting). Further, the uses()-function allows
          to include multiple classes at one. E.g.:

          <code><![CDATA[  uses('io.File', 'util.Date'); ]]></code>

          Afterwards a block of code (line eight to eleven) is included in a try/catch
          block, Within this block, multiple errors could occur:

          1.) The file is not found
          2.) The file cannot be opened (is exclusively locked by another process)
          3.) While reading the file, an error occurs (quite unlikely but possible)
          4.) While closing the file, an error can occur (which is even more unlikely
              but nevertheless possible).

          In case one of the functions fail, it throws a typed exception which we can
          catch with catch(). In line twelve we test whether the error already occured
          while opening the file. Line 14 checks the more unlikely case (error when
          reading or closing the file).

          A sample output for case 1 (file not found) looks like this:

          <pre><![CDATA[
Trying to read /tmp/file_does_not_exist.txt:
Exception io.FileNotFoundException (/tmp/file_does_not_exist.txt)
          ]]></pre>

          Does the file exists, but cannot be read, the output could look like this:

          <pre><![CDATA[
Trying to read /tmp/file_does_not_exist.txt:
Exception io.IOException (cannot open /tmp/file_does_not_exist.txt mode r)
  at File.class.php:open (line 101:fopen("/tmp/file_does_not_exist.txt", "r") - 
  Permission denied)
  at File.class.php:close (line 381:fclose(): supplied argument is not a 
  valid File-Handle resource)
          ]]></pre>

          As you can see, in opposite to Java, ZE2 or any other programming language
          that implements an exception model, the code within the try-block is executed
          completely "due to limitations of Zend Engine 1". This is somewhat a dirty
          fact which will change with ZE2. Uncaught exceptions lead to the abortion
          of the program.

          This example also shows the ease-of-use of the file object.

          Example:
          <pre><![CDATA[
Exception info.binford6100.db.Message.MessageException (statement failed)
  at MessagePart.class.php:create (line 71:Undefined property:  subject)
  at MessagePart.class.php:create (line 71:Undefined property:  abstract)
  at SPSybase.class.php:query (line 140:Sybase:  Server message:  part not found. 
    Specify owner.objectname or use sp_help to check whether the object exists 
    (sp_help may produce lots of output). (severity 16, procedure N/A)
  )
  at MessagePart.class.php:create (line 97:Undefined variable:  data)
  in MESSAGE_CTX_GLOBAL
          ]]></pre>
        </text>
      </para>              
      <para>
        <caption>Code:</caption>
        <text>
          The code follows strict guidelines:
          <ul>
            <li>the style "Studly Caps"</li>
            <li>an intending depth of 2 chars</li>
            <li>the burden to not to output any warnings or notices at an error reporting level 
              of E_ALL (most verbose)</li>
          </ul>
          You can find the complete coding standards <ref link="about.coding">here</ref>.
        </text>
      </para>              
      <para>
        <caption>Documentation:</caption>
        <text>
          We have always put much effort into a good documentation: all of its classes
          have their methods documented in PHPDoc-style (which was obviously adapted
          from JavaDoc), to be able to automatically create an API documentation out
          of the source code. An example:

          <code><![CDATA[
  /**
   * String-Representation of a date
   *
   * @see     php://date
   * @param   string format default 'r' Format string
   * @return  string The formatted date
   */
  function toString($format= 'r') {
    return date($format, $this->_utime);
  }]]></code>

          You can find a detailled description of the <ref link="about.coding">documentation guidelines here</ref>.
        </text>
      </para>              
      <para>
        <caption>Object hierarchy:</caption>
        <text>
          All objects are instances of class "Object" or of a class, that inherits
          from that class. The only exception is class "Object" itself (as self-inheritance
          is not yet invented :).
        </text>
      </para>              
      <para>
        <caption>Global functions of the framework</caption>
        <text>
          <ul>
            <li>string reflect(string s) - Creates the classname out of the filename of a class
                <code><![CDATA[  reflect('IOException.class.php'); // := 'IOException']]></code>
            </li>
            <li>void uses(string s [, string t, [...]]) - Inlcudes one or more classes
                <code><![CDATA[  uses('io.File');
  uses('io.Folder', 'lang.System');]]></code>
            </li>
            <li>void try(void) - begins a try/catch-block</li>
            <li>bool catch(string exception, &amp;object e) - Catches exceptions
                <code><![CDATA[  if (catch('IOException', $e)) die($e->getStackTrace());]]></code>
            </li>
            <li>void throw(object e) - throws an exception
                <code><![CDATA[  if (!$fd) throw(new IOException('cannot open file'));]]></code>
            </li>
            <li>&amp;mixed cast(&amp;mixed var [, string type= NULL]) - casts a variable "NULL-safe"
                <code><![CDATA[  cast('hello', 'string') := 'hello';
  cast(NULL, 'string') := NULL]]></code>
            </li>
            <li>bool is_error(void) - returns PHP error messages or - in case none exist - returns FALSE
                <code><![CDATA[  if ($e= is_error(
    $a= preg_match('/'.$userInput.'/', $str);
  )) return throw(new FormatException($e));]]></code>
            </li>
            <li>void destroy(void) - Garbage Collector</li>
            <li>error(int errno, string errstr, string errfile, string errline) - Errorhandler</li>
          </ul>
        </text>
      </para>              
    </content>
    <references>
      <ref link="tasks">Common Tasks</ref>
      <ref link="about.doc">Writing XPDoc</ref>
      <ref link="about.future">The future of XP</ref>
      <ref link="about.cvs">CVS guidelines</ref>
      <ref link="about.install">Installation</ref>
      <ref link="about.codefreeze">Codefreeze in XP</ref>
      <ref link="about.coding">Coding standards</ref>
      <ref link="about.mailinglist">Developers Mailinglist</ref>
      <ref type="ext" link="http://pear.php.net/">PEAR</ref>
      <ref type="ext" link="http://cpan.org/">CPAN</ref>
    </references>
  </main>
</document>
