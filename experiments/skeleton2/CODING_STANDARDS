XP: Coding Standards for PHP5
========================================================================
$Id$

* This extends previously defined coding standards.
---------------------------------------------------
Include everything from PHP4

* References
------------
As the Zend Engine 2 passes arguments as handles, the & is no longer
needed. Be aware of the fact that get a copy of an object, you must
use the __clone() method.

* Class constants
-----------------
Instead of using define, use the new keyword "const". 

Example:
Old code: define('FILE_MODE_READ',  'r');
New code: class File extends Stream {
            const MODE_READ = 'r';
          }

* Constructors and destructors
------------------------------
The object class no longer features __construct and __destruct.

* Singletons
------------
The instance variable shall always be denoted as

  protected static 
    $instance = NULL;

or

  private static 
    $instance = NULL;
    
, the latter in the case this class has no need of subclassing.

The accessor is a public static function getInstance().

Example:
  namespace rdbms {
    class ConnectionManager extends Object {
      private static
        $instance   = NULL;
        
      public static function getInstance() {
        if (!isset(self::$instance)) self::$instance= new ConnectionManager();
        return self::$instance;
      }
    }
  }
  
The destructor in a class that may only be used as a singleton
shall not be public (either private or protected).

* try/throw/catch
-----------------
a. The form of a try/catch block
   try {
     // [...Critical code here...]
   } catch (FormatException $e) {
     // [..Exception handling code here...]
   }
   
b. Throw  
   throw new XPException([...Arguments...]);

A discussion on what to catch when can be found at:
- http://www.javaworld.com/javaworld/javatips/jw-javatip134.html?  
  Java Tip 134: When catching exceptions, don't cast your net too wide 

Of course, not all arguments there (especially the compile-time 
checks) apply to PHP; it's interesting nevertheless.
  
* File names
------------
File names for classes and interfaces are equal and must conform to 
the pattern "<Name>.class.php".

* Access modifiers
------------------
The keywords "public", "private" and "protected" are to be used to 
specify member and method access levels. The keywords "static" and
"final" should be specified, in this order.

Method notation examples:
- public function getName() { }

- protected function recurse() { }

- private function setDate() { }

- public static function main() { }

- public static final function toString() { }


Member variable notation examples:
- protected
    $members    = array(),
    $id         = -1;
    
- private static 
    $instance   = NULL;
    
- public
    $date       = NULL,
    $message    = '';
    
* Method calls
--------------
For method calls, instead of using $this->, self:: shall be used.

Example:
- Instead of
  public function toString() {
    return 'Member#'.$this->id.'{'.$this->getName().'}';
  }
  use the following:
  public function toString() {
    return 'Member#'.$this->id.'{'.self::getName().'}';
  }

self:: also works when the method has been inherited and it is the
same syntax in static method calls.

* Type hints
------------
Type hints are to be used wherever possible. Note: When a method with
a type hinted parameter is called with a wrong type of argument, this
results in a fatal error. Use "instanceof" in case this is not acceptible
(e.g., in a SOAP service).

* Interfaces vs. abstract classes
---------------------------------
The difference between an interface and an abstract class is that an
abstract class may contain code, an interface not. Also, classes can 
implement multiple interfaces, but not multiple classes.

For discussion on this matter, see:
- http://www.google.com/search?q=Interfaces+abstract+classes

Abstract classes are to be notated as:
- abstract class Transformer extends Object { 
    // [...]
  }

* Dereferencing
---------------
Dereferencing is a nice method to write code such as:
- $conn= ConnectionManager::getInstance()->getConnection($aliasname);
- echo $article->addRevision(new Revision())->getDate()->toString();

Be aware of the fact that in case one of the calls in this chain 
returns a non-object, it will result in a fatal error. Either use
type hints or a combination of instanceof and 
IllegalArgumentException if you want to be on the safe side.

<EOF>
