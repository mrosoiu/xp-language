Index: Zend/zend.h
===================================================================
RCS file: /repository/ZendEngine2/zend.h,v
retrieving revision 1.265
diff -u -r1.265 zend.h
--- Zend/zend.h	30 Oct 2004 22:56:59 -0000	1.265
+++ Zend/zend.h	3 Nov 2004 16:11:39 -0000
@@ -255,6 +255,8 @@
  */
 typedef struct _zval_struct zval;
 typedef struct _zend_class_entry zend_class_entry;
+typedef struct _zend_package_entry zend_package_entry;
+typedef struct _zend_annotation zend_annotation;
 
 typedef struct _zend_object {
 	zend_class_entry *ce;
@@ -344,6 +346,17 @@
 	struct _zend_module_entry *module;
 };
 
+struct _zend_package_entry {
+	char *name;
+	zend_uint name_length;
+};
+
+struct _zend_annotation {
+	char *name;
+	zend_uint name_length;
+	zval *value;
+};
+
 #include "zend_stream.h"
 typedef struct _zend_utility_functions {
 	void (*error_function)(int type, const char *error_filename, const uint error_lineno, const char *format, va_list args) ZEND_ATTRIBUTE_PTR_FORMAT(printf, 4, 0);
Index: Zend/zend_API.c
===================================================================
RCS file: /repository/ZendEngine2/zend_API.c,v
retrieving revision 1.269
diff -u -r1.269 zend_API.c
--- Zend/zend_API.c	2 Nov 2004 13:10:37 -0000	1.269
+++ Zend/zend_API.c	3 Nov 2004 16:11:40 -0000
@@ -1313,6 +1313,9 @@
 			internal_function->return_reference = ptr->arg_info[0].return_reference;
 		} else {
 			internal_function->arg_info = NULL;
+			internal_function->throws = NULL;
+			internal_function->num_throws = 0;
+			internal_function->annotations = NULL;
 			internal_function->num_args = 0;
 			internal_function->required_num_args = 0;
 			internal_function->pass_rest_by_reference = 0;
Index: Zend/zend_builtin_functions.c
===================================================================
RCS file: /repository/ZendEngine2/zend_builtin_functions.c,v
retrieving revision 1.254
diff -u -r1.254 zend_builtin_functions.c
--- Zend/zend_builtin_functions.c	26 Oct 2004 23:25:05 -0000	1.254
+++ Zend/zend_builtin_functions.c	3 Nov 2004 16:11:41 -0000
@@ -1205,45 +1205,81 @@
 	zend_uint mask = va_arg(args, zend_uint);
 	zend_uint comply = va_arg(args, zend_uint);
 	zend_uint comply_mask = (comply)? mask:0;
+	char *package = va_arg(args, char *);
+	int package_len = va_arg(args, int);
 	zend_class_entry *ce  = *pce;
 
 	if ((hash_key->nKeyLength==0 || hash_key->arKey[0]!=0)
-		&& (comply_mask == (ce->ce_flags & mask))) {
+		&& (comply_mask == (ce->ce_flags & mask))
+        && (package ? 0 == memcmp(package, hash_key->arKey, MIN(hash_key->nKeyLength, package_len)) : 1)
+        ) {
 		add_next_index_stringl(array, ce->name, ce->name_length, 1);
 	}
 	return ZEND_HASH_APPLY_KEEP;
 }
 
 
-/* {{{ proto array get_declared_classes()
+/* {{{ proto array get_declared_classes([string package])
    Returns an array of all declared classes. */
 ZEND_FUNCTION(get_declared_classes)
 {
 	zend_uint mask = ZEND_ACC_INTERFACE;
 	zend_uint comply = 0;
+	char *package = NULL;
+	char *lc_name = NULL;
+	int package_len;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|s", &package, &package_len) == FAILURE) {
+		return;
+	}
 
-	if (ZEND_NUM_ARGS() != 0) {
-		ZEND_WRONG_PARAM_COUNT();
+	/* Create lowercase package name and concate a "~" */
+	if (package) {
+		package_len++;
+		lc_name = do_alloca(package_len + 1);
+		zend_str_tolower_copy(lc_name, package, package_len);
+		lc_name[package_len - 1]= '~';
+		lc_name[package_len]= 0;
 	}
 
 	array_init(return_value);
-	zend_hash_apply_with_arguments(EG(class_table), (apply_func_args_t) copy_class_or_interface_name, 3, return_value, mask, comply);
+	zend_hash_apply_with_arguments(EG(class_table), (apply_func_args_t) copy_class_or_interface_name, 5, return_value, mask, comply, lc_name, package_len);
+
+	if (lc_name) {
+		free_alloca(lc_name);
+	}
 }
 /* }}} */
 
-/* {{{ proto array get_declared_interfaces()
+/* {{{ proto array get_declared_interfaces([string package])
    Returns an array of all declared interfaces. */
 ZEND_FUNCTION(get_declared_interfaces)
 {
 	zend_uint mask = ZEND_ACC_INTERFACE;
 	zend_uint comply = 1;
-	
-	if (ZEND_NUM_ARGS() != 0) {
-		ZEND_WRONG_PARAM_COUNT();
+	char *package = NULL;
+	char *lc_name = NULL;
+	int package_len;
+
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|s", &package, &package_len) == FAILURE) {
+		return;
+	}
+
+	/* Create lowercase package name and concate a "~" */
+	if (package) {
+		package_len++;
+		lc_name = do_alloca(package_len + 1);
+		zend_str_tolower_copy(lc_name, package, package_len);
+		lc_name[package_len - 1]= '~';
+		lc_name[package_len]= 0;
 	}
 
 	array_init(return_value);
-	zend_hash_apply_with_arguments(EG(class_table), (apply_func_args_t) copy_class_or_interface_name, 3, return_value, mask, comply);
+	zend_hash_apply_with_arguments(EG(class_table), (apply_func_args_t) copy_class_or_interface_name, 5, return_value, mask, comply, lc_name, package_len);
+
+	if (lc_name) {
+		free_alloca(lc_name);
+	}
 }
 /* }}} */
 
Index: Zend/zend_compile.c
===================================================================
RCS file: /repository/ZendEngine2/zend_compile.c,v
retrieving revision 1.600
diff -u -r1.600 zend_compile.c
--- Zend/zend_compile.c	16 Oct 2004 23:17:58 -0000	1.600
+++ Zend/zend_compile.c	3 Nov 2004 16:11:43 -0000
@@ -125,7 +125,10 @@
 	zend_stack_init(&CG(foreach_copy_stack));
 	zend_stack_init(&CG(object_stack));
 	zend_stack_init(&CG(declare_stack));
+	zend_stack_init(&CG(annotation_stack));
+	zend_stack_init(&CG(class_stack));
 	CG(active_class_entry) = NULL;
+	CG(active_package_entry) = NULL;
 	zend_llist_init(&CG(list_llist), sizeof(list_llist_element), NULL, 0);
 	zend_llist_init(&CG(dimension_llist), sizeof(int), NULL, 0);
 	zend_stack_init(&CG(list_stack));
@@ -164,6 +167,8 @@
 	zend_stack_destroy(&CG(foreach_copy_stack));
 	zend_stack_destroy(&CG(object_stack));
 	zend_stack_destroy(&CG(declare_stack));
+	zend_stack_destroy(&CG(annotation_stack));
+	zend_stack_destroy(&CG(class_stack));
 	zend_stack_destroy(&CG(list_stack));
 	zend_hash_destroy(&CG(filenames_table));
 	zend_llist_destroy(&CG(open_files));
@@ -508,6 +513,55 @@
 	}
 }
 
+void zend_do_throws(znode *throws_znode TSRMLS_DC)
+{
+	zend_function *fptr = (zend_function *)CG(active_op_array);
+	zend_class_entry **pce;
+
+	MANGLE_CLASS_NAME(throws_znode);
+	if (zend_lookup_class(throws_znode->u.constant.value.str.val, throws_znode->u.constant.value.str.len, &pce TSRMLS_CC) == FAILURE) {
+		zend_error(E_COMPILE_ERROR, "Undefined class '%s' in throws list of %s::%s()", throws_znode->u.constant.value.str.val, CG(active_class_entry)->name, fptr->common.function_name);
+		/* Bails out */
+	}
+
+	fptr->common.throws = (zend_class_entry **) erealloc(fptr->common.throws, sizeof(zend_class_entry *) * (fptr->common.num_throws + 1));
+	fptr->common.throws[fptr->common.num_throws] = *pce;
+	fptr->common.num_throws++;
+	
+	FREE_PNODE(throws_znode);
+} 
+
+void zend_do_annotation(znode *name, znode *value TSRMLS_DC)
+{
+	zend_annotation annotation;
+
+	annotation.name = estrndup(name->u.constant.value.str.val, name->u.constant.value.str.len);
+	annotation.name_length = name->u.constant.value.str.len;
+	FREE_PNODE(name);
+	ALLOC_ZVAL(annotation.value);
+	if (value) {
+		*annotation.value = value->u.constant;
+	} else {
+		INIT_PZVAL(annotation.value);
+		annotation.value->type = IS_NULL;
+	}
+	zend_stack_push(&CG(annotation_stack), (void *) &annotation, sizeof(annotation));
+}
+
+void zend_do_import(znode *classname, znode *alias TSRMLS_DC)
+{
+	zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);
+
+	opline->opcode = ZEND_IMPORT;
+	opline->op1 = *classname;
+	if (!alias) {
+		SET_UNUSED(opline->op2);
+	} else {
+		opline->op2 = *alias;
+	}
+	opline->result.u.EA.type |= EXT_TYPE_UNUSED;
+} 
+
 static zend_bool opline_is_fetch_this(zend_op *opline TSRMLS_DC)
 {
 	if ((opline->opcode == ZEND_FETCH_W) && (opline->op1.op_type == IS_CONST)
@@ -1162,7 +1216,7 @@
 {
 	char lcname[16];
 	int name_len;
-
+    
 	zend_do_extended_info(TSRMLS_C);
 	zend_do_return(NULL, 0 TSRMLS_CC);
 	zend_do_handle_exception(TSRMLS_C);
@@ -1182,10 +1236,24 @@
 		}		
 	}
 
+	/* Copy annotations stack to annotation list */
+    if (zend_stack_count(&CG(annotation_stack)) > 0) {
+    	zend_annotation *annotation;
+		zend_function *fptr = (zend_function *)CG(active_op_array);
+
+		ALLOC_HASHTABLE(fptr->common.annotations);
+		zend_hash_init(fptr->common.annotations, 2, NULL, ZVAL_PTR_DTOR, 0);
+
+		while (zend_stack_top(&CG(annotation_stack), (void **) &annotation) == SUCCESS) {
+			zend_hash_add(fptr->common.annotations, annotation->name, annotation->name_length + 1, (void **) &annotation->value, sizeof(zval *), NULL);
+			efree(annotation->name);
+			zend_stack_del_top(&CG(annotation_stack));
+		}
+	}
+
 	CG(active_op_array)->line_end = zend_get_compiled_lineno(TSRMLS_C);
 	CG(active_op_array) = function_token->u.op_array;
 
-
 	/* Pop the switch and foreach seperators */
 	zend_stack_del_top(&CG(switch_cond_stack));
 	zend_stack_del_top(&CG(foreach_copy_stack));
@@ -1215,9 +1283,10 @@
 	cur_arg_info->pass_by_reference = pass_by_reference;
 
 	if (class_type->op_type != IS_UNUSED) {
+		MANGLE_CLASS_NAME(class_type);
 		cur_arg_info->class_name = class_type->u.constant.value.str.val;
 		cur_arg_info->class_name_len = class_type->u.constant.value.str.len;
-		cur_arg_info->allow_null = 0;
+		cur_arg_info->allow_null = (initialization != NULL);
 	} else {
 		cur_arg_info->class_name = NULL;
 		cur_arg_info->class_name_len = 0;
@@ -1347,6 +1416,7 @@
 				zval_dtor(&class_name->u.constant);
 				break;
 			default:
+				MANGLE_CLASS_NAME(class_name);
 				opline->op2 = *class_name;
 				break;
 		}
@@ -1854,7 +1924,8 @@
 		return 1; /* method doesn't exist in child, copy from parent */
 	}
 
-	if (parent->common.fn_flags & ZEND_ACC_ABSTRACT
+	if (!(parent->common.scope->ce_flags & ZEND_ACC_INTERFACE)
+		&& parent->common.fn_flags & ZEND_ACC_ABSTRACT
 		&& parent->common.scope != (child->common.prototype ? child->common.prototype->common.scope : child->common.scope)
 		&& child->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_IMPLEMENTED_ABSTRACT)) {
 		zend_error(E_COMPILE_ERROR, "Can't inherit abstract function %s::%s() (previously declared abstract in %s)", 
@@ -2529,13 +2600,16 @@
 	zend_op *opline;
 	int doing_inheritance = 0;
 	zend_class_entry *new_class_entry = emalloc(sizeof(zend_class_entry));
-	char *lcname = zend_str_tolower_dup(class_name->u.constant.value.str.val, class_name->u.constant.value.str.len);
+	char *lcname;
 
 	if (CG(active_class_entry)) {
 		zend_error(E_COMPILE_ERROR, "Class declarations may not be nested");
 		return;
 	}
 
+	MANGLE_CLASS_NAME(class_name);
+	lcname = zend_str_tolower_dup(class_name->u.constant.value.str.val, class_name->u.constant.value.str.len);
+ 
 	if (!(strcmp(lcname, "self") && strcmp(lcname, "parent"))) {
 		efree(lcname);
 		zend_error(E_COMPILE_ERROR, "Cannot use '%s' as class name as it is reserved", class_name->u.constant.value.str.val);
@@ -2638,6 +2712,97 @@
 	CG(active_class_entry) = NULL;
 }
 
+void zend_do_begin_instance_creation(TSRMLS_D)
+{
+	zend_op *opline;
+	zval lambda;
+	zend_class_entry **pce;
+	zend_class_entry *new_class_entry = emalloc(sizeof(zend_class_entry));
+
+	/* Find class declaring opcode */
+	opline = &CG(active_op_array)->opcodes[CG(active_op_array)->last - 4];
+	if (opline->opcode == ZEND_EXT_FCALL_BEGIN) {
+		opline--;
+	}
+
+	if (opline->op2.op_type != IS_CONST) {
+		zend_error(E_COMPILE_ERROR, "Cannot use instance creation expression with variables");
+		/* Bails out */
+	}
+
+	if (zend_lookup_class(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len, &pce TSRMLS_CC) == FAILURE) {
+		zend_error(E_COMPILE_ERROR, "Undefined class '%s' in instance creation", opline->op2.u.constant.value.str.val);
+		/* Bails out */
+	}
+	
+	/* Create lambda name */
+	build_runtime_defined_function_key(&lambda, opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len TSRMLS_CC);
+	new_class_entry->name= Z_STRVAL(lambda);
+	new_class_entry->name_length= Z_STRLEN(lambda);
+
+	/* Overwrite original opcode's class name */
+	efree(opline->op2.u.constant.value.str.val);
+	opline->op2.u.constant.value.str.val = estrndup(new_class_entry->name, new_class_entry->name_length);
+	opline->op2.u.constant.value.str.len = new_class_entry->name_length;
+	
+	/* Declare class */
+	new_class_entry->type = ZEND_USER_CLASS;
+	zend_initialize_class_data(new_class_entry, 1 TSRMLS_CC);
+	new_class_entry->filename = zend_get_compiled_filename(TSRMLS_C);
+	new_class_entry->line_start = zend_get_compiled_lineno(TSRMLS_C);
+	new_class_entry->ce_flags |= ZEND_ACC_FINAL;
+	new_class_entry->parent = *pce;
+
+	/* Add to class table */
+	{
+		char *lcname = zend_str_tolower_dup(new_class_entry->name, new_class_entry->name_length);
+
+		zend_hash_add(CG(class_table), lcname, new_class_entry->name_length + 1, &new_class_entry, sizeof(zend_class_entry *), NULL);
+		efree(lcname);
+	}
+
+	zend_stack_push(&CG(class_stack), (void **) &CG(active_class_entry), sizeof(zend_class_entry*));
+	CG(active_class_entry) = new_class_entry;
+}
+
+void zend_do_end_instance_creation(TSRMLS_D)
+{
+	if (CG(active_class_entry)->parent->ce_flags & ZEND_ACC_INTERFACE) {
+		zend_uint num_interfaces = ++CG(active_class_entry)->num_interfaces;
+
+		CG(active_class_entry)->interfaces = (zend_class_entry **) erealloc(CG(active_class_entry)->interfaces, sizeof(zend_class_entry *) * num_interfaces);
+		CG(active_class_entry)->interfaces[num_interfaces - 1]= CG(active_class_entry)->parent;
+		zend_do_implement_interface(CG(active_class_entry), CG(active_class_entry)->parent TSRMLS_CC);
+		CG(active_class_entry)->parent= NULL;
+	} else {
+		zend_do_inheritance(CG(active_class_entry), CG(active_class_entry)->parent TSRMLS_CC);
+	}
+
+	zend_stack_top(&CG(class_stack), (void **) &CG(active_class_entry));
+	zend_stack_del_top(&CG(class_stack));
+}
+
+void zend_do_begin_package_declaration(znode *package_name TSRMLS_DC)
+{
+   if (strcmp(package_name->u.constant.value.str.val, "main") == 0) {
+	   zend_error(E_COMPILE_ERROR, "Cannot use 'main' as package name as it is reserved");
+   } else {
+	   zend_package_entry *new_package_entry = emalloc(sizeof(zend_package_entry));
+
+	   new_package_entry->name = package_name->u.constant.value.str.val;
+	   new_package_entry->name_length = package_name->u.constant.value.str.len;
+	   zend_str_tolower(new_package_entry->name, new_package_entry->name_length);
+	   CG(active_package_entry) = new_package_entry;
+   }
+}
+
+void zend_do_end_package_declaration(znode *package_name TSRMLS_DC)
+{
+   FREE_PNODE(package_name);
+   efree(CG(active_package_entry));
+   CG(active_package_entry) = NULL;
+}
+ 
 
 void zend_do_implements_interface(znode *interface_znode TSRMLS_DC)
 {
Index: Zend/zend_compile.h
===================================================================
RCS file: /repository/ZendEngine2/zend_compile.h,v
retrieving revision 1.297
diff -u -r1.297 zend_compile.h
--- Zend/zend_compile.h	27 Oct 2004 17:58:45 -0000	1.297
+++ Zend/zend_compile.h	3 Nov 2004 16:11:44 -0000
@@ -45,6 +45,23 @@
         CG(doc_comment) = NULL;  \
         CG(doc_comment_len) = 0; \
     }
+#define MANGLE_MAIN_LEN sizeof("main~") - 1
+#define MANGLE_CLASS_NAME(class_name) \
+	if (memcmp(class_name->u.constant.value.str.val, "main~", MANGLE_MAIN_LEN) == 0) { \
+		class_name->u.constant.value.str.len -= MANGLE_MAIN_LEN; \
+		memcpy(class_name->u.constant.value.str.val, class_name->u.constant.value.str.val + MANGLE_MAIN_LEN, class_name->u.constant.value.str.len); \
+		class_name->u.constant.value.str.val[class_name->u.constant.value.str.len] = 0; \
+	} else if (CG(active_package_entry) && !memchr(class_name->u.constant.value.str.val, '~', class_name->u.constant.value.str.len)) { \
+		int len= CG(active_package_entry)->name_length + 1 + class_name->u.constant.value.str.len; \
+		char *tmp= estrndup(class_name->u.constant.value.str.val, class_name->u.constant.value.str.len); \
+		class_name->u.constant.value.str.val= (char*) erealloc(class_name->u.constant.value.str.val, len + 1); \
+		memcpy(class_name->u.constant.value.str.val, CG(active_package_entry)->name, CG(active_package_entry)->name_length); \
+		memcpy(class_name->u.constant.value.str.val+ CG(active_package_entry)->name_length, "~", sizeof("~")); \
+		memcpy(class_name->u.constant.value.str.val+ CG(active_package_entry)->name_length+ 1, tmp, class_name->u.constant.value.str.len); \
+		class_name->u.constant.value.str.val[len]= 0; \
+		class_name->u.constant.value.str.len= len; \
+		efree(tmp); \
+	}
 
 typedef struct _zend_op_array zend_op_array;
 typedef struct _zend_op zend_op;
@@ -170,6 +187,9 @@
 	zend_arg_info *arg_info;
 	zend_bool pass_rest_by_reference;
 	unsigned char return_reference;
+	zend_class_entry **throws;
+	zend_uint num_throws;
+	HashTable *annotations;
 	/* END of common elements */
 
 	zend_uint *refcount;
@@ -224,6 +244,9 @@
 	zend_arg_info *arg_info;
 	zend_bool pass_rest_by_reference;
 	unsigned char return_reference;
+	zend_class_entry **throws;
+	zend_uint num_throws;
+	HashTable *annotations;
 	/* END of common elements */
 
 	void (*handler)(INTERNAL_FUNCTION_PARAMETERS);
@@ -245,6 +268,9 @@
 		zend_arg_info *arg_info;
 		zend_bool pass_rest_by_reference;
 		unsigned char return_reference;
+		zend_class_entry **throws;
+		zend_uint num_throws;
+		HashTable *annotations;
 	} common;
 	
 	zend_op_array op_array;
@@ -424,6 +450,8 @@
 
 void zend_do_begin_class_declaration(znode *class_token, znode *class_name, znode *parent_class_name TSRMLS_DC);
 void zend_do_end_class_declaration(znode *class_token, znode *parent_token TSRMLS_DC);
+void zend_do_begin_package_declaration(znode *package_name TSRMLS_DC);
+void zend_do_end_package_declaration(znode *package_name TSRMLS_DC);
 void zend_do_declare_property(znode *var_name, znode *value, zend_uint access_type TSRMLS_DC);
 void zend_do_declare_implicit_property(TSRMLS_D);
 void zend_do_declare_class_constant(znode *var_name, znode *value TSRMLS_DC);
@@ -486,6 +514,16 @@
 
 void zend_do_abstract_method(znode *function_name, znode *modifiers, znode *body TSRMLS_DC);
 
+void zend_do_throws(znode *throws_znode TSRMLS_DC);
+
+void zend_do_annotation(znode *name, znode *value TSRMLS_DC);
+
+void zend_do_import(znode *classname, znode *alias TSRMLS_DC);
+
+void zend_do_begin_instance_creation(TSRMLS_D);
+
+void zend_do_end_instance_creation(TSRMLS_D);
+
 ZEND_API void function_add_ref(zend_function *function);
 
 #define INITIAL_OP_ARRAY_SIZE 64
Index: Zend/zend_exceptions.c
===================================================================
RCS file: /repository/ZendEngine2/zend_exceptions.c,v
retrieving revision 1.74
diff -u -r1.74 zend_exceptions.c
--- Zend/zend_exceptions.c	30 Oct 2004 10:13:27 -0000	1.74
+++ Zend/zend_exceptions.c	3 Nov 2004 16:11:45 -0000
@@ -28,6 +28,7 @@
 #include "zend_interfaces.h"
 #include "zend_exceptions.h"
 
+zend_class_entry *default_iexception_ce;
 zend_class_entry *default_exception_ce;
 zend_class_entry *error_exception_ce;
 static zend_object_handlers default_exception_handlers;
@@ -554,16 +555,35 @@
 	{NULL, NULL, NULL}
 };
 
+static zend_function_entry default_iexception_functions[] = {
+	ZEND_ABSTRACT_ME(exception, getMessage, NULL)
+	ZEND_ABSTRACT_ME(exception, getFile, NULL)
+	ZEND_ABSTRACT_ME(exception, getLine, NULL)
+	ZEND_ABSTRACT_ME(exception, __toString, NULL)
+	{NULL, NULL, NULL}
+};
+
 void zend_register_default_exception(TSRMLS_D)
 {
 	zend_class_entry ce;
 
+	INIT_CLASS_ENTRY(ce, "IException", default_iexception_functions);
+	default_iexception_ce = zend_register_internal_class(&ce TSRMLS_CC);
+	default_iexception_ce->ce_flags = ZEND_ACC_ABSTRACT | ZEND_ACC_INTERFACE;
+
 	INIT_CLASS_ENTRY(ce, "Exception", default_exception_functions);
 	default_exception_ce = zend_register_internal_class(&ce TSRMLS_CC);
 	default_exception_ce->create_object = zend_default_exception_new; 
 	memcpy(&default_exception_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));
 	default_exception_handlers.clone_obj = NULL;
 
+	/* Implement the IException interface */
+	{
+		zend_uint num_interfaces = ++default_exception_ce->num_interfaces;
+		default_exception_ce->interfaces = (zend_class_entry **) realloc(default_exception_ce->interfaces, sizeof(zend_class_entry *) * num_interfaces);
+		default_exception_ce->interfaces[num_interfaces - 1] = default_iexception_ce;
+	}
+
 	zend_declare_property_string(default_exception_ce, "message", sizeof("message")-1, "", ZEND_ACC_PROTECTED TSRMLS_CC);
 	zend_declare_property_string(default_exception_ce, "string", sizeof("string")-1, "", ZEND_ACC_PRIVATE TSRMLS_CC);
 	zend_declare_property_long(default_exception_ce, "code", sizeof("code")-1, 0, ZEND_ACC_PROTECTED TSRMLS_CC);
@@ -699,8 +719,8 @@
 
 	exception_ce = Z_OBJCE_P(exception);
 
-	if (!exception_ce || !instanceof_function(exception_ce, default_exception_ce TSRMLS_CC)) {
-		zend_error(E_ERROR, "Exceptions must be valid objects derived from the Exception base class");
+	if (!exception_ce || !instanceof_function(exception_ce, default_iexception_ce TSRMLS_CC)) {
+		zend_error(E_ERROR, "Exceptions must be valid objects that implement the IException interface");
 	}
 	zend_throw_exception_internal(exception TSRMLS_CC);
 }
Index: Zend/zend_globals.h
===================================================================
RCS file: /repository/ZendEngine2/zend_globals.h,v
retrieving revision 1.139
diff -u -r1.139 zend_globals.h
--- Zend/zend_globals.h	23 Sep 2004 06:23:36 -0000	1.139
+++ Zend/zend_globals.h	3 Nov 2004 16:11:45 -0000
@@ -73,8 +73,11 @@
 	zend_stack foreach_copy_stack;
 	zend_stack object_stack;
 	zend_stack declare_stack;
+	zend_stack annotation_stack;
+	zend_stack class_stack;
 
 	zend_class_entry *active_class_entry;
+	zend_package_entry *active_package_entry;
 
 	/* variables for list() compilation */
 	zend_llist list_llist;
Index: Zend/zend_language_parser.y
===================================================================
RCS file: /repository/ZendEngine2/zend_language_parser.y,v
retrieving revision 1.151
diff -u -r1.151 zend_language_parser.y
--- Zend/zend_language_parser.y	4 Oct 2004 19:54:34 -0000	1.151
+++ Zend/zend_language_parser.y	3 Nov 2004 16:11:45 -0000
@@ -111,6 +111,7 @@
 %token T_TRY
 %token T_CATCH
 %token T_THROW
+%token T_THROWS
 %token T_USE
 %token T_GLOBAL
 %right T_STATIC T_ABSTRACT T_FINAL T_PRIVATE T_PROTECTED T_PUBLIC
@@ -119,9 +120,13 @@
 %token T_ISSET
 %token T_EMPTY
 %token T_CLASS
+%token T_PACKAGE
+%token T_CLASSNAME
 %token T_INTERFACE
 %token T_EXTENDS
 %token T_IMPLEMENTS
+%token T_OPERATOR
+%token T_COMPARE
 %token T_OBJECT_OPERATOR
 %token T_DOUBLE_ARROW
 %token T_LIST
@@ -142,6 +147,7 @@
 %token T_DOLLAR_OPEN_CURLY_BRACES
 %token T_CURLY_OPEN
 %token T_PAAMAYIM_NEKUDOTAYIM
+%token T_IMPORT
 
 %% /* Rules */
 
@@ -159,6 +165,7 @@
 		statement
 	|	function_declaration_statement	{ zend_do_early_binding(TSRMLS_C); }
 	|	class_declaration_statement		{ zend_do_early_binding(TSRMLS_C); }
+	|	package_declaration_statement
 ;
 
 
@@ -172,6 +179,7 @@
 		statement
 	|	function_declaration_statement
 	|	class_declaration_statement
+	|	package_declaration_statement
 ;
 
 
@@ -220,8 +228,18 @@
 		'{' inner_statement_list '}' { zend_do_end_catch(&$1 TSRMLS_CC); }
 		additional_catches { zend_do_mark_last_catch(&$7, &$18 TSRMLS_CC); }
 	|	T_THROW expr ';' { zend_do_throw(&$2 TSRMLS_CC); }
+	|	T_IMPORT import_list ';'
 ;
 
+import_list:
+		import_list ',' import
+	|	import
+;
+
+import:
+		class_name_reference	            { zend_do_import(&$1, NULL TSRMLS_CC); }
+	|	class_name_reference T_AS T_STRING  { zend_do_import(&$1, &$3 TSRMLS_CC); }
+;
 
 additional_catches:
 		non_empty_additional_catches { $$ = $1; }
@@ -262,6 +280,14 @@
 		unticked_class_declaration_statement	{ zend_do_ticks(TSRMLS_C); }
 ;
 
+class_declaration_statements:
+		class_declaration_statement class_declaration_statements
+	|   /* empty */
+;
+
+package_declaration_statement:
+		unticked_package_declaration_statement  { zend_do_ticks(TSRMLS_C); }
+;
 
 is_reference:
 		/* empty */	{ $$.op_type = ZEND_RETURN_VAL; }
@@ -289,6 +315,16 @@
 			'}' { zend_do_end_class_declaration(&$1, &$2 TSRMLS_CC); }
 ;
 
+unticked_package_declaration_statement:
+		T_PACKAGE T_STRING { zend_do_begin_package_declaration(&$2 TSRMLS_CC); }
+		   '{'
+		   class_declaration_statements
+		   '}' { zend_do_end_package_declaration(&$2 TSRMLS_CC); }
+	|	T_PACKAGE T_CLASSNAME { zend_do_begin_package_declaration(&$2 TSRMLS_CC); }
+		   '{'
+		   class_declaration_statements
+		   '}' { zend_do_end_package_declaration(&$2 TSRMLS_CC); }
+;
 
 class_entry_type:
 		T_CLASS			{  $$.u.constant.value.lval = 0; }
@@ -428,6 +464,7 @@
 optional_class_type:
 		/* empty */		{ $$.op_type = IS_UNUSED; }
 	|	T_STRING		{ $$ = $1; }
+	|	T_CLASSNAME		{ $$ = $1; }
 ;
 
 
@@ -478,9 +515,49 @@
 		variable_modifiers { CG(access_type) = $1.u.constant.value.lval; } class_variable_declaration ';'
 	|	class_constant_declaration ';'
 	|	method_modifiers T_FUNCTION { $2.u.opline_num = CG(zend_lineno); } is_reference T_STRING { zend_do_begin_function_declaration(&$2, &$5, 1, $4.op_type, &$1 TSRMLS_CC); } '(' 
-			parameter_list ')' method_body { zend_do_abstract_method(&$5, &$1, &$10 TSRMLS_CC); zend_do_end_function_declaration(&$2 TSRMLS_CC); }
+			parameter_list ')' throws method_body { zend_do_abstract_method(&$5, &$1, &$11 TSRMLS_CC); zend_do_end_function_declaration(&$2 TSRMLS_CC); }
+	|	annotation_list method_modifiers T_FUNCTION { $3.u.opline_num = CG(zend_lineno); } is_reference T_STRING { zend_do_begin_function_declaration(&$3, &$6, 1, $5.op_type, &$2 TSRMLS_CC); } '(' 
+			parameter_list ')' throws method_body { zend_do_abstract_method(&$6, &$2, &$12 TSRMLS_CC); zend_do_end_function_declaration(&$3 TSRMLS_CC); }
+	|	method_modifiers T_OPERATOR { $2.u.opline_num = CG(zend_lineno); } is_reference operator_token { zend_do_begin_function_declaration(&$2, &$5, 1, $4.op_type, &$1 TSRMLS_CC); } '(' 
+			parameter_list ')' throws method_body { zend_do_abstract_method(&$5, &$1, &$11 TSRMLS_CC); zend_do_end_function_declaration(&$2 TSRMLS_CC); }
+;
+
+throws:
+		/* empty */
+	|	T_THROWS throws_list
 ;
 
+throws_list:
+		throws_class_name 					{ zend_do_throws(&$1 TSRMLS_CC); }
+	|	throws_list ',' throws_class_name	{ zend_do_throws(&$3 TSRMLS_CC); }
+;	
+
+throws_class_name:
+		T_STRING { $$ = $1; }
+	|	T_CLASSNAME { $$ = $1; }
+;
+
+annotation_list:
+		annotation
+	|	annotation_list ',' annotation
+;
+
+annotation:
+		'@' T_STRING						{ zend_do_annotation(&$2, NULL TSRMLS_CC); }
+	|	'@' T_STRING '(' common_scalar ')'	{ zend_do_annotation(&$2, &$4 TSRMLS_CC); }
+;
+
+operator_token:
+		'+'								{ $$.u.constant.value.str.val = estrndup("+", sizeof("+")- 1); $$.u.constant.value.str.len = sizeof("+")- 1; }
+	|	'-'								{ $$.u.constant.value.str.val = estrndup("-", sizeof("-")- 1); $$.u.constant.value.str.len = sizeof("-")- 1; }
+	|	'*'								{ $$.u.constant.value.str.val = estrndup("*", sizeof("*")- 1); $$.u.constant.value.str.len = sizeof("*")- 1; }
+	|	'/'								{ $$.u.constant.value.str.val = estrndup("/", sizeof("/")- 1); $$.u.constant.value.str.len = sizeof("/")- 1; }
+	|	'%'								{ $$.u.constant.value.str.val = estrndup("%", sizeof("%")- 1); $$.u.constant.value.str.len = sizeof("%")- 1; }
+	|	'!'								{ $$.u.constant.value.str.val = estrndup("!", sizeof("!")- 1); $$.u.constant.value.str.len = sizeof("%")- 1; }
+	|	T_INC							{ $$.u.constant.value.str.val = estrndup("++", sizeof("++")- 1); $$.u.constant.value.str.len = sizeof("++")- 1; }
+	|	T_DEC							{ $$.u.constant.value.str.val = estrndup("--", sizeof("--")- 1); $$.u.constant.value.str.len = sizeof("--")- 1; }
+	|	T_COMPARE						{ $$.u.constant.value.str.val = estrndup("__compare", sizeof("__compare")- 1); $$.u.constant.value.str.len = sizeof("__compare")- 1; }
+;
 
 method_body:
 		';' /* abstract method */		{ $$.u.constant.value.lval = ZEND_ACC_ABSTRACT; }
@@ -539,12 +616,17 @@
 	|	expr					{ $$ = $1; }
 ;
 
+optional_class_statement_list:
+		/* empty */
+	|	'{' { zend_do_begin_instance_creation(TSRMLS_C); } class_statement_list { zend_do_end_instance_creation(TSRMLS_C); } '}'
+;
+
 expr_without_variable:	
 		T_LIST '(' { zend_do_list_init(TSRMLS_C); } assignment_list ')' '=' expr { zend_do_list_end(&$$, &$7 TSRMLS_CC); }
 	|	variable '=' expr		{ zend_check_writable_variable(&$1); zend_do_end_variable_parse(BP_VAR_W, 0 TSRMLS_CC); zend_do_assign(&$$, &$1, &$3 TSRMLS_CC); }
 	|	variable '=' '&' variable { zend_check_writable_variable(&$1); zend_do_end_variable_parse(BP_VAR_W, 0 TSRMLS_CC); zend_do_end_variable_parse(BP_VAR_W, 0 TSRMLS_CC); zend_do_assign_ref(&$$, &$1, &$4 TSRMLS_CC); }
 	|	variable '=' '&' T_NEW class_name_reference { zend_error(E_STRICT, "Assigning the return value of new by reference is deprecated");  zend_check_writable_variable(&$1); zend_do_extended_fcall_begin(TSRMLS_C); zend_do_begin_new_object(&$4, &$5 TSRMLS_CC); } ctor_arguments { zend_do_end_new_object(&$3, &$4, &$7 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C); zend_do_end_variable_parse(BP_VAR_W, 0 TSRMLS_CC); zend_do_assign_ref(&$$, &$1, &$3 TSRMLS_CC); }
-	|	T_NEW class_name_reference { zend_do_extended_fcall_begin(TSRMLS_C); zend_do_begin_new_object(&$1, &$2 TSRMLS_CC); } ctor_arguments { zend_do_end_new_object(&$$, &$1, &$4 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}
+	|	T_NEW class_name_reference { zend_do_extended_fcall_begin(TSRMLS_C); zend_do_begin_new_object(&$1, &$2 TSRMLS_CC); } ctor_arguments optional_class_statement_list { zend_do_end_new_object(&$$, &$1, &$4 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}
 	|	T_CLONE expr { zend_do_clone(&$$, &$2 TSRMLS_CC); }
 	|	variable T_PLUS_EQUAL expr 	{ zend_check_writable_variable(&$1); zend_do_end_variable_parse(BP_VAR_RW, 0 TSRMLS_CC); zend_do_binary_assign_op(ZEND_ASSIGN_ADD, &$$, &$1, &$3 TSRMLS_CC); }
 	|	variable T_MINUS_EQUAL expr	{ zend_check_writable_variable(&$1); zend_do_end_variable_parse(BP_VAR_RW, 0 TSRMLS_CC); zend_do_binary_assign_op(ZEND_ASSIGN_SUB, &$$, &$1, &$3 TSRMLS_CC); }
@@ -627,10 +709,12 @@
 
 fully_qualified_class_name:
 		T_STRING { zend_do_fetch_class(&$$, &$1 TSRMLS_CC); }
+	|	T_CLASSNAME { zend_do_fetch_class(&$$, &$1 TSRMLS_CC); }
 ;
 
 class_name_reference:
 		T_STRING				{ zend_do_fetch_class(&$$, &$1 TSRMLS_CC); }
+	|	T_CLASSNAME				{ zend_do_fetch_class(&$$, &$1 TSRMLS_CC); }
 	|	dynamic_class_name_reference	{ zend_do_end_variable_parse(BP_VAR_R, 0 TSRMLS_CC); zend_do_fetch_class(&$$, &$1 TSRMLS_CC); }
 ;
 
@@ -661,8 +745,7 @@
 
 
 ctor_arguments:
-		/* empty */	{ $$.u.constant.value.lval=0; }
-	|	'(' function_call_parameter_list ')'	{ $$ = $2; }
+		'(' function_call_parameter_list ')'	{ $$ = $2; }
 ;
 
 
Index: Zend/zend_language_scanner.l
===================================================================
RCS file: /repository/ZendEngine2/zend_language_scanner.l,v
retrieving revision 1.115
diff -u -r1.115 zend_language_scanner.l
--- Zend/zend_language_scanner.l	2 Aug 2004 16:38:09 -0000	1.115
+++ Zend/zend_language_scanner.l	3 Nov 2004 16:11:45 -0000
@@ -794,6 +794,10 @@
 	return T_THROW;
 }
 
+<ST_IN_SCRIPTING>"throws" {
+	return T_THROWS;
+}
+
 <ST_IN_SCRIPTING>"if" {
 	return T_IF;
 }
@@ -890,6 +894,10 @@
 	return T_CLASS;
 }
 
+<ST_IN_SCRIPTING>"package" {
+	return T_PACKAGE;
+}
+
 <ST_IN_SCRIPTING>"interface" {
 	return T_INTERFACE;
 }
@@ -902,6 +910,18 @@
 	return T_IMPLEMENTS;
 }
 
+<ST_IN_SCRIPTING>"import" {
+	return T_IMPORT;
+}
+
+<ST_IN_SCRIPTING>"operator" {
+	return T_OPERATOR;
+}
+
+<ST_IN_SCRIPTING>"__compare" {
+	return T_COMPARE;
+}
+
 <ST_IN_SCRIPTING,ST_DOUBLE_QUOTES,ST_BACKQUOTE,ST_HEREDOC>"->" {
 	yy_push_state(ST_LOOKING_FOR_PROPERTY TSRMLS_CC);
 	return T_OBJECT_OPERATOR;
@@ -1395,6 +1415,12 @@
 	return T_STRING;
 }
 
+<ST_IN_SCRIPTING>({LABEL}"~")+{LABEL} {
+	zend_copy_value(zendlval, yytext, yyleng);
+	zendlval->type = IS_STRING;
+	return T_CLASSNAME;
+}
+
 <ST_DOUBLE_QUOTES,ST_BACKQUOTE,ST_HEREDOC>{LABEL} {
 	zend_copy_value(zendlval, yytext, yyleng);
 	zendlval->type = IS_STRING;
Index: Zend/zend_object_handlers.c
===================================================================
RCS file: /repository/ZendEngine2/zend_object_handlers.c,v
retrieving revision 1.106
diff -u -r1.106 zend_object_handlers.c
--- Zend/zend_object_handlers.c	30 Oct 2004 19:11:37 -0000	1.106
+++ Zend/zend_object_handlers.c	3 Nov 2004 16:11:45 -0000
@@ -606,6 +606,8 @@
 			call_user_call->handler = zend_std_call_user_call;
 			call_user_call->arg_info = NULL;
 			call_user_call->num_args = 0;
+			call_user_call->throws = NULL;
+			call_user_call->num_throws = 0;
 			call_user_call->scope = zobj->ce;
 			call_user_call->fn_flags = 0;
 			call_user_call->function_name = estrndup(method_name, method_len);
Index: Zend/zend_opcode.c
===================================================================
RCS file: /repository/ZendEngine2/zend_opcode.c,v
retrieving revision 1.109
diff -u -r1.109 zend_opcode.c
--- Zend/zend_opcode.c	4 Oct 2004 19:54:34 -0000	1.109
+++ Zend/zend_opcode.c	3 Nov 2004 16:11:45 -0000
@@ -78,6 +78,9 @@
 	op_array->doc_comment = NULL;
 	op_array->doc_comment_len = 0;
 
+	op_array->num_throws = 0;
+	op_array->throws = NULL;
+
 	op_array->arg_info = NULL;
 	op_array->num_args = 0;
 	op_array->required_num_args = 0;
@@ -90,6 +93,8 @@
 	op_array->current_brk_cont = -1;
 
 	op_array->static_variables = NULL;
+	op_array->annotations = NULL;
+
 	op_array->last_try_catch = 0;
 
 	op_array->return_reference = 0;
@@ -206,6 +211,10 @@
 		zend_hash_destroy(op_array->static_variables);
 		FREE_HASHTABLE(op_array->static_variables);
 	}
+	if (op_array->annotations) {
+		zend_hash_destroy(op_array->annotations);
+		FREE_HASHTABLE(op_array->annotations);
+	}
 
 	if (--(*op_array->refcount)>0) {
 		return;
@@ -263,6 +272,9 @@
 		}
 		efree(op_array->arg_info);
 	}
+	if (op_array->num_throws > 0 && op_array->throws) {
+        efree(op_array->throws);
+	}
 }
 
 void init_op(zend_op *op TSRMLS_DC)
Index: Zend/zend_operators.c
===================================================================
RCS file: /repository/ZendEngine2/zend_operators.c,v
retrieving revision 1.201
diff -u -r1.201 zend_operators.c
--- Zend/zend_operators.c	29 Oct 2004 00:55:11 -0000	1.201
+++ Zend/zend_operators.c	3 Nov 2004 16:11:46 -0000
@@ -101,6 +101,55 @@
 	return result;
 }
 
+static inline int call_operator_overloading(char *operator, int operator_len, zval *result, zval *op1, zval *op2, int bail TSRMLS_DC)
+{
+	zend_function *mptr;
+	zval *rval, **params[2];
+	zend_fcall_info fci;
+	zend_fcall_info_cache fcc;
+
+	if (zend_hash_find(&Z_OBJCE_P(op1)->function_table, operator, operator_len, (void **) &mptr) == FAILURE) {
+		if (bail) {
+			zend_error(E_ERROR, "Class %s does not support overloading of the %s operator", Z_OBJCE_P(op1)->name, operator);
+			/* Never returns */
+		}
+		return FAILURE;
+	}
+
+	params[0] = &op1;
+	params[1] = &op2;
+
+	/* Call operator method statically with operands and take its return value
+	 * as return value for the operation.
+	 */
+	fci.size = sizeof(fci);
+	fci.function_table = NULL;
+	fci.function_name = NULL;
+	fci.symbol_table = NULL;
+	fci.object_pp = NULL;
+	fci.retval_ptr_ptr = &rval;
+	fci.param_count = op2 ? 2 : 1;
+	fci.params = params;
+	fci.no_separation = 1;
+
+	fcc.initialized = 1;
+	fcc.function_handler = mptr;
+	fcc.calling_scope = NULL;
+	fcc.object_pp = NULL;
+
+	if (zend_call_function(&fci, &fcc TSRMLS_CC) == FAILURE) {
+		zend_error(E_ERROR, "Could not call operator method %s::%s", Z_OBJCE_P(op1)->name, operator);
+		return FAILURE;
+	}
+
+	if (rval) {
+		*result = *rval;
+    	zval_copy_ctor(result);
+		zval_ptr_dtor(&rval);
+	}
+	return SUCCESS;
+}
+
 
 ZEND_API void convert_scalar_to_number(zval *op TSRMLS_DC)
 {
@@ -781,6 +830,9 @@
 		result->value.dval = op1->value.dval + op2->value.dval;
 		return SUCCESS;
 	}
+	if (op1->type == IS_OBJECT) {
+		return call_operator_overloading("+", sizeof("+"), result, op1, op2, 1 TSRMLS_CC);
+	}
 	zend_error(E_ERROR, "Unsupported operand types");
 	return FAILURE;				/* unknown datatype */
 }
@@ -821,6 +873,9 @@
 		result->value.dval = op1->value.dval - op2->value.dval;
 		return SUCCESS;
 	}
+	if (op1->type == IS_OBJECT) {
+		return call_operator_overloading("-", sizeof("-"), result, op1, op2, 1 TSRMLS_CC);
+	}
 	zend_error(E_ERROR, "Unsupported operand types");
 	return FAILURE;				/* unknown datatype */
 }
@@ -853,6 +908,9 @@
 		result->value.dval = op1->value.dval * op2->value.dval;
 		return SUCCESS;
 	}
+	if (op1->type == IS_OBJECT) {
+		return call_operator_overloading("*", sizeof("*"), result, op1, op2, 1 TSRMLS_CC);
+	}
 	zend_error(E_ERROR, "Unsupported operand types");
 	return FAILURE;				/* unknown datatype */
 }
@@ -892,6 +950,9 @@
 		result->value.dval = op1->value.dval / op2->value.dval;
 		return SUCCESS;
 	}
+	if (op1->type == IS_OBJECT) {
+		return call_operator_overloading("/", sizeof("/"), result, op1, op2, 1 TSRMLS_CC);
+	}
 	zend_error(E_ERROR, "Unsupported operand types");
 	return FAILURE;				/* unknown datatype */
 }
@@ -900,6 +961,10 @@
 ZEND_API int mod_function(zval *result, zval *op1, zval *op2 TSRMLS_DC)
 {
 	zval op1_copy, op2_copy;
+
+	if (op1->type == IS_OBJECT) {
+		return call_operator_overloading("%", sizeof("%"), result, op1, op2, 1 TSRMLS_CC);
+	}
 	
 	zendi_convert_to_long(op1, op1_copy, result);
 	zendi_convert_to_long(op2, op2_copy, result);
@@ -937,7 +1002,10 @@
 ZEND_API int boolean_not_function(zval *result, zval *op1 TSRMLS_DC)
 {
 	zval op1_copy;
-	
+
+	if (Z_TYPE_P(op1) == IS_OBJECT) {
+		return call_operator_overloading("!", sizeof("!"), result, op1, NULL, 1 TSRMLS_CC);	
+	}
 	zendi_convert_to_boolean(op1, op1_copy, result);
 
 	result->type = IS_BOOL;
@@ -1331,6 +1399,10 @@
 	}
 
 	if (op1->type==IS_OBJECT && op2->type==IS_OBJECT) {
+		if (SUCCESS == call_operator_overloading("__compare", sizeof("__compare"), result, op1, op2, 0 TSRMLS_CC)) {
+			convert_to_long(result);
+			COMPARE_RETURN_AND_FREE(SUCCESS);
+        }
 		/* If the handlers array is not identical, fall through
 		 * and perform get() or cast() if implemented
 		 */
@@ -1371,13 +1443,19 @@
 		COMPARE_RETURN_AND_FREE(SUCCESS);
 	}
 	if (op1->type==IS_OBJECT) {
-		result->value.lval = 1;
-		result->type = IS_LONG;
+		/* $object == NULL*/
+		if (FAILURE == call_operator_overloading("compare", sizeof("compare"), result, op1, op2, 0 TSRMLS_CC)) {
+			result->value.lval = 1;
+			result->type = IS_LONG;
+		}
 		COMPARE_RETURN_AND_FREE(SUCCESS);
 	}
 	if (op2->type==IS_OBJECT) {
-		result->value.lval = -1;
-		result->type = IS_LONG;
+		/* NULL == $object */
+		if (FAILURE == call_operator_overloading("compare", sizeof("compare"), result, op2, op1, 0 TSRMLS_CC)) {
+			result->value.lval = -1;
+			result->type = IS_LONG;
+		}
 		COMPARE_RETURN_AND_FREE(SUCCESS);
 	}
 
@@ -1713,6 +1791,12 @@
 				}
 			}
 			break;
+		case IS_OBJECT: {
+				TSRMLS_FETCH();
+			
+				return call_operator_overloading("++", sizeof("++"), op1, op1, NULL, 1 TSRMLS_CC);
+			}
+			break;
 		default:
 			return FAILURE;
 	}
@@ -1762,6 +1846,12 @@
 					break;
 			}
 			break;
+		case IS_OBJECT: {
+				TSRMLS_FETCH();
+			
+				return call_operator_overloading("--", sizeof("--"), op1, op1, NULL, 1 TSRMLS_CC);
+			}
+			break;
 		default:
 			return FAILURE;
 	}
Index: Zend/zend_reflection_api.c
===================================================================
RCS file: /repository/ZendEngine2/zend_reflection_api.c,v
retrieving revision 1.136
diff -u -r1.136 zend_reflection_api.c
--- Zend/zend_reflection_api.c	31 Oct 2004 15:30:53 -0000	1.136
+++ Zend/zend_reflection_api.c	3 Nov 2004 16:11:47 -0000
@@ -631,7 +631,18 @@
 	if (fptr->type == ZEND_USER_FUNCTION && fptr->op_array.return_reference) {
 		string_printf(str, "&");
 	}
-	string_printf(str, "%s ] {\n", fptr->common.function_name);
+	string_printf(str, "%s ]", fptr->common.function_name);
+ 
+ 	if (fptr->common.num_throws) {
+		zend_uint i;
+
+		string_printf(str, " throws %s", fptr->common.throws[0]->name);
+		for (i = 1; i < fptr->common.num_throws; ++i) {
+			string_printf(str, ", %s", fptr->common.throws[i]->name);
+		}
+	}
+	string_write(str, " {\n", sizeof(" {\n") - 1);
+    
 	/* The information where a function is declared is only available for user classes */
 	if (fptr->type == ZEND_USER_FUNCTION) {
 		string_printf(str, "%s  @@ %s %d - %d\n", indent, 
@@ -1496,7 +1507,7 @@
 }
 /* }}} */
 
-/* {{{ proto public ReflectionParameter[] Reflection_Function::getParameters()
+/* {{{ proto public ReflectionParameter[] ReflectionFunction::getParameters()
    Returns an array of parameter objects for this function */
 ZEND_METHOD(reflection_function, getParameters)
 {
@@ -1523,6 +1534,32 @@
 }
 /* }}} */
 
+/* {{{ proto public ReflectionClass[] ReflectionFunction::getExceptionTypes()
+   Returns an array of interfaces this class implements */
+ZEND_METHOD(reflection_function, getExceptionTypes)
+{
+	reflection_object *intern;
+	zend_function *fptr;
+
+	METHOD_NOTSTATIC_NUMPARAMS(0);
+	GET_REFLECTION_OBJECT_PTR(fptr);
+
+	/* Return an empty array if this class implements no interfaces */
+	array_init(return_value);
+
+	if (fptr->common.num_throws) {
+		zend_uint i;
+
+	   	for (i=0; i < fptr->common.num_throws; i++) {
+			zval *throws;
+			ALLOC_ZVAL(throws);
+			zend_reflection_class_factory(fptr->common.throws[i], throws TSRMLS_CC);
+			add_next_index_zval(return_value, throws);
+		}
+	}
+}
+/* }}} */
+
 /* {{{ proto public static mixed ReflectionParameter::export(mixed function, mixed parameter [, bool return]) throws ReflectionException
    Exports a reflection object. Returns the output if TRUE is specified for return, printing it otherwise. */
 ZEND_METHOD(reflection_parameter, export)
@@ -2210,6 +2247,68 @@
 }
 /* }}} */
 
+/* {{{ proto public ReflectionClass ReflectionMethod::hasAnnotation(string name)
+   Get annotation by name */
+ZEND_METHOD(reflection_method, hasAnnotation)
+{
+	reflection_object *intern;
+	zend_function *mptr;
+	char *name; 
+	int name_len;
+
+	METHOD_NOTSTATIC;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &name, &name_len) == FAILURE) {
+		return;
+	}
+	GET_REFLECTION_OBJECT_PTR(mptr);
+
+	RETVAL_BOOL(mptr->common.annotations && zend_hash_exists(mptr->common.annotations, name, name_len + 1));
+}
+/* }}} */
+
+/* {{{ proto public ReflectionClass ReflectionMethod::getAnnotation(string name)
+   Get annotation by name */
+ZEND_METHOD(reflection_method, getAnnotation)
+{
+	reflection_object *intern;
+	zend_function *mptr;
+	zval **value;
+	char *name; 
+	int name_len;
+
+	METHOD_NOTSTATIC;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s", &name, &name_len) == FAILURE) {
+		return;
+	}
+	GET_REFLECTION_OBJECT_PTR(mptr);
+
+	if (mptr->common.annotations && (zend_hash_find(mptr->common.annotations, name, name_len + 1, (void **) &value) == SUCCESS)) {
+		*return_value = **value;
+		zval_copy_ctor(return_value);
+		return;
+	}
+	zend_throw_exception_ex(reflection_exception_ptr, 0 TSRMLS_CC, "Annotation '%s' does not exist", name);
+}
+/* }}} */
+
+/* {{{ proto public ReflectionClass ReflectionMethod::getAnnotations()
+   Get annotations */
+ZEND_METHOD(reflection_method, getAnnotations)
+{
+	zval *tmp_copy;
+	reflection_object *intern;
+	zend_function *mptr;
+
+	METHOD_NOTSTATIC;
+	GET_REFLECTION_OBJECT_PTR(mptr);
+
+	array_init(return_value);
+	if (mptr->common.annotations) {
+		zend_hash_copy(Z_ARRVAL_P(return_value), mptr->common.annotations, (copy_ctor_func_t) zval_add_ref, (void *) &tmp_copy, sizeof(zval *));
+	}
+}
+/* }}} */
+
 /* {{{ proto public static mixed ReflectionClass::export(mixed argument [, bool return]) throws ReflectionException
    Exports a reflection object. Returns the output if TRUE is specified for return, printing it otherwise. */
 ZEND_METHOD(reflection_class, export)
@@ -2957,6 +3056,24 @@
 }
 /* }}} */
 
+/* {{{ proto public string ReflectionClass::getPackage()
+   Returns class' package name or NULL if class is not within a package */
+ZEND_METHOD(reflection_class, getPackage)
+{
+	reflection_object *intern;
+	zend_class_entry *ce;
+	char *package_name;
+
+	METHOD_NOTSTATIC;
+	GET_REFLECTION_OBJECT_PTR(ce);
+
+	if ((package_name = strrchr(ce->name, '~'))) {
+		RETURN_STRINGL(ce->name, ce->name_length - strlen(package_name), 1);
+	}
+	RETURN_NULL();
+}
+/* }}} */
+
 /* {{{ proto public ReflectionExtension|NULL ReflectionClass::getExtension()
    Returns NULL or the extension the class belongs to */
 ZEND_METHOD(reflection_class, getExtension)
@@ -3572,6 +3689,7 @@
 	ZEND_ME(reflection_function, invokeArgs, NULL, 0)
 	ZEND_ME(reflection_function, returnsReference, NULL, 0)
 	ZEND_ME(reflection_function, getParameters, NULL, 0)
+	ZEND_ME(reflection_function, getExceptionTypes, NULL, 0)
 	ZEND_ME(reflection_function, getNumberOfParameters, NULL, 0)
 	ZEND_ME(reflection_function, getNumberOfRequiredParameters, NULL, 0)
 	{NULL, NULL, NULL}
@@ -3593,6 +3711,9 @@
 	ZEND_ME(reflection_method, invoke, NULL, 0)
 	ZEND_ME(reflection_method, invokeArgs, NULL, 0)
 	ZEND_ME(reflection_method, getDeclaringClass, NULL, 0)
+	ZEND_ME(reflection_method, hasAnnotation, NULL, 0)
+	ZEND_ME(reflection_method, getAnnotation, NULL, 0)
+	ZEND_ME(reflection_method, getAnnotations, NULL, 0)
 	{NULL, NULL, NULL}
 };
 
@@ -3628,6 +3749,7 @@
 	ZEND_ME(reflection_class, getStaticProperties, NULL, 0)
 	ZEND_ME(reflection_class, getDefaultProperties, NULL, 0)
 	ZEND_ME(reflection_class, isIterateable, NULL, 0)
+	ZEND_ME(reflection_class, getPackage, NULL, 0)
 	ZEND_ME(reflection_class, implementsInterface, NULL, 0)
 	ZEND_ME(reflection_class, getExtension, NULL, 0)
 	ZEND_ME(reflection_class, getExtensionName, NULL, 0)
Index: Zend/zend_vm_def.h
===================================================================
RCS file: /repository/ZendEngine2/zend_vm_def.h,v
retrieving revision 1.3
diff -u -r1.3 zend_vm_def.h
--- Zend/zend_vm_def.h	3 Nov 2004 07:11:49 -0000	1.3
+++ Zend/zend_vm_def.h	3 Nov 2004 16:11:48 -0000
@@ -3421,3 +3421,36 @@
 	ZEND_VM_NEXT_OPCODE();
 }
 
+ZEND_VM_HANDLER(150, ZEND_IMPORT, ANY, ANY)
+{
+	char *alias_name;
+	int alias_len;
+	zend_op *opline = EX(opline);
+	zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
+
+	/* Calculate the short name from the long one if no alias is supplied */
+	if (OP2_TYPE == IS_UNUSED) {
+		char *tmp = strrchr(ce->name, '~');
+
+		if (!tmp) {
+			zend_error(E_COMPILE_ERROR, "Cannot import %s which is not contained in a package", ce->name);
+			/* Bails out */
+		}
+
+		alias_len = strlen(tmp)- 1;		
+		alias_name = zend_str_tolower_dup(tmp+ 1, alias_len);
+	} else {
+		alias_name = zend_str_tolower_dup(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len);
+		alias_len = opline->op2.u.constant.value.str.len;
+	}
+
+	ce->refcount++;
+	if (zend_hash_add(CG(class_table), alias_name, alias_len+ 1, &ce, sizeof(zend_class_entry *), NULL)==FAILURE) {
+		ce->refcount--;
+		zend_error(E_COMPILE_ERROR, "Cannot import class %s as already declared %s", ce->name, alias_name);
+		/* Bails out */
+	}
+	
+	efree(alias_name);
+	ZEND_VM_NEXT_OPCODE();
+}
Index: Zend/zend_vm_execute.h
===================================================================
RCS file: /repository/ZendEngine2/zend_vm_execute.h,v
retrieving revision 1.4
diff -u -r1.4 zend_vm_execute.h
--- Zend/zend_vm_execute.h	3 Nov 2004 07:11:49 -0000	1.4
+++ Zend/zend_vm_execute.h	3 Nov 2004 16:11:55 -0000
@@ -483,6 +483,39 @@
 	ZEND_VM_NEXT_OPCODE();
 }
 
+static int ZEND_IMPORT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
+{
+	char *alias_name;
+	int alias_len;
+	zend_op *opline = EX(opline);
+    zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
+
+	/* Calculate the short name from the long one if no alias is supplied */
+	if (opline->op2.op_type == IS_UNUSED) {
+		char *tmp = strrchr(ce->name, '~');
+
+		if (!tmp) {
+			zend_error(E_COMPILE_ERROR, "Cannot import %s which is not contained in a package", ce->name);
+			/* Bails out */
+		}
+            
+		alias_len = strlen(tmp)- 1;		
+		alias_name = zend_str_tolower_dup(tmp+ 1, alias_len);
+	} else {
+		alias_name = zend_str_tolower_dup(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len);
+		alias_len = opline->op2.u.constant.value.str.len;
+	}
+
+	ce->refcount++;
+	if (zend_hash_add(CG(class_table), alias_name, alias_len+ 1, &ce, sizeof(zend_class_entry *), NULL)==FAILURE) {
+		ce->refcount--;
+		zend_error(E_COMPILE_ERROR, "Cannot import class %s as already declared %s", ce->name, alias_name);
+		/* Bails out */
+	}
+	
+	efree(alias_name);
+	ZEND_VM_NEXT_OPCODE();
+}
 static int ZEND_FETCH_CLASS_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
 {
 	zend_op *opline = EX(opline);
@@ -27471,6 +27504,31 @@
   	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
   	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
+  	ZEND_IMPORT_SPEC_HANDLER,
   	ZEND_NULL_HANDLER
   };
   zend_opcode_handlers = (opcode_handler_t*)labels;
@@ -30975,6 +31033,39 @@
 	ZEND_VM_NEXT_OPCODE();
 }
 
+static int ZEND_IMPORT_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
+{
+	char *alias_name;
+	int alias_len;
+	zend_op *opline = EX(opline);
+    zend_class_entry *ce = EX_T(opline->op1.u.var).class_entry;
+
+	/* Calculate the short name from the long one if no alias is supplied */
+	if (opline->op2.op_type == IS_UNUSED) {
+		char *tmp = strrchr(ce->name, '~');
+
+		if (!tmp) {
+			zend_error(E_COMPILE_ERROR, "Cannot import %s which is not contained in a package", ce->name);
+			/* Bails out */
+		}
+            
+		alias_len = strlen(tmp)- 1;		
+		alias_name = zend_str_tolower_dup(tmp+ 1, alias_len);
+	} else {
+		alias_name = zend_str_tolower_dup(opline->op2.u.constant.value.str.val, opline->op2.u.constant.value.str.len);
+		alias_len = opline->op2.u.constant.value.str.len;
+	}
+
+	ce->refcount++;
+	if (zend_hash_add(CG(class_table), alias_name, alias_len+ 1, &ce, sizeof(zend_class_entry *), NULL)==FAILURE) {
+		ce->refcount--;
+		zend_error(E_COMPILE_ERROR, "Cannot import class %s as already declared %s", ce->name, alias_name);
+		/* Bails out */
+	}
+	
+	efree(alias_name);
+	ZEND_VM_NEXT_OPCODE();
+}
 
 void zend_vm_use_old_executor()
 {
@@ -31129,6 +31220,7 @@
   	ZEND_ASSIGN_DIM_HANDLER,
   	ZEND_ISSET_ISEMPTY_PROP_OBJ_HANDLER,
   	ZEND_HANDLE_EXCEPTION_HANDLER,
+  	ZEND_IMPORT_HANDLER,
   	ZEND_NULL_HANDLER
   };
   zend_opcode_handlers = (opcode_handler_t*)labels;
Index: Zend/zend_vm_opcodes.h
===================================================================
RCS file: /repository/ZendEngine2/zend_vm_opcodes.h,v
retrieving revision 1.1
diff -u -r1.1 zend_vm_opcodes.h
--- Zend/zend_vm_opcodes.h	27 Oct 2004 20:13:59 -0000	1.1
+++ Zend/zend_vm_opcodes.h	3 Nov 2004 16:11:56 -0000
@@ -127,3 +127,4 @@
 #define ZEND_ASSIGN_DIM              147
 #define ZEND_ISSET_ISEMPTY_PROP_OBJ  148
 #define ZEND_HANDLE_EXCEPTION        149
+#define ZEND_IMPORT                  150
