%{

class Arith {		// must first specify class header
				// must not use yy[A-Z].* as identifiers
				// could overwrite methods named yy[a-z].*
				// in (anonymous) subclass
%}
				// value stack is of class Object,
				// <className> results in cast

%token	<Double> Number 99	// mapped to public static final int
 
%left	'+' '-'
%left	'*' '/'
%right	UNARY

%start	prog

%%	// public Object yyparse(yyInput yyLex) throws IOException, yyException

expr	: expr '+' expr		{ $$ = $1 + $3; }
	| expr '-' expr		{ $$ = $1 - $3; }
	| expr '*' expr		{ $$ = $1 * $3; }
	| expr '/' expr		{ $$ = $1 / $3;  }
	| '+' expr %prec UNARY	{ $$ = $<>2; }	// can suppress class
	| '-' expr %prec UNARY	{ $$ = -$2d; }
	| '(' expr ')'		{ $$ = $2; }
	| Number		// $$ = yyDefault($1);

prog	: /* null */
	| prog expr '\n'	{ echo "\t".$2); }
	| prog '\n'
	| prog error '\n'	{ $this->yyErrorFlag = 0; }	// forces recovery

%%				// rest is emitted after yyparse()

   function main ($args) {
	
        $yyInput = new Scanner("1 + 2\n");
        $this->yyparse($yyInput);
      
  }

}				// must specify trailing } for parser


 			// yyInput through separate class
class  Scanner { // implements yyInput
 
  var $_data;
  function Scanner ($data) {
	$this->_data = $data;
  }
  var $_pos = 0;
  var $_token;
  
  function advance () {
    $this->_pos++;
    $this->_token = $this->_data{$this->_pos};
    
    if ($this->_pos > strlen($this->_data)) {
	    return false;
    }
    return true;
    
  }

  function token () {
    return $this->_token;
    
  }

}


$t = new Arith();
$t->main;



