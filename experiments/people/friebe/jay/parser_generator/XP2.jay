%{
?><?php
  uses(
    'net.xp_framework.tools.vm.PNode',
    'net.xp_framework.tools.vm.VNode',
    'net.xp_framework.tools.vm.CompileError'
  );
/*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2004 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   +----------------------------------------------------------------------+
*/

/* $Id$ */

/* 
 * LALR shift/reduce conflicts and how they are resolved:
 *
 * - 2 shift/reduce conflicts due to the dangeling elseif/else ambiguity.  Solved by shift.
 * - 1 shift/reduce conflict due to arrays within encapsulated strings. Solved by shift. 
 * - 1 shift/reduce conflict due to objects within encapsulated strings.  Solved by shift.
 * 
 */

  class Parser extends Object {
    var
      $errors= array();

    /**
     * Adds an error
     *
     * @access  public
     * @param   &net.xp_framework.tools.vm.CompileError error
     */
    function addError(&$error) {
      $this->errors[]= &$error;
    }
    
    /**
     * Returns whether errors have occured
     *
     * @access  public
     * @return  bool
     */
    function hasErrors() {
      return !empty($this->errors);
    }

    /**
     * Returns whether errors have occured
     *
     * @access  public
     * @return  net.xp_framework.tools.vm.CompileError[]
     */
    function getErrors() {
      return $this->errors;
    }

    /**
     * Error handler
     *
     * @access  public
     * @param   int level
     * @param   string message
     */
    function error($level, $message) {
      switch ($level) {
        case E_ERROR:
        case E_CORE_ERROR:
        case E_COMPILE_ERROR:
          $this->addError(new CompileError($level, $message));
          // Fall-through intended
      }
      echo '*** ', $message, "\n";
    }
%}
 
%left T_INCLUDE T_INCLUDE_ONCE T_EVAL T_REQUIRE T_REQUIRE_ONCE
%left ','
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left '=' T_PLUS_EQUAL T_MINUS_EQUAL T_MUL_EQUAL T_DIV_EQUAL T_CONCAT_EQUAL T_MOD_EQUAL T_AND_EQUAL T_OR_EQUAL T_XOR_EQUAL T_SL_EQUAL T_SR_EQUAL
%left '?' ':'
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left '|'
%left '^'
%left '&'
%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL
%nonassoc '<' T_IS_SMALLER_OR_EQUAL '>' T_IS_GREATER_OR_EQUAL T_COMPARE_ARROW
%left T_SL T_SR
%left '+' '-' '.'
%left '*' '/' '%'
%right '!'
%nonassoc T_INSTANCEOF
%right '~' T_INC T_DEC T_INT_CAST T_DOUBLE_CAST T_STRING_CAST T_ARRAY_CAST T_OBJECT_CAST T_BOOL_CAST T_UNSET_CAST '@'
%right '['
%nonassoc T_NEW T_CLONE
%left T_ELSEIF
%left T_ELSE
%left T_ENDIF
%right T_STATIC T_ABSTRACT T_FINAL T_PRIVATE T_PROTECTED T_PUBLIC
%token T_REQUIRE_ONCE 258
%token T_REQUIRE 259
%token T_EVAL 260
%token T_INCLUDE_ONCE 261
%token T_INCLUDE 262
%token T_LOGICAL_OR 263
%token T_LOGICAL_XOR 264
%token T_LOGICAL_AND 265
%token T_PRINT 266
%token T_SR_EQUAL 267
%token T_SL_EQUAL 268
%token T_XOR_EQUAL 269
%token T_OR_EQUAL 270
%token T_AND_EQUAL 271
%token T_MOD_EQUAL 272
%token T_CONCAT_EQUAL 273
%token T_DIV_EQUAL 274
%token T_MUL_EQUAL 275
%token T_MINUS_EQUAL 276
%token T_PLUS_EQUAL 277
%token T_BOOLEAN_OR 278
%token T_BOOLEAN_AND 279
%token T_IS_NOT_IDENTICAL 280
%token T_IS_IDENTICAL 281
%token T_IS_NOT_EQUAL 282
%token T_IS_EQUAL 283
%token T_IS_GREATER_OR_EQUAL 284
%token T_IS_SMALLER_OR_EQUAL 285
%token T_SR 286
%token T_SL 287
%token T_INSTANCEOF 288
%token T_UNSET_CAST 289
%token T_BOOL_CAST 290
%token T_OBJECT_CAST 291
%token T_ARRAY_CAST 292
%token T_STRING_CAST 293
%token T_DOUBLE_CAST 294
%token T_INT_CAST 295
%token T_DEC 296
%token T_INC 297
%token T_CLONE 298
%token T_NEW 299
%token T_EXIT 300
%token T_IF 301
%token T_ELSEIF 302
%token T_ELSE 303
%token T_ENDIF 304
%token T_LNUMBER 305
%token T_DNUMBER 306
%token T_STRING 307
%token T_STRING_VARNAME 308
%token T_VARIABLE 309
%token T_NUM_STRING 310
%token T_INLINE_HTML 311
%token T_CHARACTER 312
%token T_BAD_CHARACTER 313
%token T_ENCAPSED_AND_WHITESPACE 314
%token T_CONSTANT_ENCAPSED_STRING 315
%token T_ECHO 316
%token T_DO 317
%token T_WHILE 318
%token T_ENDWHILE 319
%token T_FOR 320
%token T_ENDFOR 321
%token T_FOREACH 322
%token T_ENDFOREACH 323
%token T_DECLARE 324
%token T_ENDDECLARE 325
%token T_AS 326
%token T_SWITCH 327
%token T_ENDSWITCH 328
%token T_CASE 329
%token T_DEFAULT 330
%token T_BREAK 331
%token T_CONTINUE 332
%token T_FUNCTION 333
%token T_CONST 334
%token T_RETURN 335
%token T_TRY 336
%token T_CATCH 337
%token T_THROW 338
%token T_USE 339
%token T_GLOBAL 340
%token T_PUBLIC 341
%token T_PROTECTED 342
%token T_PRIVATE 343
%token T_FINAL 344
%token T_ABSTRACT 345
%token T_STATIC 346
%token T_VAR 347
%token T_UNSET 348
%token T_ISSET 349
%token T_EMPTY 350
%token T_CLASS 351
%token T_INTERFACE 352
%token T_EXTENDS 353
%token T_IMPLEMENTS 354
%token T_OBJECT_OPERATOR 355
%token T_DOUBLE_ARROW 356
%token T_LIST 357
%token T_ARRAY 358
%token T_CLASS_C 359
%token T_METHOD_C 360
%token T_FUNC_C 361
%token T_LINE 362
%token T_FILE 363
%token T_COMMENT 364
%token T_DOC_COMMENT 365
%token T_OPEN_TAG 366
%token T_OPEN_TAG_WITH_ECHO 367
%token T_CLOSE_TAG 368
%token T_WHITESPACE 369
%token T_START_HEREDOC 370
%token T_END_HEREDOC 371
%token T_DOLLAR_OPEN_CURLY_BRACES 372
%token T_CURLY_OPEN 373
%token T_DOUBLE_COLON 374

%token T_HALT_COMPILER 375
%token T_CLASSNAME 376
%token T_PACKAGE 377
%token T_ENUM 378
%token T_OPERATOR 379
%token T_THROWS 380
%token T_COMPARE 381
%token T_IMPORT 382
%token T_VOID 383
%token T_CONSTRUCT 384
%token T_FINALLY 385
%token T_DESTRUCT 386
%token T_NATIVE 387
%token T_PROPERTY 388

%% /* Rules */

start:
	top_statement_list  { /* echo PNode::stringOf($$); */ }
;

top_statement_list:
		top_statement_list top_statement  { $$[]= $2; }
	|	/* empty */
;

top_statement:
		statement                       
	|	function_declaration_statement
	|	class_declaration_statement
	|	package_declaration_statement
	|	enum_declaration_statement
;

inner_statement_list:
		inner_statement_list inner_statement {
          $$[]= $2; 
        }
	|	/* empty */ {
          $$= NULL; 
        }
;

inner_statement:
		statement
	|	function_declaration_statement
	|	class_declaration_statement
	|	package_declaration_statement
;

statement:
		'{' inner_statement_list '}' { $$= $2; }
	|	T_IF '(' expr ')' statement elseif_list else_single { 
          $$= &new IfNode($3, $5, $6, $7);
        }
	|	T_WHILE '(' expr ')' statement {
          $$= &new WhileNode($3, $5);
        }
	|	T_DO statement T_WHILE '(' expr ')' ';' {
          $$= &new DoWhileNode($5, $2);
        }
	|	T_FOR '(' for_expr ';' for_expr ';' for_expr ')' statement {
          $$= &new ForNode($3, $5, $7, $9);
        }
	|	T_SWITCH '(' expr ')' switch_case_list {
          $$= &new SwitchNode($3, $5);
        }
	|	T_BREAK ';'				{ 
          $$= &new BreakNode(NULL);
        }
	|	T_BREAK expr ';' {
          $$= &new BreakNode($2);
        }
	|	T_CONTINUE ';' {
          $$= &new ContinueNode(NULL);
        }
	|	T_CONTINUE expr ';' {
          $$= &new ContinueNode($2);
        }
	|	T_RETURN ';' { 
          $$= &new ReturnNode(NULL);
        }
	|	T_RETURN expr_without_variable ';' { 
          $$= &new ReturnNode($2);
        }
	|	T_RETURN variable ';' {
          $$= &new ReturnNode($2);
        }
	|	T_STATIC static_var_list ';'
	|	T_ECHO echo_expr_list ';' { 
          $$= &new EchoNode($2);
        }
	|	expr ';' { 
          // Intentionally empty
        }
	|	T_USE use_filename ';' {
    	  $this->error(E_COMPILE_ERROR, 'use: Not yet supported. Please use include_once() or require_once()');
        }
	|	T_UNSET '(' unset_variables ')' ';'
	|	T_FOREACH '(' variable T_AS foreach_variable foreach_optional_arg ')' statement {
          $$= &new ForeachNode($3, $5, $6, $8);
        }
	|	T_FOREACH '(' expr_without_variable T_AS w_variable foreach_optional_arg ')' statement {
          $$= &new ForeachNode($3, $5, $6, $8);
        }
	|	T_DECLARE { /* TBI */ }
	|	';'		/* empty statement */
	|	T_TRY '{' inner_statement_list '}' T_CATCH '(' fully_qualified_class_name T_VARIABLE ')' '{' inner_statement_list '}' additional_catches optional_finally {
          $$= &new TryNode($3, new CatchNode($7, $8, $11, $13), $14);
        }
	|	T_THROW expr ';' { 
          $$= &new ThrowNode($2);
        }
	|	T_IMPORT import_list ';' { 
          $$= &new ImportListNode($2);
        }
;

import_list:
		import_list ',' import { 
          $$[]= $3; 
        }
	|	import { 
          $$= $1; 
        }
;

import:
		class_name_reference { 
          $$= &new ImportNode($1, NULL); 
        }
	|	class_name_reference T_AS T_STRING { 
          $$= &new ImportNode($1, $3); 
        }
	|	class_name_reference T_AS r_variable { 
          $$= &new ImportNode($1, $3); 
        }
;

additional_catches:
		non_empty_additional_catches { 
          $$= $1; 
        }
	|	/* empty */ { 
          $$= NULL; 
        }
;

non_empty_additional_catches:
		additional_catch { 
          $$= array($1); 
        }
	|	non_empty_additional_catches additional_catch { 
          $$[]= $2; 
        }
;

optional_finally:
		T_FINALLY '{' inner_statement_list '}' {
          $$= &new FinallyNode($3);
        }
	|	/* empty */ { 
          $$= NULL; 
        }
;

additional_catch:
	T_CATCH '(' fully_qualified_class_name T_VARIABLE ')' '{' inner_statement_list '}' {
      $$= &new CatchNode($3, $4, $7, NULL);
    }
;

unset_variables:
		unset_variable
	|	unset_variables ',' unset_variable
;

unset_variable:
		variable { 
          $$= &PNode::create('Unset', array(&$1)); 
        }
;

use_filename:
		T_CONSTANT_ENCAPSED_STRING			{ $$ = $1; }
	|	'(' T_CONSTANT_ENCAPSED_STRING ')'	{ $$ = $2; }
;

package_inner_statement_list:
	   	package_inner_statement_list package_inner_statement { 
          $$[]= $2;
        }
	|   /* empty */ {
          $$= NULL;
        }
;

package_inner_statement:
		class_declaration_statement
	|	enum_declaration_statement
	|	T_IMPORT package_import_list ';' {
          $$= &new ImportListNode($2);
        }
;

package_import_list:
		package_import_list ',' package_import
	|	package_import
;

package_import:
		T_CLASSNAME {
          $$= &new ImportNode($1, NULL);
        }
	|	T_CLASSNAME T_AS T_STRING {
          $$= &new ImportNode($1, $3);
        }
;

function_declaration_statement:
		T_FUNCTION T_STRING '(' parameter_list ')' '{' inner_statement_list '}' { 
          $$= &new FunctionDeclarationNode($2, $4, $7);
        }
;

optional_annotation_list:
		/* empty */       { $$= NULL; }
	|	annotation_list   { $$= $1; }
;

class_declaration_statement:
		optional_annotation_list class_entry_type T_STRING extends_from implements_list '{' class_statement_list '}' {
          $$= &new ClassDeclarationNode($3, $4, $5, $7, $2, $1);
        }
	|	optional_annotation_list interface_entry T_STRING interface_extends_list '{' class_statement_list '}' {
          $$= &new InterfaceDeclarationNode($3, $4, $6, $2, $1);
        }
;

package_declaration_statement:
		T_PACKAGE fully_qualified_class_name '{' package_inner_statement_list '}' {
          $$= &new PackageDeclarationNode($2, $4);
        }
;

class_entry_type:
		T_CLASS					{ $$= 0; }
	|	T_ABSTRACT T_CLASS		{ $$= MODIFIER_ABSTRACT; }
	|	T_FINAL T_CLASS			{ $$= MODIFIER_FINAL; }
;

extends_from:
		/* empty */								{ $$= NULL; }
	|	T_EXTENDS fully_qualified_class_name	{ $$= $2; }
;

interface_entry:
	T_INTERFACE		{ $$= 0; }
;

interface_extends_list:
		/* empty */
	|	T_EXTENDS interface_list { $$= $2; }
;

implements_list:
		/* empty */                   { $$= NULL; }
	|	T_IMPLEMENTS interface_list   { $$= $2; }
;

interface_list:
		fully_qualified_class_name						{ $$= array($1); }
	|	interface_list ',' fully_qualified_class_name 	{ $$[]= $3; }
;

enum_declaration_statement:
		optional_annotation_list T_ENUM T_STRING '{' enum_inner_statement_list '}' {
          $$= &new EnumDeclarationNode($3, $5, $1);
        }
;

enum_inner_statement_list:
		enum_declaration_list
	| 	enum_declaration_list ';' class_statement_list
;

enum_declaration_list:
		enum_declaration_list ',' enum_declaration_list_member {
          $$[]= $3;
        }
	|	enum_declaration_list_member {
          $$= array($1);
        }
;

enum_declaration_list_member:
		T_STRING {
          $$= &PNode::create('EnumMember', array($1, NULL));
        }
	|	T_STRING '(' static_scalar ')' {
          $$= &PNode::create('EnumMember', array($1, $3));
        }
	|	T_STRING '{' method_declaration '}' {
          $$= &PNode::create('EnumMethod', array($1, &$3));
        }
;

foreach_optional_arg:
		/* empty */						{ $$= NULL; }
	|	T_DOUBLE_ARROW foreach_variable	{ $$= $2; }
;


foreach_variable:
		w_variable			{ $$= $1; }
	|	'&' w_variable		{ $$= $2; }
;

switch_case_list:
		'{' case_list '}'					{ $$= $2; }
	|	'{' ';' case_list '}'				{ $$= $3; }
;


case_list:
		/* empty */	{ 
          $$= array();
        }
	|	case_list T_CASE expr case_separator inner_statement_list { 
          $$[]= &new CaseNode($3, $5);
        }
	|	case_list T_DEFAULT case_separator inner_statement_list {
          $$[]= &new DefaultNode($4);
        }
;

case_separator:
		':'
	|	';'
;

elseif_list:
		/* empty */ {
          $$= NULL;
        }
	|	elseif_list T_ELSEIF '(' expr ')' statement {
          $$= &PNode::create('ElseIf', array($4, $6));
        }
;

else_single:
		/* empty */
	|	T_ELSE statement {
          $$= $2;
        }
;

parameter_list: 
		non_empty_parameter_list {
          $$= $1;
        }
	|	/* empty */ {
          $$= NULL;
        }
;

non_empty_parameter_list:
		optional_class_type T_VARIABLE {
          $$= array(new ParameterNode($2, $1, NULL));
        }
	|	optional_class_type T_VARIABLE '=' static_scalar {
          $$= array(new ParameterNode($2, $1, $4));
        }
	|	non_empty_parameter_list ',' optional_class_type T_VARIABLE {
          $$[]= &new ParameterNode($4, $3, NULL);
        }
	|	non_empty_parameter_list ',' optional_class_type T_VARIABLE '=' static_scalar {
          $$[]= &new ParameterNode($4, $3, $6);
        }
;

optional_class_type:
		/* empty */		{ $$= NULL; }
	|	T_STRING		{ $$= $1; }
	|	T_CLASSNAME     { $$= $1; }
	|	T_ARRAY		    { $$= 'array'; }
	|	T_STRING '[' ']' { $$= array($1); }
	|	T_CLASSNAME '[' ']' { $$= array($1); }
;

function_call_parameter_list:
		non_empty_function_call_parameter_list	{ $$= $1; }
	|	/* empty */				                { $$= array(); }
;


non_empty_function_call_parameter_list:
		expr_without_variable	                                            { $$= array($1); }
	|	variable				                                            { $$= array($1); }
	|	'&' w_variable 			                                            { $$= array($2);  }
	|	non_empty_function_call_parameter_list ',' expr_without_variable	{ $$[]= $3; }
	|	non_empty_function_call_parameter_list ',' variable					{ $$[]= $3; }
	|	non_empty_function_call_parameter_list ',' '&' w_variable			{ $$[]= $4; }
;

static_var_list:
		static_var_list ',' T_VARIABLE {
          $$[]= &PNode::create('StaticVariable', array($3, NULL));
        }
	|	static_var_list ',' T_VARIABLE '=' static_scalar {
          $$[]= &PNode::create('StaticVariable', array($3, $5));
        }
	|	T_VARIABLE  {
          $$= array(PNode::create('StaticVariable', array($1, NULL)));
        }
	|	T_VARIABLE '=' static_scalar {
          $$= array(PNode::create('StaticVariable', array($1, $3)));
        }
;


class_statement_list:
		class_statement_list class_statement    { $$[]= $2; }
	|	/* empty */                             { $$= array(); }
;

class_statement:
		non_empty_member_modifiers optional_class_type class_variable_declaration ';' {
          $$= &new MemberDeclarationListNode($1, $2, $3); 
        }
	|	class_constant_declaration ';' {
          $$= &PNode::create('ClassConstantDeclarationList', array($1, $2)); 
        }
	|	non_empty_member_modifiers T_OPERATOR operator_token '(' parameter_list ')' throws method_body {
          $$= &new OperatorDeclarationNode($3, $5, $8, $1, NULL, $7);
        }
	|	annotation_list non_empty_member_modifiers T_OPERATOR operator_token '(' parameter_list ')' throws method_body {
          $$= &new OperatorDeclarationNode($4, $6, $9, $2, $1, $8);
        }
    |   method_declaration
;

method_declaration:
	 	non_empty_member_modifiers T_CONSTRUCT '(' parameter_list ')' throws method_body {
          $$= &new ConstructorDeclarationNode($4, $7, $1, NULL, $6);
        }
	|	annotation_list non_empty_member_modifiers T_CONSTRUCT '(' parameter_list ')' throws method_body {
          $$= &new ConstructorDeclarationNode($5, $8, $2, $1, $7);
        }
	| 	non_empty_member_modifiers T_DESTRUCT '(' ')' throws method_body {
          $$= &new DestructorDeclarationNode($6, $1, NULL, $5);
        }
	|	annotation_list non_empty_member_modifiers T_DESTRUCT '(' ')' throws method_body {
          $$= &new DestructorDeclarationNode($7, $2, $1, $6);
        }
	|	non_empty_member_modifiers return_type_name T_STRING '(' parameter_list ')' throws method_body {
          $$= &new MethodDeclarationNode($3, $5, $2, $8, $1, NULL, $7);
        }
	|	annotation_list non_empty_member_modifiers return_type_name T_STRING '(' parameter_list ')' throws method_body {
          $$= &new MethodDeclarationNode($4, $6, $3, $9, $2, $1, $8);
        }
;

return_type_name:
	    T_STRING { 
          $$= $1; 
        }
	|   T_CLASSNAME { 
          $$= $1; 
        }
	|   T_STRING '[' ']' { 
          $$= array($1); 
        }
	|   T_CLASSNAME '[' ']' { 
          $$= array($1); 
        }
    |   T_VOID      { 
          $$= NULL; 
        }
    |   T_FUNCTION  { 
          $$= 'mixed'; 
          $this->error(E_STRICT, '"function" is deprecated, use return type or "void" instead'); 
        }
;

throws:
		/* empty */ { 
          $$= NULL; 
        }
	|	T_THROWS throws_list { 
          $$= $2; 
        }
;

throws_list:
		fully_qualified_class_name {
          $$= array($1); 
        }
	|	throws_list ',' fully_qualified_class_name	{ 
          $$[]= $3; 
        }
;	

annotation_list:
		'[' annotation_elements ']' { 
          $$= $2; 
        }
;

annotation_elements:
		annotation {
          $$= array($1);
        }
	|	annotation_elements ',' annotation {
          $$[]= $3;
        }
;

annotation:
		'@' T_STRING { 
          $$= &PNode::create('Annotation', array($2, NULL)); 
        }
	|	'@' T_STRING '(' common_scalar ')' { 
          $$= &PNode::create('Annotation', array($2, $4)); 
        }
	|	'@' T_STRING '(' annotation_defines ')' { 
          $$= &PNode::create('Annotation', array($2, $4)); 
        }
;

annotation_defines:
		annotation_define
	|	annotation_defines ',' annotation_define
;

annotation_define:
		T_STRING { /* TBI compiler::call('zend_do_annotation_define', array($1, NULL )); */ }
	|	T_STRING '=' static_scalar  { /* TBI compiler::call('zend_do_annotation_define', array($1, $3)); */ }
;

operator_token:
		'+'								{ $$= '+'; }
	|	'-'								{ $$= '-'; }
	|	'*'								{ $$= '*'; }
	|	'/'								{ $$= '/'; }
	|	'%'								{ $$= '%'; }
	|	'!'								{ $$= '!'; }
	|	'.'								{ $$= '.'; }
	|	T_INC							{ $$= '++'; }
	|	T_DEC							{ $$= '--'; }
	|	T_COMPARE						{ $$= '__compare'; }
;

method_body:
		';' /* abstract method */		{ $$= NULL; }
	|	'{' inner_statement_list '}'	{ $$= $2; }
;

non_empty_member_modifiers:
		member_modifier								{ $$= $1; }
	|	non_empty_member_modifiers member_modifier	{ $$= $1 | $2; }
;

member_modifier:
		T_PUBLIC				{ $$= MODIFIER_PUBLIC; }
	|	T_PROTECTED				{ $$= MODIFIER_PROTECTED; }
	|	T_PRIVATE				{ $$= MODIFIER_PRIVATE; }
	|	T_STATIC				{ $$= MODIFIER_STATIC; }
	|	T_ABSTRACT				{ $$= MODIFIER_ABSTRACT; }
	|	T_FINAL					{ $$= MODIFIER_FINAL; }
	|	T_NATIVE				{ $$= MODIFIER_NATIVE; }
;

class_variable_declaration:
        class_variable_declaration ',' class_variable  { $$[]= $3; }
    |   class_variable { $$= array($1); }
;

class_variable:
	|	T_VARIABLE {
          $$= new MemberDeclarationNode($1, NULL, NULL);
        }
	|	T_VARIABLE '=' static_scalar {
          $$= new MemberDeclarationNode($1, $3, NULL);
        }
    |   T_PROPERTY T_VARIABLE get_or_set get_or_set {
          $$= new PropertyDeclarationNode($2, array_merge($3, $4));
        }
;

get_or_set:
        T_STRING T_STRING '(' ')' {
         $1 == 'get' || $1 == 'set' ? $$= array($1 => $2) : $this->raiseError($1.' not supported');
        }
    |   T_STRING T_VARIABLE {
         $1 == 'get' || $1 == 'set' ? $$= array($1 => $2) : $this->raiseError($1.' not supported');
        }
    |   T_STRING T_VOID {
         $1 == 'get' || $1 == 'set' ? $$= array($1 => NULL) : $this->raiseError($1.' not supported');
        }
;

class_constant_declaration:
		class_constant_declaration ',' T_STRING '=' static_scalar {
          $$[]= &PNode::create('ClassConstantDeclaration', array($2, &$3));
        }
	|	T_CONST T_STRING '=' static_scalar	{
          $$= array(PNode::create('ClassConstantDeclaration', array($2, &$3)));
        }
;

echo_expr_list:	
		echo_expr_list ',' expr { $$[]= $3; }
	|	expr					{ $$= array($1); }
;


for_expr:
		/* empty */			        { $$= TRUE; }
	|	non_empty_for_expr	        { $$= $1; }
;

non_empty_for_expr:
		non_empty_for_expr ',' expr { $$[]= $3; }
	|	expr					    { $$= array($1); }
;

expr_without_variable:	
		T_LIST '(' assignment_list ')' '=' expr {
          $$= &PNode::create('ListAssign', array($3, &$6));
        }
	|	variable '=' expr {
          $$= &new AssignNode($1, $3);
        }
	|	T_NEW class_name_reference ctor_arguments {
          $$= &new NewNode($2, $3);
        }
	|	T_CLONE expr { 
          $$= &PNode::create('Clone', array(&$2));
        }
	|	variable T_PLUS_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '+');
        }
	|	variable T_MINUS_EQUAL expr	{
          $$= &new BinaryAssignNode($1, $3, '-');
        }
	|	variable T_MUL_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '*');
        }
	|	variable T_DIV_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '/');
        }
	|	variable T_CONCAT_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '.');
        }
	|	variable T_MOD_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '%');
        }
	|	variable T_AND_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '&');
        }
	|	variable T_OR_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '|');
        }
	|	variable T_XOR_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '^');
        }
	|	variable T_SL_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '<<');
        }
	|	variable T_SR_EQUAL expr {
          $$= &new BinaryAssignNode($1, $3, '>>');
        }
	|	rw_variable T_INC {
          $$= &new PostIncNode($1);
        }
	|	T_INC rw_variable {
          $$= &new PreIncNode($1);
        }
	|	rw_variable T_DEC {
          $$= &new PostDecNode($1);
        }
	|	T_DEC rw_variable {
          $$= &new PreDecNode($1);
        }
	|	expr T_BOOLEAN_OR expr {
          $$= &PNode::create('Boolean', array(&$1, &$3, '||'));
        }
	|	expr T_BOOLEAN_AND expr {
          $$= &PNode::create('Boolean', array(&$1, &$3, '&&'));
        }
	|	expr T_LOGICAL_OR expr {    // "or"
          $$= &PNode::create('Boolean', array(&$1, &$3, '||'));
        }
	|	expr T_LOGICAL_AND expr {   // "and"
          $$= &PNode::create('Boolean', array(&$1, &$3, '&&'));
        }
	|	expr T_LOGICAL_XOR expr {   // "xor"
          $$= &PNode::create('Boolean', array(&$1, &$3, '^^'));
        }
	|	expr '|' expr {
          $$= &new BinaryNode($1, $3, '|');
        }
	|	expr '&' expr {
          $$= &new BinaryNode($1, $3, '&');
        }
	|	expr '^' expr {
          $$= &new BinaryNode($1, $3, '^');
        }
	|	expr '.' expr {
          $$= &new BinaryNode($1, $3, '.');
        }
	|	expr '+' expr {
          $$= &new BinaryNode($1, $3, '+');
        }
	|	expr '-' expr {
          $$= &new BinaryNode($1, $3, '-');
        }
	|	expr '*' expr {
          $$= &new BinaryNode($1, $3, '*');
        }
	|	expr '/' expr {
          $$= &new BinaryNode($1, $3, '/');
        }
	|	expr '%' expr {
          $$= &new BinaryNode($1, $3, '%');
        }
	| 	expr T_SL expr {
          $$= &new BinaryNode($1, $3, '<<');
        }
	|	expr T_SR expr {
          $$= &new BinaryNode($1, $3, '>>');
        }
	|	'+' expr {
          $$= &new BinaryNode(NULL, $2, '+');
        }
	|	'-' expr {
          $$= &new BinaryNode(NULL, $2, '-');
        }
	|	'!' expr {
          $$= &new NotNode($2);
        }
	|	'~' expr {
          $$= &PNode::create('Unary', array(&$2, '~'));
        }
	|	expr T_IS_IDENTICAL expr {
          $$= &new BinaryNode($1, $3, '===');
        }
	|	expr T_IS_NOT_IDENTICAL expr {
          $$= &new BinaryNode($1, $3, '!==');
        }
	|	expr T_IS_EQUAL expr {
          $$= &new BinaryNode($1, $3, '==');
        }
	|	expr T_IS_NOT_EQUAL expr {
          $$= &new BinaryNode($1, $3, '!=');
        }
	|	expr '<' expr {
          $$= &new BinaryNode($1, $3, '<');
        }
	|	expr T_IS_SMALLER_OR_EQUAL expr {
          $$= &new BinaryNode($1, $3, '<=');
        }
	|	expr '>' expr {
          $$= &new BinaryNode($1, $3, '>');
        }
	|	expr T_IS_GREATER_OR_EQUAL expr {
          $$= &new BinaryNode($1, $3, '>=');
        }
	|	expr T_COMPARE_ARROW expr {
          $$= &new BinaryNode($1, $3, '<=>');
        }
	|	expr T_INSTANCEOF class_name_reference { 
          $$= &new InstanceOfNode($1, $3);
        }
	|	'(' expr ')' { 
          $$= &$2; 
        }
	|	expr '?' expr ':' expr	{
          $$= &new TernaryNode($1, $3, $5);
        }
	|	internal_functions_in_yacc { $$ = $1; }
	|	T_INT_CAST expr 	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_LONG )); */ }
	|	T_DOUBLE_CAST expr 	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_DOUBLE )); */ }
	|	T_STRING_CAST expr	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_STRING )); */ } 
	|	T_ARRAY_CAST expr 	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_ARRAY )); */ }
	|	T_OBJECT_CAST expr 	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_OBJECT )); */ }
	|	T_BOOL_CAST expr	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_BOOL )); */ }
	|	T_UNSET_CAST expr	{ /* TBI compiler::call('zend_do_cast', array($$, $2, IS_NULL )); */ }
	|	T_EXIT exit_expr {
          $$= &new ExitNode($2);
        }
	|	'@' expr { 
          /* TBI compiler::call('zend_do_begin_silence', array($1)); } expr { compiler::call('zend_do_end_silence', array($1 )); $$ = $3; */ 
        }
	|	scalar { 
          $$= $1; 
        }
	|	T_ARRAY '(' array_pair_list ')' { $$= $3; }
	|	'`' encaps_list '`'	{
          $$= &PNode::create('Execute', $2);
        }
;

function_call:
		T_STRING '(' function_call_parameter_list ')' {
          $$= &new FunctionCallNode($1, $3);
        }
	|	variable_without_objects '(' function_call_parameter_list ')' {
          $$= &new FunctionCallNode($1, $3);
        }
	|	fully_qualified_class_name T_DOUBLE_COLON T_STRING '(' function_call_parameter_list ')' {
          $$= &new MethodCallNode($1, new MemberNode($3), $5, NULL);
        }
	|   fully_qualified_class_name T_DOUBLE_COLON variable_without_objects '(' function_call_parameter_list ')' {
          $$= &new MethodCallNode($1, new MemberNode($3), $5, NULL);
        }
;

fully_qualified_class_name:
		T_STRING    { $$= $1; }
	|	T_CLASSNAME { $$= $1; }
;

class_name_reference:
		T_STRING				      { $$= &new ClassReferenceNode($1, NULL); }
//	|	T_STRING '<' T_STRING '>'     { $$= &new ClassReferenceNode($1, $3); }
	|	T_CLASSNAME				      { $$= &new ClassReferenceNode($1, NULL); }
//	|	T_CLASSNAME '<' T_STRING '>'  { $$= &new ClassReferenceNode($1, $3); }
;

exit_expr:
		/* empty */ { 
          $$= NULL; 
        }
	|	'(' ')' { 
          $$= NULL; 
        }
	|	'(' expr ')' { 
          $$= $2; 
        }
;

ctor_arguments:
		'(' function_call_parameter_list ')' variable_properties { 
          $$= &new NewClassNode($2, NULL, $4);
        }
	|	'(' function_call_parameter_list ')' '{' class_statement_list '}' variable_properties { 
          $$= &new NewClassNode($2, $5, $7);
        }
;

common_scalar:
		T_LNUMBER 					{ $$= (int)$1; }
	|	T_DNUMBER 					{ $$= (float)$1; }
	|	T_CONSTANT_ENCAPSED_STRING	{ $$= $1; }
	|	T_LINE 						{ $$= (int)$1; }
	|	T_FILE 						{ $$= $1; }
	|	T_CLASS_C					{ $$= $1; }
	|	T_METHOD_C					{ $$= $1; }
	|	T_FUNC_C					{ $$= $1; }
;

static_scalar: /* compile-time evaluated scalars */
		common_scalar				{ $$= $1; }
	|	T_STRING 					{ $$= $1; }
	|	'+' static_scalar			{ $$= $2; }
	|	'-' static_scalar			{ $$= -1 * $2; } 
	|	T_ARRAY '(' static_array_pair_list ')' { $$= $3; }
	|	class_constant 		        { $$ = $1; }
;

scalar:
		T_STRING 				{ $$= $1; }
	|	T_STRING_VARNAME		{ $$= $1; }
	|	class_constant			{ $$= $1; }
	|	common_scalar			{ $$= $1; }
	|	'"' encaps_list '"' 	{ $$= $2; }
	|	'\'' encaps_list '\''	{ $$= $2; }
	|	T_START_HEREDOC encaps_list T_END_HEREDOC { $$ = $2; /* compiler::call('zend_do_end_heredoc'); */ }
;

static_array_pair_list:
		/* empty */ {
          $$= array(); 
        }
	|	non_empty_static_array_pair_list possible_comma	{ 
          $$= $1; 
        }
;

possible_comma:
		/* empty */
	|	','
;

non_empty_static_array_pair_list:
		non_empty_static_array_pair_list ',' static_scalar T_DOUBLE_ARROW static_scalar	{ 
          $$[$3]= $5;
        }
	|	non_empty_static_array_pair_list ',' static_scalar {
          $$[]= $3;
        }
	|	static_scalar T_DOUBLE_ARROW static_scalar {
          $$= array($1 => $3);
        }
	|	static_scalar { 
          $$= array($1);
        }
;

expr:
		r_variable { 
          $$= $1; 
        }
	|	expr_without_variable { 
          $$= $1; 
        }
;

r_variable:
	variable    { $$= $1; }
;

w_variable:
	variable	{ $$= $1; }
;

rw_variable:
	variable	{ $$= $1; }
;

variable:
		base_variable_with_function_calls T_OBJECT_OPERATOR object_property method_or_not variable_properties {
          if (NULL !== $4) {
            // $this->setDate()
            $$= &new MethodCallNode($1, $3, $4, $5);
          } else {
            // $this->date
            $$= &new ObjectReferenceNode($1, $3, $5);
          }
	    }
	|	base_variable_with_function_calls { 
          $$= $1; 
        }
;

variable_properties:
		variable_properties variable_property { 
          $$[]= $2; 
        }
	|	/* empty */ { 
          $$= NULL; 
        }
;

variable_property:
		T_OBJECT_OPERATOR object_property method_or_not {
            if (NULL !== $3) {
              // $this->setOrder()->setDate() or $this->order->setDate()
              $$= &new MethodCallNode(NULL, $2, $3, NULL);
            } else {
              // $this->setOrder()->date or $this->order->date
              $$= &new ObjectReferenceNode(NULL, $2, NULL);
            }
        }
;

method_or_not:
		'(' function_call_parameter_list ')' {
          $$= $2; 
        }
	|	/* empty */ { 
          $$= NULL; 
        }
;

variable_without_objects:
		reference_variable { 
          $$ = $1; 
        }
	|	simple_indirect_reference reference_variable { 
          xp::error('TODO variable_without_objects: simple_indirect_reference reference_variable');
        }
;

static_member:
		fully_qualified_class_name T_DOUBLE_COLON variable_without_objects { 
          $$= &PNode::create('StaticMember', array($1, &$3)); 
        }
;

base_variable_with_function_calls:
		base_variable { 
          $$= $1; 
        }
	|	function_call { 
          $$= $1; 
        }
;

base_variable:
		reference_variable { $$= $1; /* $$->u_EA_type = ZEND_PARSED_VARIABLE; */ }
	|	simple_indirect_reference reference_variable { /* TBI compiler::call('zend_do_indirect_references', array($$, $1, $2 )); $$->u_EA_type = ZEND_PARSED_VARIABLE; */ }
	|	static_member { $$= $1;}
;
	
reference_variable:
		reference_variable '[' dim_offset ']' { 
          $$->offset= $3;
        }
	|	reference_variable '{' expr '}' {
          $$->offset= $3;
        }
	|	compound_variable { 
          $$= $1; 
        }
;
	

compound_variable:
		T_VARIABLE			{ $$= &new VariableNode($1); }
	|	'$' '{' expr '}'	{ $$= &PNode::create('DynamicVariable', array(&$3)); }
;

dim_offset:
		/* empty */		{ $$= NULL; }
	|	expr			{ $$= $1; }
;


object_property:
		object_dim_list { $$ = $1; }
	|	variable_without_objects { }
;

object_dim_list:
		object_dim_list '[' dim_offset ']' { $$->offset= $3; }
	|	object_dim_list '{' expr '}' { $$->offset= $3; }
	|	variable_name { $$= &new MemberNode($1); }
;

variable_name:
		T_STRING		{ $$= $1; }
	|	'{' expr '}'	{ $$= $2; }
;

simple_indirect_reference:
		'$' { /* TBI $$->u_constant_value_lval = 1; */ }
	|	simple_indirect_reference '$' { /* TBI $$->u_constant_value_lval++; */ }
;

assignment_list:
		assignment_list ',' assignment_list_element
	|	assignment_list_element
;

assignment_list_element:
		variable { }
	|	T_LIST '(' assignment_list ')' { }
	|	/* empty */	{ }
;


array_pair_list:
		/* empty */ { 
          $$= array();
        }
	|	non_empty_array_pair_list possible_comma	{ 
          $$ = $1; 
        }
;

non_empty_array_pair_list:
		non_empty_array_pair_list ',' expr T_DOUBLE_ARROW expr {
          $$[$3]= $5;
        }
	|	non_empty_array_pair_list ',' expr {
          $$[]= $3;
        }
	|	expr T_DOUBLE_ARROW expr {
          $$= array($1 => $3);
        }
	|	expr {
          $$= array($1);
        }
	|	non_empty_array_pair_list ',' expr T_DOUBLE_ARROW '&' w_variable { /* TBI compiler::call('zend_do_add_array_element', array($$, $6, $3, 1 )); */ }
	|	non_empty_array_pair_list ',' '&' w_variable { /* TBI compiler::call('zend_do_add_array_element', array($$, $4, NULL, 1 )); */ }
	|	expr T_DOUBLE_ARROW '&' w_variable	{ /* TBI compiler::call('zend_do_init_array', array($$, $4, $1, 1 )); */ }
	|	'&' w_variable 			{ /* TBI compiler::call('zend_do_init_array', array($$, $2, NULL, 1 )); */ }
;

encaps_list:
		encaps_list encaps_var { /* TBI compiler::call('zend_do_end_variable_parse', array(BP_VAR_R, 0 ));  compiler::call('zend_do_add_variable', array($$, $1, $2 )); */ }
	|	encaps_list T_STRING			{ /* TBI compiler::call('zend_do_add_string', array($$, $1, $2 ));  */ }
	|	encaps_list T_NUM_STRING		{ /* TBI compiler::call('zend_do_add_string', array($$, $1, $2 ));  */ }
	|	encaps_list T_ENCAPSED_AND_WHITESPACE	{ /* TBI compiler::call('zend_do_add_string', array($$, $1, $2 ));  */ }
	|	encaps_list T_CHARACTER 		{ /* TBI compiler::call('zend_do_add_char', array($$, $1, $2 ));  */ }
	|	encaps_list T_BAD_CHARACTER		{ /* TBI compiler::call('zend_do_add_string', array($$, $1, $2 ));  */ }
	|	encaps_list '['		{ /* TBI $2->u_constant_value_lval = '['; compiler::call('zend_do_add_char', array($$, $1, $2 ));  */ }
	|	encaps_list ']'		{ /* TBI $2->u_constant_value_lval = ']'; compiler::call('zend_do_add_char', array($$, $1, $2 ));  */ }
	|	encaps_list '{'		{ /* TBI $2->u_constant_value_lval = '{'; compiler::call('zend_do_add_char', array($$, $1, $2 ));  */ }
	|	encaps_list '}'		{ /* TBI $2->u_constant_value_lval = '}'; compiler::call('zend_do_add_char', array($$, $1, $2 ));  */ }
	|	encaps_list T_OBJECT_OPERATOR  {  /* TBI $2->u_constant_value_lval = '-';  compiler::call('zend_do_add_char', array($tmp, $1, $2 ));  $2->u_constant_value_lval = '>'; compiler::call('zend_do_add_char', array($$, $tmp, $2 ));  */ }
	|	/* empty */	{ 
          $$= ''; 
        }

;

encaps_var:
		T_VARIABLE { /* compiler::call('zend_do_begin_variable_parse'); compiler::call('fetch_simple_variable', array($$, $1, 1 )); */ }
	|	T_VARIABLE '[' encaps_var_offset ']' { /* compiler::call('zend_do_begin_variable_parse'); } encaps_var_offset ']'	{ compiler::call('fetch_array_begin', array($$, $1, $4 )); */ }
	|	T_VARIABLE T_OBJECT_OPERATOR T_STRING { /* compiler::call('zend_do_begin_variable_parse'); compiler::call('fetch_simple_variable', array($2, $1, 1 )); compiler::call('zend_do_fetch_property', array($$, $2, $3 )); */ }
	|	T_DOLLAR_OPEN_CURLY_BRACES expr '}' { /* compiler::call('zend_do_begin_variable_parse');  compiler::call('fetch_simple_variable', array($$, $2, 1 )); */ }
	|	T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}' { /* compiler::call('zend_do_begin_variable_parse');  compiler::call('fetch_array_begin', array($$, $2, $4 )); */ }
	|	T_CURLY_OPEN variable '}' { /* $$ = $2; */ }
;

encaps_var_offset:
		T_STRING		{ $$ = $1; }
	|	T_NUM_STRING	{ $$ = $1; }
	|	T_VARIABLE		{ $$ = $1; /* compiler::call('fetch_simple_variable', array($$, $1, 1 )); */ }
;

internal_functions_in_yacc:
		T_ISSET '(' isset_variables ')' { $$ = $3; }
	|	T_EMPTY '(' variable ')'	{ /* compiler::call('zend_do_isset_or_isempty', array(ZEND_ISEMPTY, $$, $3 )); */ }
	|	T_INCLUDE expr 			{ /* compiler::call('zend_do_include_or_eval', array(ZEND_INCLUDE, $$, $2 )); */ }
	|	T_INCLUDE_ONCE expr 	{ /* compiler::call('zend_do_include_or_eval', array(ZEND_INCLUDE_ONCE, $$, $2 ));*/  }
	|	T_EVAL '(' expr ')' 	{ /* compiler::call('zend_do_include_or_eval', array(ZEND_EVAL, $$, $3 )); */ }
	|	T_REQUIRE expr			{ /* compiler::call('zend_do_include_or_eval', array(ZEND_REQUIRE, $$, $2 )); */ }
	|	T_REQUIRE_ONCE expr		{ /* compiler::call('zend_do_include_or_eval', array(ZEND_REQUIRE_ONCE, $$, $2 )); */ }
;

isset_variables:
		variable 				{ /* compiler::call('zend_do_isset_or_isempty', array(ZEND_ISSET, $$, $1 )); */ }
	|	isset_variables ',' { /* compiler::call('zend_do_boolean_and_begin', array($1, $2 )); } variable { compiler::call('zend_do_isset_or_isempty', array(ZEND_ISSET, $tmp, $4 )); compiler::call('zend_do_boolean_and_end', array($$, $1, $tmp, $2 )); */ }
;	

class_constant:
		fully_qualified_class_name T_DOUBLE_COLON T_STRING { 
          $$= &PNode::create('ConstantReference', array($1, $3)); 
        }
;

%%
}
