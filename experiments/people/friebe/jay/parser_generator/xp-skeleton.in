#	jay skeleton

#	character in column 1 determines outcome...
#		# is a comment
#		. is copied
#		t is copied as //t if -t is set
#	other lines are interpreted to call jay procedures

.<?php
. // created by jay 0.8 (c) 1998 Axel.Schreiner@informatik.uni-osnabrueck.de
. // modified by alan@akbkhome.com to try to generate php!
. // modified by cellog@users.sourceforge.net to fit PEAR CS
. // %token constants
.
 tokens var
.
. // Class now
.
 prolog		## %{ ... %} prior to the first %%
.
.    /**
.     * thrown for irrecoverable syntax errors and stack overflow.
.     */
.    
.     var $yyErrorCode = 256;
.
.    /**
.     * Debugging
.     */
.     var $debug = false;
.
.
 tables			## tables for rules, default reduction, and action calls
 debug			## tables for debugging

.    /**
.     * (syntax) error message.
.     * Can be overwritten to control message format.
.     * @param message text to be displayed.
.     * @param expected vector of acceptable tokens, if available.
.     */
.    function raiseError ($message, $expected = null)
.    {     
.        if ($expected !== null ) {
.            $m = "$message expecting";
.            foreach($expected as $e) {
.                $m .= " $e";
.            }
.        } else {
.            $m = $message;
.        }
.        return $this->error(E_COMPILE_ERROR, $message);  
.    }
.
.
.
.    /**
.     * index-checked interface to yyName[].
.     * @param token single character or %token value.
.     * @return token name or [illegal] or [unknown].
.     */
.    function yyname ($token) {
.        if ($token < 0 || $token >  count($this->yyName)) return "[illegal]";
.        if (($name = $this->yyName[$token]) != null) return $name;
.        return "[unknown]";
.    }
.
.    /**
.     * computes list of expected tokens on error by tracing the tables.
.     * @param state for which to compute the list.
.     * @return list of token names.
.     */
.    function yyExpecting ($state) {
.        $len = 0;
.        $ok = array();//new boolean[YyNameClass.yyName.length];
.
.        if (($n =  $this->yySindex[$state]) != 0) {
.            $start = $n;
.            if ($start < 0) { $start = 0; }       
.            for ($token = $start;
.                $token < count($this->yyName) && 
.                        $n+$token < count($this->yyTable); $token++) {
.                if (@$this->yyCheck[$n+$token] == $token && !@$ok[$token] && 
.                        $this->yyName[$token] != null) {
.                    $len++;
.                    $ok[$token] = true;
.                }
.            } // end for
.        }
.        if (($n = $this->yyRindex[$state]) != 0) {
.            $start = $n;
.            if ($start < 0) { $start = 0; }       
.            for ($token = $start;
.                     $token < count($this->yyName)  && 
.                     $n+$token <  count($this->yyTable); $token++) 
.            {
.               if (@$this->yyCheck[$n+$token] == $token && !@$ok[$token] 
.                          && @$this->yyName[$token] != null) {
.                    $len++;
.                    $ok[$token] = true;
.               }
.            } // end for
.        }
.        $result = array();
.        for ($n = $token = 0; $n < $len;  $token++) {
.            if (@$ok[$token]) { $result[$n++] =$this->yyName[$token]; }
.        }
.        return $result;
.    }
.
.
.    /**
.     * initial size and increment of the state/value stack [default 256].
.     * This is not final so that it can be overwritten outside of invocations
.     * of yyparse().
.     */
.    var $yyMax;
.
.    /**
.     * executed at the beginning of a reduce action.
.     * Used as $$ = yyDefault($1), prior to the user-specified action, if any.
.     * Can be overwritten to provide deep copy, etc.
.     * @param first value for $1, or null.
.     * @return first.
.     */
.    function yyDefault ($first) {
.        return $first;
.    }
.
.    /**
.     * the generated parser.
.     * Maintains a state and a value stack, currently with fixed maximum size.
.     * @param yyLex scanner.
.     * @return result of the last reduction, if any.
.     * @throws yyException on irrecoverable parse error.
.     */
.    function yyparse (&$yyLex) {
t        $this->debug = true;
.        $this->yyLex = &$yyLex;
.
.        if ($this->debug)
.           echo "\tStarting jay:yyparse";
.        //error_reporting(E_ALL);
.        if ($this->yyMax <= 0) $this->yyMax = 256;			// initial size
.        $yyState = 0;
.        $yyStates = array();
.        $yyVal = null;
.        $yyVals = array();
.        $this->yyTableCount = count($this->yyTable);
.        $yyToken = -1;                 // current input
.        $yyErrorFlag = 0;              // #tks to shift
.        $tloop = 0;
 local		## %{ ... %} after the first %%

.    
.        while (1) {//yyLoop: 
.            //echo "yyLoop\n";
.            //if ($this->debug) echo "\tyyLoop:\n";
.            for ($yyTop = 0;; $yyTop++) {
.                //if ($this->debug) echo ($tloop++) .">>>>>>yyLoop:yTop = {$yyTop}\n";
.                $yyStates[$yyTop] = $yyState;
.                $yyVals[$yyTop] = $yyVal;
.
.                //yyDiscarded: 
.                for (;;) {	// discarding a token does not change stack
.                    //echo "yyDiscarded\n";
.                    if ($this->debug) echo "\tIn main loop : State = {$yyState}\n";
.                    if ($this->debug) echo "\tyydefred = {$this->yyDefRed[$yyState]}\n";
.                    if (($yyN = $this->yyDefRed[$yyState]) == 0) {	
.                        // else [default] reduce (yyN)
.                        //if ($this->debug) echo "\tA:token is $yyToken\n";
.                        if ($yyToken < 0) {
.                            //if ($this->debug) echo "\tA:advance\n";
.                            if ($yyLex->advance()) {
.                               
.                                $yyToken = $yyLex->token ;
.                            } else {
.                                $yyToken = 0;
.                            }
.                        }
.                        if ($this->debug) {
.                            echo "\tA:token is now " .
.                            "{$this->yyName[$yyToken]} " .token_name($yyToken).  "\n";
.                            var_dump($yyToken);
.                        }
.                        //if ($this->debug) echo "GOT TOKEN $yyToken";
.                        //if ($this->debug) echo "Sindex:  {$this->yySindex[$yyState]}\n";
.
.                        if (($yyN = $this->yySindex[$yyState]) != 0
.                                  && ($yyN += $yyToken) >= 0
.                                  && $yyN < $this->yyTableCount && $this->yyCheck[$yyN] == $yyToken) {
.                            $yyState = $this->yyTable[$yyN];		// shift to yyN
.                            $yyVal = $yyLex->value;
.                            $yyToken = -1;
.                            if ($yyErrorFlag > 0) $yyErrorFlag--;
.                            continue 2; // goto!!yyLoop;
.                        }
. 
.                       
.              
.                        if (($yyN = $this->yyRindex[$yyState]) != 0
.                                && ($yyN += $yyToken) >= 0
.                                && $yyN < $this->yyTableCount && $this->yyCheck[$yyN] == $yyToken) {
.                            $yyN = $this->yyTable[$yyN];			// reduce (yyN)
.                        } else {
.                            switch ($yyErrorFlag) {
.    
.                                case 0:
.                                    $info = $yyLex->parseError();
.                                    $info .= ', Unexpected '.$this->yyName($yyToken).',';
.                                    return $this->raiseError("$info syntax error",
.                                                $this->yyExpecting($yyState));
.                                
.                                case 1: case 2:
.                                    $yyErrorFlag = 3;
.                                    do { 
.                                        if (($yyN = @$this->yySindex
.                                                [$yyStates[$yyTop]]) != 0
.                                                && ($yyN += $this->yyErrorCode) >= 0 && $yyN < $this->yyTableCount
.                                                && $this->yyCheck[$yyN] == $this->yyErrorCode) {
.                                            $yyState = $this->yyTable[$yyN];
.                                            $yyVal = $yyLex->value;
.                                            //vi /echo "goto yyLoop?\n";
.                                            break 3; //continue yyLoop;
.                                        }
.                                    } while ($yyTop-- >= 0);
.                                    $info = $yyLex->parseError();
.                                    return $this->raiseError("$info irrecoverable syntax error");
.    
.                                case 3:
.                                    if ($yyToken == 0) {
.                                        $info =$yyLex->parseError();
.                                        return $this->raiseError("$info irrecoverable syntax error at end-of-file");
.                                    }
.                                    $yyToken = -1;
.                                    //echo "goto yyDiscarded?";  
.                                    break 1; //continue yyDiscarded;		// leave stack alone
.                            }
.                        }
.                    }    
.                    $yyV = $yyTop + 1-$this->yyLen[$yyN];
.                    //if ($this->debug) echo "\tyyV is $yyV\n";
.                    $yyVal = $yyV > $yyTop ? null : $yyVals[$yyV];
.                    // echo "\tyyVal is ". serialize($yyVal) ."\n";
.                    if ($this->debug) echo "\tswitch($yyN)\n";
.                   
. switch ($yyN) {

 actions		## code from the actions within the grammar

.  }
.                   
.                    //if ($this->debug) echo "\tDONE switch\n";if ($this->debug) echo "\t--------------\n";
.                    $yyTop -= $this->yyLen[$yyN];
.                    //if ($this->debug) echo "\tyyTop is $yyTop\n";
.                    $yyState = $yyStates[$yyTop];
.                    //if ($this->debug) echo "\tyyState is {$yyState}\n";
.                    $yyM = $this->yyLhs[$yyN];
.                    //if ($this->debug) echo "\tyyM is now $yyM\n";
.
.
.
.                    if ($yyState == 0 && $yyM == 0) {
.                        $yyState = $yyFinal;
.                        if ($yyToken < 0) {
.                            $yyToken =0;
.                            if ($yyLex->advance()) {
.                                $yyToken = $yyLex->token;
.                            }
.                        }
.                        if ($this->debug) echo "\tTOKEN IS NOW $yyToken\n";
.                        if ($yyToken == 0) {
.                            return $yyVal;
.                        }
.                        //if ($this->debug) echo "\t>>>>> yyLoop(A)?\n";
.                        continue 2; //continue yyLoop;
.                    }
.                    if (($yyN = $this->yyGindex[$yyM]) != 0 && ($yyN += $yyState) >= 0
.                            && $yyN < $this->yyTableCount && $this->yyCheck[$yyN] == $yyState) {
.                        //if ($this->debug) echo "\tyyState: using yyTable\n";
.                        $yyState = $this->yyTable[$yyN];
.                    } else {
.                        //if ($this->debug) echo "\tyyState: using yyDgoto\n";
.                        $yyState = $this->yyDgoto[$yyM];
.                    }  
.                    //if ($this->debug) echo "\t>>>>> yyLoop(B)?\n";
.                    continue 2;//continue yyLoop;
.                }
.            }
.        }
.    }
.
.
 epilog			## text following second %%
.
.
. ?>
