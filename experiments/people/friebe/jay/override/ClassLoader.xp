/* This class is part of the XP framework
 * 
 * $Id: ClassLoader.class.php 8326 2006-11-05 15:42:21Z friebe $
 */

import lang.ClassNotFoundException;

package lang {

  /** 
   * Loads a class
   * 
   * @purpose  Load classes
   * @test     xp://net.xp_framework.unittest.reflection.ClassLoaderTest
   * @see      xp://lang.XPClass#forName
   */
  class ClassLoader extends lang.Object {
    public 
      $classpath= '';
    
    /**
     * Constructor. 
     *
     * The path argument is optional and lets you define where to search for
     * classes (it will be prefixed to the class name)
     *
     * @access  public
     * @param   string path default '' classpath
     */
    public  __construct(string $path= '') {
      if (!empty($path)) $this->classpath= $path~'.';
    }

    /**
     * Creates a string representation
     *
     * @access  public
     * @return  string
     */
    public string toString() {
      return (
        $this->getClassName()~
        ($this->classpath ? '<'~rtrim($this->classpath, '.')~'>' : '')~
        '(search= '~xp::stringOf(explode(PATH_SEPARATOR, ini_get('include_path')))~')'
      );
    }

    /**
     * Load class bytes
     *
     * @access  public
     * @param   string name fully qualified class name
     * @return  string
     */
    public string loadClassBytes(string $name) {
      return file_get_contents($this->findClass($name));
    }
    
    /**
     * Retrieve the default class loader
     *
     * @model   static
     * @access  public
     * @return  &lang.ClassLoader
     */
    public static self getDefault() {
      static $instance= NULL;
      
      if (!$instance) $instance= new self();
      return $instance;
    }
    
    /**
     * Find a class by the specified name (but do not load it)
     *
     * @access  public
     * @param   string class fully qualified class name io.File
     * @return  string filename, FALSE if not found
     */
    public string findClass(string $class) {
      if (!$class) return FALSE;    // Border case

      $filename= str_replace('.', DIRECTORY_SEPARATOR, $this->classpath~$class)~'.php5';
      foreach (array_unique(explode(PATH_SEPARATOR, ini_get('include_path'))) as $dir) {
        if (!file_exists($dir~DIRECTORY_SEPARATOR~$filename)) continue;
        return realpath($dir~DIRECTORY_SEPARATOR~$filename);
      }
      return FALSE;
    }
    
    /**
     * Load the class by the specified name
     *
     * @access  public
     * @param   string class fully qualified class name io.File
     * @return  &lang.XPClass
     * @throws  lang.ClassNotFoundException in case the class can not be found
     */
    public lang.XPClass loadClass(string $class) throws lang.ClassNotFoundException {
      $name= xp::reflect($class);

      if (!class_exists($name)) {
        $qname= $this->classpath~$class;
        if (FALSE === include_class(strtr($qname, '.', DIRECTORY_SEPARATOR))) {
          throw(new lang.ClassNotFoundException('Class "'~$qname~'" not found'));
        }
        xp::registry('class.'~$name, $qname);
        is_callable(array($name, '__static')) && call_user_func(array($name, '__static'));
      }

      $c= new lang.XPClass($name);
      return $c;
    }

    /**
     * Define a class with a given name
     *
     * @access  protected
     * @param   string class fully qualified class name
     * @param   string bytes sourcecode of the class
     * @return  &lang.XPClass
     * @throws  lang.FormatException in case the class cannot be defined
     */
    protected lang.XPClass _defineClassFromBytes(string $class, string $bytes) throws lang.FormatException {
      $name= xp::reflect($class);

      if (!class_exists($name)) {
        $qname= $this->classpath~$class;
        if (FALSE === eval($bytes)) {
          throw(new lang.FormatException('Cannot define class "'~$qname~'"'));
        }
        if (!class_exists($name)) {
          throw(new lang.FormatException('Class "'~$qname~'" not defined'));
        }
        xp::registry('class.'~$name, $qname);
        is_callable(array($name, '__static')) && call_user_func(array($name, '__static'));
      }      

      $c= new lang.XPClass($name);
      return $c;
    }
    
    /**
     * Define a class with a given name
     *
     * @access  public
     * @param   string class fully qualified class name
     * @param   string parent either sourcecode of the class or FQCN of parent
     * @param   string[] interfaces default NULL FQCNs of implemented interfaces
     * @param   string bytes default NULL inner sourcecode of class (containing {}) 
     * @return  &lang.XPClass
     * @throws  lang.FormatException in case the class cannot be defined
     * @throws  lang.ClassNotFoundException if given parent class does not exist
     */
    public lang.XPClass defineClass(string $class, string $parent, string[] $interfaces= NULL, string $bytes= NULL) throws lang.FormatException, lang.ClassNotFoundException {
      
      // If invoked with less than four arguments, old behaviour will be executed
      if (NULL === $bytes) {
        return $this->_defineClassFromBytes($class, $parent);
      }
      
      $name= xp::reflect($class);
      if (!class_exists($name)) {
        $qname= $this->classpath~$class;
        $parentName= xp::reflect($parent);
        
        if (!class_exists($parentName)) {
          throw(new lang.ClassNotFoundException('Parent class '~$parent~' does not exist.'));
        }
        
        $implements= (sizeof($interfaces) 
          ? ' implements ' ~ implode(', ', array_map(array('xp', 'reflect'), $interfaces))
          : ''
        );
        $newBytes= 'class '~$name~' extends '~$parentName~' '~$implements~$bytes;
        if (FALSE === eval($newBytes)) {
          throw(new lang.FormatException('Cannot define class "'~$qname~'"'));
        }
        
        if (!class_exists($name)) {
          throw(new lang.FormatException('Class "'~$qname~'" not defined'));
        }
        
        xp::registry('class.'~$name, $qname);
        is_callable(array($name, '__static')) && call_user_func(array($name, '__static'));
      }
      
      $c= new lang.XPClass($name);
      return $c;
    }
    
    /**
     * Loads a resource.
     *
     * @access  public
     * @param   string filename name of resource
     * @return  string
     * @throws  lang.ElementNotFoundException in case the resource cannot be found
     */
    public string getResource(string $filename) throws lang.ElementNotFoundException {
      foreach (array_unique(explode(PATH_SEPARATOR, ini_get('include_path'))) as $dir) {
        if (!file_exists($dir~DIRECTORY_SEPARATOR~$filename)) continue;
        return file_get_contents($dir~DIRECTORY_SEPARATOR~$filename);
      }
    
      return raise('lang.ElementNotFoundException', 'Could not load resource '~$filename);
    }
    
    /**
     * Retrieve a stream to the resource
     *
     * @access  public
     * @param   string filename name of resource
     * @return  &io.File
     * @throws  lang.ElementNotFoundException in case the resource cannot be found
     */
    public io.File getResourceAsStream(string $filename) throws lang.ElementNotFoundException {
      foreach (array_unique(explode(PATH_SEPARATOR, ini_get('include_path'))) as $dir) {
        if (!file_exists($dir~DIRECTORY_SEPARATOR~$filename)) continue;
        return new io.File($filename);
      }
    
      return raise('lang.ElementNotFoundException', 'Could not load resource '~$filename);
    }
  }
}
