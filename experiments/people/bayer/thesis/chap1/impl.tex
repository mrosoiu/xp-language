% ********** Chapter 1 **********

\section{Implementation}
\label{sec:chap1:impl}

Um mit der Implementation beginnen zu k"onnen musste zun"achst ein als dynamisch ladbare Bibliothek verf"ugbares
PHP erzeugt werden. Hierzu wurde von \cite{PHPHP} ein PHP in der Version 5.2.0 im Quelltext heruntergeladen und 
"ubersetzt, nachdem es mittels des Kommandozeilenparameters "'--enable-embed=shared"' konfiguriert wurde. Die so
erzeugte \emph{libphp5.so} konnte, zusammen mit den vorhandenen Headerdateien, zur Entwicklung genutzt werden.

Nun musste noch daf"ur gesorgt werden, dass sich die vom JSR 223 verlangten Klassen aus \emph{javax.script} im
Classpath befinden. Nachdem allerdings die Klassen aus der Referenzimplementation aus den zum Teil in 
\ref{sec:chap1:prototype} beschriebenen Gr"unden nicht in Frage kamen, wurde von \cite{JAVAHP} ein
\emph{Java Development Toolkit (JDK)} der Version 6 heruntergeladen. Da dieses JDK nicht als System-VM genutzt
werden kann wurde ein Makefile erstellt, welches die zur "Ubersetzung und Ausf"uhrung n"otigen Kommandos
vereinfacht.

Nachdem diese Vorarbeiten geleistet waren konnte mit der eigentlichen Implementation begonnen werden.
Der erste Schritt war das Abbilden des ersten Use-Cases (verf"ugbare ScriptEngines auflisten), erstens um 
sicherzustellen dass die Entwicklungsumgebung den Anforderungen gerecht wird, und zweitens um einen ersten
Eindruck der JSR 223 API zu erhalten. Also wurde im Package \emph{samples} eine Klasse namens
\emph{EngineList} geschrieben, die einen ScriptEngineManager erzeugt, und mittels der Methode
\emph{getEngineFactories()} eine Liste aller verf"ugbaren ScriptEngines erstellt. Der Inhalt dieser
Liste wird dann mittels \emph{System.out.println()} ausgegeben. 
Nachdem dem Makefile ein Target namens "'list"' hinzugef"ugt wurde, ergab ein erstes Ausf"uhren dieser Klasse
zum einen keine Fehler, und zweitens dass dem JDK 6 mit \emph{Mozilla Rhino} bereits eine ScriptEngine beiliegt:
\begin{lstlisting}[caption=erste Tests]
# make list
found 1 available ScriptEngines:
Engine: Mozilla Rhino
#
\end{lstlisting}

Im Folgenden wurde die Klasse \emph{PHPScriptEngineFactory} erstellt, welche gem"a\ss \ref{sec:chap1:design:java} 
das Interface \emph{ScriptEngineFactory} implementiert, hierbei erw"ahnenswert sind die Methoden 
\emph{getProgram()} und \emph{getMethodCallSyntax()}, erstere erstellt aus als Strings vorliegenden
einzelnen Anweisungen ein ausf"uhrbares PHP-Programm, zweitere erzeugt aus den "ubergebenen Parametern
einen der PHP-Syntax entsprechenden Methodenaufruf. Wurde nun die EngineList ausgef"uhrt stellte sich heraus,
dass der ScriptEngineManager die neue ScriptEngine schon erkannte:
\begin{lstlisting}[caption=Neue ScriptEngine]
# make list
found 2 available ScriptEngines:
Engine: Mozilla Rhino
Engine: XP-Framework Turpitude PHP Engine
#
\end{lstlisting}

Nachdem dieser Schritt getan war, wurde mit der Erstellung der eigentlichen ScriptEngine begonnen. Deren
Implementation gestalete sich sehr einfach, da durch das Ableiten der Klasse \emph{AbstactScriptEngine} 
fast alle Varianten der \emph{eval()}-Methode schon vorimplementiert waren, lediglich das Auslesen des
Skriptquelltextes aus einem "ubergebenen \emph{Reader} musste selbst umgesetzt werden. 
Da\ss\ PHP urspr"unglich ausschlie\ss lich als CGI ausgef"uhrt wurde merkt man dem Kern der Sprache noch
deutlich an. So muss eine SAPI Funktionen aufrufen, welche den Beginn des sogenannten "'Requests"', respektive
dessen Ende anzeigen, auch m"ussen Funktionen zum setzen und lesen von HTTP-Headern und Cookies bereitgestellt
werden. Die n"otigen Aufrufe der Zend-Funktionen \emph{php\_module\_startup()} und \emph{php\_request\_startup}
werden in der PHPScriptEngine von zwei privaten, nativen Methoden erledigt: \emph{startUp()} und \emph{shutDown()}. 
Zus"atzlich wurde im Konstructor der PHPScriptEngine ein sogenannter "'ShutdownHook"' eingef"ugt, welcher daf"ur 
sorgt dass zumindest beim Herunterfahren der Virtual Machine shutDown() aufgerufen wird.

Nachdem in Java die Grundlagen gelegt waren konnte mit dem Realisieren des nativen Teiles begonnen werden.
Die l"uckenhafte, an vielen Stellen sogar g"anzlich fehlende Dokumentation der Zend-Engine machte es unm"oglich
herauszufinden was der von den Zend-Entwicklern vorgesehene Weg ist, um PHP auf die beschriebene Art und Weise
einzubetten. Folglich musste erraten werden wie vorgegangen werden sollte.
Ein erster Ansatz PHP-Code auszuf"uhren war die Zend-API Funktion \emph{zend\_eval\_string}. Nachdem der n"otige
Boilerplate-Code geschrieben war zeigten sich auch Erfolge: eine in Java geschriebene HelloWorld-Klasse, welche
den Quelltext <echo "'Hello World\\n"';> direkt an die ScriptEngine weiterreicht, erzeugte die gew"unschte Ausgabe.
Eigehendere Tests unter Zuhilfenahme der \emph{ScriptExec} Klasse, die ein Skript aus einer ihr "ubergebenen Datei
ausliest und an die ScriptEngine weitergibt f"orderten allerdings einen gravierenden Nachteil von zend\_eval\_string
zutage: Sobald als Parameter "'retval\_ptr"' nicht mehr \emph{NULL} "ubergeben wird, wird nicht mehr das komplette
Skript, sondern nur noch die erste Zuweisung innerhalb des Quelltextes ausgef"uhrt. Wurde diese Skript
\begin{lstlisting}[caption=Testscript f"ur zend\_eval\_string()]
$var = "Test";
for ($i=0; $i<10; $i++) {
    printf("Hello %s\n", $var);
}
\end{lstlisting}
mit retval\_ptr == NULL ausgef"uhrt, so wurde wie erwartet der Text "'Hello Test"' zehnfach auf der Konsole
ausgegeben. "Ubergab man allerdings einen Pointer auf ein valides zval-Struct so wurde nichts mehr ausgegeben,
und jener Struct enthielt als Wert den String "'Test"', und zus"atzlilch gab zend\_eval\_string einen Fehlercode
als eigenen R"uckgabewert zur"uck. Dieses Ph"anomen lies sich auch mit beliebig komplizierten Zuweisungen reproduzieren.

TODO:
error\_cb  -> java exceptions
einfache Scripte mit Variablen scheinen zu gehen
zval\_to\_jobject geschrieben, jni api suckt, zend api suckt haerter

zend\_eval\_string nicht der weg - compile\_string. Deswegen: gleich mal Compilable implementiert, PHPCompiledScript
angelegt

rausparsen von PHP-Tags

compile tut, execute segfaultet. Loesung: function call?
function call funktioniert, allerdungs nur mittels Hack...
ErrorCBCalled eingef"uehrt um exit von Fehlern unterscheiden zu k"onnen
Exceptions eingebaut

ini file -> wie?
Segfaults: --enable-debug, C-Frontend schreiben
phpinfo() segfaultet, muss weiter erforscht werden.





% ********** End of chapter **********
