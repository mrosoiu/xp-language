% ********** Chapter 1 **********

\section{Implementation}
\label{sec:chap1:impl}

Um mit der Implementation beginnen zu k"onnen musste zun"achst ein als dynamisch ladbare Bibliothek verf"ugbares
PHP erzeugt werden. Hierzu wurde von \cite{PHPHP} ein PHP in der Version 5.2.0 im Quelltext heruntergeladen und 
"ubersetzt, nachdem es mittels des Kommandozeilenparameters "'--enable-embed=shared"' konfiguriert wurde. Die so
erzeugte \emph{libphp5.so} konnte, zusammen mit den vorhandenen Headerdateien, zur Entwicklung genutzt werden.

Nun musste noch daf"ur gesorgt werden, dass sich die vom JSR 223 verlangten Klassen aus \emph{javax.script} im
Classpath befinden. Nachdem allerdings die Klassen aus der Referenzimplementation aus den zum Teil in 
\ref{sec:javanscripts:prototype} beschriebenen Gr"unden nicht in Frage kamen, wurde von \cite{JAVAHP} ein
\emph{Java Development Toolkit (JDK)} der Version 6 heruntergeladen. Da dieses JDK nicht als System-VM genutzt
werden kann wurde ein Makefile erstellt, welches die zur "Ubersetzung und Ausf"uhrung n"otigen Kommandos
vereinfacht.

Nachdem diese Vorarbeiten geleistet waren konnte mit der eigentlichen Implementation begonnen werden.
Der erste Schritt war das Abbilden des ersten Use-Cases (verf"ugbare ScriptEngines auflisten), erstens um 
sicherzustellen dass die Entwicklungsumgebung den Anforderungen gerecht wird, und zweitens um einen ersten
Eindruck der JSR 223 API zu erhalten. Also wurde im Package \emph{samples} eine Klasse namens
\emph{EngineList} geschrieben, die einen ScriptEngineManager erzeugt, und mittels der Methode
\emph{getEngineFactories()} eine Liste aller verf"ugbaren ScriptEngines erstellt. Der Inhalt dieser
Liste wird dann mittels \emph{System.out.println()} ausgegeben. 
Nachdem dem Makefile ein Target namens "'list"' hinzugef"ugt wurde, ergab ein erstes Ausf"uhren dieser Klasse
zum einen keine Fehler, und zweitens dass dem JDK 6 mit \emph{Mozilla Rhino} bereits eine ScriptEngine beiliegt:
\begin{lstlisting}[caption=erste Tests]
# make list
found 1 available ScriptEngines:
Engine: Mozilla Rhino
#
\end{lstlisting}

Im Folgenden wurde die Klasse \emph{PHPScriptEngineFactory} erstellt, welche wie in Kapitel
\ref{sec:chap1:design:java} beschrieben
das Interface \emph{ScriptEngineFactory} implementiert, hierbei erw"ahnenswert sind die Methoden 
\emph{getProgram()} und \emph{getMethodCallSyntax()}, erstere erstellt aus als Strings vorliegenden
einzelnen Anweisungen ein ausf"uhrbares PHP-Programm, zweitere erzeugt aus den "ubergebenen Parametern
einen der PHP-Syntax entsprechenden Methodenaufruf. Wurde nun die EngineList ausgef"uhrt stellte sich heraus,
dass der ScriptEngineManager die neue ScriptEngine schon erkannte:
\begin{lstlisting}[caption=Neue ScriptEngine]
# make list
found 2 available ScriptEngines:
Engine: Mozilla Rhino
Engine: XP-Framework Turpitude PHP Engine
#
\end{lstlisting}

Nachdem dieser Schritt getan war, wurde mit der Erstellung der eigentlichen ScriptEngine begonnen. Deren
Implementation gestalete sich sehr einfach, da durch das Ableiten der Klasse \emph{AbstactScriptEngine} 
fast alle Varianten der \emph{eval()}-Methode schon vorimplementiert waren, lediglich das Auslesen des
Skriptquelltextes aus einem "ubergebenen \emph{Reader} musste selbst umgesetzt werden. 
Da\ss\ PHP urspr"unglich ausschlie\ss lich als CGI ausgef"uhrt wurde merkt man dem Kern der Sprache noch
deutlich an. So muss eine SAPI Funktionen aufrufen, welche den Beginn des sogenannten "'Requests"', respektive
dessen Ende anzeigen, auch m"ussen Funktionen zum setzen und lesen von HTTP-Headern und Cookies bereitgestellt
werden. Die n"otigen Aufrufe der Zend-Funktionen \emph{php\_module\_startup()} und \emph{php\_request\_startup}
werden in der PHPScriptEngine von zwei privaten, nativen Methoden erledigt: \emph{startUp()} und \emph{shutDown()}. 
Zus"atzlich wurde im Konstructor der PHPScriptEngine ein sogenannter "'ShutdownHook"' eingef"ugt, welcher daf"ur 
sorgt dass zumindest beim Herunterfahren der Virtual Machine shutDown() aufgerufen wird.

Nachdem in Java die Grundlagen gelegt waren konnte mit dem Realisieren des nativen Teiles begonnen werden.
Die l"uckenhafte, an vielen Stellen sogar g"anzlich fehlende Dokumentation der Zend-Engine machte es unm"oglich
herauszufinden was der von den Zend-Entwicklern vorgesehene Weg ist, um PHP auf die beschriebene Art und Weise
einzubetten. Folglich musste durch reines Ausprobieren erraten werden wie vorgegangen werden sollte.
Zun"achst musste ein zur "Ubergabe an die Zend-Engine geeignetes \emph{sapi\_module\_struct} definiert werden.
Hierbei handelt es sich um ein C-Struct, welches im Wesentlichen Pointer auf Callback-Funktionen enth"alt.
Viele dieser Funktionen, wie \emph{read\_cookies} und \emph{send\_headers}, wurden leer implementiert, da sie f"ur 
die geplante Art des Einsatzes nicht sinnvoll sind. Lediglich \emph{error\_callback} soll hier erw"ahnt werden:
innerhalb dieser Methode werden zwei globale Variablen gesetzt, eine zeigt an ob die Fehlermethode aufgerufen wurde,
die andere h"alt die beim Aufruf ausgelesene Fehlermeldung vor, um sie sp"ater an den Benutzer weiterzugeben.
Ein erster Ansatz PHP-Code auszuf"uhren war die Zend-API Funktion \emph{zend\_eval\_string}. Nachdem der n"otige
Boilerplate-Code geschrieben war zeigten sich auch Erfolge: eine in Java geschriebene HelloWorld-Klasse, welche
den Quelltext "'echo 'Hello World';"' direkt an die ScriptEngine weiterreicht, erzeugte die gew"unschte Ausgabe.
Eigehendere Tests unter Zuhilfenahme der \emph{ScriptExec} Klasse, die ein Skript aus einer ihr "ubergebenen Datei
ausliest und an die ScriptEngine weitergibt f"orderten allerdings einen gravierenden Nachteil von zend\_eval\_string
zutage: Sobald als Parameter "'retval\_ptr"' nicht mehr \emph{NULL} "ubergeben wird, wird nicht mehr das komplette
Skript, sondern nur noch die erste Zuweisung innerhalb des Quelltextes ausgef"uhrt. Wurde dieses Skript
\begin{lstlisting}[caption=Testscript f"ur zend\_eval\_string()]
$var = "Test";
for ($i=0; $i<10; $i++) {
    printf("Hello %s\n", $var);
}
\end{lstlisting}
mit retval\_ptr == NULL ausgef"uhrt, so wurde wie erwartet der Text "'Hello Test"' zehnfach auf der Konsole
ausgegeben. "Ubergab man allerdings einen Pointer auf ein valides zval-Struct so wurde nichts mehr ausgegeben,
und jener Struct enthielt als Wert den String "'Test"', und zus"atzlilch gab zend\_eval\_string einen Fehlercode
als eigenen R"uckgabewert zur"uck. Dieses Ph"anomen lies sich auch mit anderen, beliebig komplizierten Zuweisungen 
reproduzieren.

Obwohl der Versuch zend\_eval\_string zu nutzen fehlschlug konnten einige geschriebene Komponenten f"ur weitere
Ans"atze weiterverwandt werden, insbesondere die Funktionen \emph{zval\_to\_jobject} zur Konvertierung des Zend-Engine
Datentypes \emph{zval} in den JNI-Datentyp \emph{jobject}, und \emph{java\_throw}, die dass werfen von Java-Exceptions
aus dem nativen Teil heraus vereinfacht. 
Das Entwickeln der Funktion \emph{zval\_to\_jobject} erwies sich aufgrund der fehlenden Dokumentation der Zend-Engine als
unerwartet kompliziert, insbesondere das Auslesen von Objekten aus zvals erfordert intimes Wissen "uber Zend-Engine Interna.
So werden beispielsweise Eigenschaften, \emph{Properties} genannt, analog zu den Elementen von Arrays intern 
in einer \emph{Hashtable} gespeichert, wobei die Schl"ussel-Namen den Namen der Eigenschaft darstellen. Allerdings wird
dieser Schl"ussel im Falle von privaten und gesch"utzten (\emph{protected}) Eigenschaften gesondert kodiert, in diesem
Falle beginnt er mit einem Nullbyte ($\backslash$0), gefolgt vom Namen der Objektklasse und einem weiteren Nullbyte und dem eigentlichen
Namen des Properties. Verst"andlicherweise sorgt diese Kodierung in C, wo das Nullbyte als Endzeichen f"ur Strings verwandt wird,
f"ur einige Probleme.
Ein weiteres Problem das gel"ost wurde war, dass alle Zend-API Funktionen die
Quelltexte interpretieren erwarten, dass keine PHP-Tags mehr in diesem enthalten sind. PHP-Skripte werden "ublicherweise
innerhalb der Zeichenfolge "'$<$?php"' und "'?$>$"' eingeschlossen, um sie von den umgebenden Inhalten (meist HTML) abzugrenzen.
Die PHPScriptEngine filtert diese Zeichen automatisch aus dem Quelltextstrom.
TODO: zend\_first\_try weil php-errors zu Exceptions

Da zend\_eval\_string offensichtlich ungeeignet war die Anforderungen zu erf"ullen wurde nach einer Alternative gesucht, und
die Funktion \emph{compile\_string} gefunden. Da diese - wie bereits der Name andeutet - den Quelltext lediglich in einen
\emph{zend\_opcode\_array} "ubersetzt und dieser sp"ater ohnehin seperat ausgef"uhrt werden muss, wurde an dieser Stelle dem
geplanten Projektablauf vorgegriffen, und das Interface \emph{Compilable} gleich mitimplementiert. Im Rahmen dieses Schrittes
wurde die Klasse \emph{PHPCompiledScript} wie geplant realisiert. Diese enth"alt die native Methode \emph{execute}, von welcher
der von der PHPScriptEngine erzeugte und in einen im PHPCompiledScript enhaltenen ByteBuffer geschriebene Opcode letztendlich
ausgef"uhrt wird. Hierzu sollte urspr"unglich die Zend-API Methode \emph{execute()} verwandt werden, allerdings fuehrte jeglicher
Aufruf dieser Methode ausschliesslich zu Abst"urzen und Speicherfehlzugriffen, "uber deren Ursachen nur Vermutungen angestellt
werden k"onnen. Schlussendlich gelang es trotz aller Hindernisse Zend-Opcode fehlerfrei auszuf"uhren: die Zend-API Methode
\emph{zend\_call\_function()} l"asst sich zur Ausf"uhrung jeglichen Opcodes missbrauchen, es ist lediglich notwendig einige
Typfelder des Opcode-Arrays mit "'falschen"' Informationen zu f"ullen. Zus"atzlich l"ost dieser Ansatz ein weiteres Problem:
Jede Funktion hat einen R"uckgabewert, aber im Gegensatz zu zend\_eval\_string wird dieser nicht direkt der Methode "ubergeben,
sondern in einem C-Struct des Types \emph{zend\_fcall\_info} gespeichert und l"asst sich von dort erstens m"uhelos auslesen, und
weiterhin beeiflusst er das Ausf"uhrverhalten von zend\_call\_function nicht im Geringsten. Allerdings ergaben sich aus dieser 
Art und Weise Zend-Opcode auszuf"uhren auch einige Abweichungen zu einem "'Standard-PHP"':

Es war nicht mehr m"oglich Kommandozeilenparameter an das so ausgef"uhrte Script zu "ubergeben. Das ist vernachl"assigbar, da
JSR223 diese Art der Daten"ubergabe nicht vorsieht. Weiterhin erhielt der ansonsten innerhalb eines gew"ohnlichen Scriptes nutzlose
PHP-Befehl \emph{return} pl"otzlich einen Sinn: das Script beendete sich und der R"uckgabewert wurde mit der zur"uckgegebenen
Variablen bef"ullt. Getreu dem Motto "'It's not a bug, it's a feature"' wurde dies allerdings nicht als st"orend empfunden, da
der normale \emph{exit}-Befehl sich weiterhin wie gewohnt verhielt, und so nur zus"atzliche Funktionalit"at verf"ugbar wurde.

Der n"achste Schritt war nun die "Ubergabe von Parametern aus Java an den Interpreter. Idealerweise sollten die zu "ubergebenen
Objekte nicht nur hin- und herkopiert werden, sondern sie sollten als Repr"asentation innerhalb der PHP-Umgebung verf"ugbar sein.
Dies bringt den Vorteil mit sich, dass nicht nur die Daten der Objekte, sondern auch deren Funktionalit"at dem PHP-Entwickler zur
Verf"ugung steht. Ausserdem sollte es dem Anwender m"oglich sein Java-Objekte aus PHP heraus zu erzeugen und Methoden auf diesen
Aufuzrufen.

Um dies zu erreichen war es n"otig Klassen "'von Aussen"', also ohne PHP-Quelltext zu nutzen, in den Interpreter zu injizieren,
und Aufrufe auf Objekte dieser Klassen auf C-Ebene abzuhandeln, da nur so auf JNI-Funktionalit"at zugegriffen werden konnte. 
Leider existiert auch zu dieser Seite der Zend-Engine keinerleit Dokumentation, und so musste viel ausprobiert werden um
herauszufinden wie dies zu bewerkstelligen w"are. Schliesslich wurde die Zend-Makro \emph{INIT\_OVERLOADED\_CLASS\_ENTRY} entdeckt,
und nach vielen weiteren Versuchen wurde auch die Bedeutung der einzelnen Paramteter herausgefunden.

Um der Zend-Engine eine Klasse unterzuschieben muss zun"achst ein C-Struct definiert werden das neben einem Struct von Typ
\emph{zend\_object} namens \emph{std} beliebige weitere Daten enthalten kann. Dieses Struct wird f"ur jeden Instanz der Klasse
vorgehalten. Weiterhin wird ein Array vom Typ \emph{function\_entry[]} ben"otigt, welches die Callbacks - im wesentlichen Funktionspointer
auf C-Funktionen - f"ur verschiedene Ereignisse auf dem Objekt enthalten. Besonders erw"ahnenswert sind hier die Funktionen f"ur 
\emph{\_\_call}, \emph{\_\_get} und \emph{\_\_set}, \emph{\_\_call} wird bei jedem Methodenaufruf aufgerufen, und erh"alt neben dem
Funktionsnamen auch alle "ubergebenen Parameter, und bietet so die M"oglichkeit PHP-Methoden direkt in C zu implementieren. 
\emph{\_\_get} und \emph{\_\_set} werden bei jedem lesenden beziehungsweise schreibenden Zugriff auf ein nicht gefundenes Attribut des
Objektes aufgerufen, und erhalten neben dem neuen Wert auch den Namen des Attributes. Weiterhin gibt es noch die beiden Funktionen
\emph{\_\_construct} und \emph{\_\_destruct}, die beim erzeugen beziehungsweise zerst"oren des Objektes aufgerufen werden,
die Funktionen \emph{\_\_sleep} und \emph{\_\_wakeup}, die beim serialisieren beziehungsweise deserialisieren des Objektes zum
Einsatz kommen, sowie die Funktion \emph{\_\_cast}, die das Casten des Objektes auf einen anderen Datentyp implementieren soll.
Diese Funktionspointer werden zusammen mit dem Klassennamen an das Makro "ubergeben, um so einen sogenannten \emph{zend\_class\_entry}
zu erzeugen, der f"ur jede Klasse ein mal global gespeichert wird.
Auf diese Art und Weise konnten die in 
\ref{sec:chap1:design:native} geforderten Klassen und deren Methoden implementiert werden. Alle Callback-Methoden haben keinen (\emph{void})
als R"uckgabewert und m"ussen die Argumente entgegenehmen, die im Zend-API Makro \emph{INTERNAL\_FUNCTION\_PARAMETERS} definiert werden.
Es enth"ahlt unter anderem einen Pointer auf den R"uckgabewert (\emph{return\_value}), einen Pointer auf das Objekt (\emph{this}), vor
allem aber ein Array der beim Aufruf der PHP-Methode "ubergebenen Argumente (\emph{argv}) und einen Ganzzahlenwert, der die Anzahl
der Argumente enth"alt (\emph{argc}).
Um allerdings "uberhaupt JNI-Funktionen nutzen zu k"onnen musste zun"achst die startUp-Funktion erweitert werden: beim Aufruf dieser
wird der JNI-Evironment Pointer als globale Variable gespeichert, auch werden hier die Funktionen aufgerufen, die die Turpitude-Klassen
in die PHP-Umgebung injizieren.

Als erstes wurde die Klasse \emph{TurpitudeEnvironment} implementiert. Das Objekt-Struct enth"alt neben dem zend\_object noch pointer
auf den aktuellen ScripContext sowie die JNI-Umgebung. Eigene, f"ur PHP lesbare Attribute besitzt die Klasse nicht, also mussten
nur die geforderten Methoden umgesetzt werden. Zuvor wurde allerdings getestet, ob das injizieren der Klasse funktioniert hat, und die
ScriptEngine wurde derart angepasst, dass jedem Aufruf eines PHP-Skriptes eine Zeile vorangestellt wird, die eine Instanz der Klasse
erzeugt und in das PHP-Superglobal \emph{\$\_SERVER} eingef"ugt wird. Superglobals sind eine Besonderheit von PHP, normale globale
Variablen m"uessen im Scope einer Funktion oder Methode mittels des Schl"usselwortes \emph{global} bekannt gemacht werden, Superglobals
hingegen sind immer und von "uberall erreichbar. Der Name, unter dem das TurpitudeEnvironment dort eingef"ugt wird ist in der ScriptEngine
mittels der Methoden \emph{setVarName()} und \emph{getVarName()} konfigurierbar. Ein \emph{var\_dump(\$\_SERVER)} zeigte, dass das
injizieren und initialisieren der Klasse funktioniert hatte.
\begin{lstlisting}[caption=TurpitudeEnvironment in \$\_SERVER einf"ugen]
$_SERVER["TURP_ENV"] = new TurpitudeEnvironment();
\end{lstlisting}
In allen Turpitude-Klassen wird hierzu in der Callback-Methoda \emph{\_\_call} der 
Methodenname ausgelesen, der sich in \emph{argv} and der Stelle [0] befindet. Ausserdem wird stets ein Pointer auf die zweite Stelle
von \emph{argv}, sowie ein Integer der um eins kleiner ist als \emph{argc}, an die die eigentlichen
Methoden implementierenden Funktionen "ubergeben, zusammen mit \emph{return\_value} und eventuell dem dem Objekt-eigenen C-Struct.
Diese PHP-Methoden implementierenden Funktionen werden im weiteren Verlauf auch \emph{Handler} genannt.
Danach wird in jeder \emph{\_\_call}-Funktion mittels \emph{strcmp} der Name der aufgerufenen Methode mit den Namen der zu implementierenden 
Methoden verglichen, und falls eine "Ubereinstimmung gefunden wurde wird die jeweilige Funktion aufgerufen. Wird keine "Ubereinstimmung
gefunden wird mittels des Makros \emph{php\_error} ein PHP-Laufzeitfehler erzeugt. Da diese Fehler von Turpitude von der Funktion
\emph{turpitude\_error\_cb} als \emph{PHPEvalException} an die JVM weitergeleitet werden stellen sie ein probates Mittel zum Abbruch
der PHP-Programmausf"uhrung dar, und k"onnen gefahrlos eingesetzt werden.

Die erste Methode des TurpitudeEnvironment, die implementiert wurde war \emph{findClass()}. In der zugeh"origen C-Funktion wird zun"achst 
lediglich "uberpr"uft, ob die Anzahl der Parameter stimmt, und ob der "ubergebene Parameter vom Typ \emph{String} ist. Dann wird die
zur Klasse \emph{TurpitudeJavaClass} geh"orende Funktion \emph{make\_turpitude\_jclass\_instance} aufgerufen, die eine TurpitudeJavaClass
zur"uckgibt. Um eine Instanz dieser
Klasse erzeugen zu k"onnen musste diese allerdings zun"achst dem Interpreter bekannt gemacht werden, dies geschah analog zum Bekanntmachen
von TurpitudeEnvironment. Die Funktion \emph{make\_turpitude\_jclass\_instance} selbst erwartet drei Argumente, eine \emph{jclass} der zu
repr"asentierenden Klasse, deren Klassennamen und einen Pointer auf den zval, der das Objekt enthalten soll. Da die TurpitudeJavaClass 
tats"achlich Attribute (den Klassennamen) enthalten soll, muss die Zend-HashTable initialisiert werden, die diese Attribute enthalten soll.
Dies geschieht mittels der Zend-Funktion \emph{object\_init\_ex}, die neben einem zval-Pointer den class\_entry entgegennimmt.
Nachdem im entsprechenden \emph{object\_struct} die jclass gesetzt wurde konnte schlussendlich "uber die Funktion \emph{zend\_hash\_update} 
der Klassenname in die HashTable eingef"ugt werden. Ein var\_dump einer solchen Klasse sah nun wie folgt aus:
\begin{lstlisting}[caption=Dump einer TurpitudeJavaClass]
object(TurpitudeJavaClass)#4 (1) {
  ["ClassName"]=>
    string(16) "java/lang/String"
}
\end{lstlisting}
Um aus Klassen Objekte erzeugen zu k"onnen muss ein Konstruktor aufgerufen werden. Konstruktoren werden im JNI wie ganz normale Methoden
behandelt, nur dass der Methodenname stets \emph{$<$init$>$} ist. Um mittels JNI eine Methode aufrufen zu k"onnen muss diese zuerst in
Form einer Variablen des Types \emph{jmethodID} vorhanden sein, die wiederum mit der JNI-Umgebung und einer \emph{jclass} erzeugt werden kann.
Hierzu muss neben dem Methodennamen allerdings auch die Signatur der aufzufindenden Methode angegeben werden, und zwar in einer speziellen
Syntax. Diese zu erl"autern w"urde an dieser Stelle den Rahmen sprengen, deswegen hier nur der Verweis auf die JNI-Dokumentation, zu finden
unter \cite{JNIHP}.
Um eine jmethodID f"ur den PHP-Anwender hantierbar zu machen wurde die Klasse TurpitudeJavaMethod eingef"uhrt, wieder analog zu den
vorherigen Klassen. Eine TurpitudeJavaMethod hat weder Attribute noch eigene Methoden, sie wird ausschliesslich als Parameter in Methoden
anderer Klassen ben"otigt. Erzeugt wird ein solches Objekt mit der Methode \emph{findMethod()} der Klasse TurpitudeJavaClass, die zwei 
String-Argumente erwartet: den Methodennamen und die JNI-kodierte Methodensignatur. Die Validit"at dieser beiden Argumente wird nicht explizit
gepr"uft, wird keine entsprechende Methode gefunden wird ein PHP-Fehler erzeugt. Die TurpitudeJavaClass wird durch die Funktion
\emph{make\_turpitude\_jmethod\_instance} erzeugt, und speichert neben ihrem Namen und ihrer Signatur noch einen Indikator der anzeigt
ob sie statisch aufgerufen werden kann. Ausserdem wird im object\_struct die jclass und der im enum \emph{turpitude\_java\_type} definierte
Typ des R"uckgabewertes gespeichert. Dieser wird durch parsen der Signatur ermittelt und wird sp"ater beim Aufruf der Methode ben"otigt.
Neben den einfachen Java-Datentypen wie \emph{int}, \emph{boolean} und \emph{double} werden noch \emph{void} und vor allem \emph{Object} unterschieden,
wobei der eigentliche Typ des Objektes keine Rolle spielt.
Neben der Methode \emph{findMethod()} wurde in der TurpitudeJavaClass noch die Methoden \emph{findStaticMethod()} f"ur statisch
aufrufbare Methoden und \emph{findConstructor()}, die dem Anwender die "Ubergabe von "'$<$init$>$"' als Methodenname erspart, definiert.

Derart erstellte Konstruktoren konnten nun zur Erzeugung von Java-Objekten genutzt werden. Diese sollten in PHP durch die Klasse
\emph{TurpitudeJavaObject} dargestellt werden, und so musste diese zun"achst dem Interpreter auf be"ahrte Weise bekanntgemacht werden.
Neben dem \emph{jobject}, welches das Java-Objekt auf C-Ebene repr"asentiert wird im object\_struct des TurpitudeJavaObject noch die \emph{jclass}
mitgespeichert, was sp"ater klassenspezifische Operationen erleichtern soll. Das Objekt selbst wird schon im call-Handler der TurpitudeJavaClass 
erzeugt, und zwar mittels der JNI-Funktion \emph{NewObject}, falls der Konstruktor keine Argumente erfordert, und er Funktion \emph{NewObjectA} falls
er Argumente erwartet. Alle JNI-Funktionen mit dem Suffix "'A"' am Ende erwarten die an die Java-Methode weiterzureichenden Argumente als Array
des Types \emph{jvalue}, einem Union aller JNI-Typen. Um ein solches Array f"ullen zu k"onnen wurde die Funktion \emph{zval\_to\_jvalue} geschrieben,
die "uber den Typen des zval ermittelt welches Attribut des jvalue bef"ullt werden soll. Leider enth"alt ein jvalue keinerlei Typinformation "uber den
gespeicherten Wert, was sp"ater bei der R"uckumwandlung eines jvalue in einen zval zu Problemen f"uhren k"onnte. Im Gegensatz zur oben beschriebenen 
Funktion \emph{zval\_to\_jobject} wandelt \emph{zval\_to\_jvalue} scalare PHP-Typen nicht in deren Objekt"aquivalente in Java, sondern in die
entsprechenden simplen Java-Typen um. Somit k"onnen auch Konstruktoren (und sp"ater auch Methoden) aufgerufen werden die solche Typen als Argumente
verlangen, ohne sich auf das Autoboxing der JVM verlassen zu m"ussen.
Um aus einem jobject eine Instanz der Klasse
TurpitudeJavaObject zu konstruieren wird es, zusammen mit der zugeh"origen Klasse - sowohl die jclass als auch die TurpitudeJavaClass - an die Funktion 
\emph{make\_turpitude\_jobject\_instance} "ubergeben, in der die eigentliche Instanz angelegt und die Turpitude-Klasse als Attribut "'Class"' hinzugef"ugt wird. 
Eine so erzeugte Repr"asentation eines Java-Objektes vom Typ java.util.Date sieht f"ur den PHP-Anwender wie folgt aus:
\begin{lstlisting}[caption=Dump eines TurpitudeJavaObject]
object(TurpitudeJavaObject)#6 (1) {
  ["Class"]=>
  object(TurpitudeJavaClass)#4 (1) {
    ["ClassName"]=>
    string(14) "java/util/Date"
  }
}
\end{lstlisting}
Nun konnte endlich der Aufruf von Java-Methoden implementiert werden. Der call-Handler des TurpitudeJavaObjects "uberpr"uft zuerst, ob es sich bei der
aufgerufenen Methode um \emph{javaInvoke} handelt. Ist dies der Fall wird die Methode des Java-Objektes aufgerufen, die im ersten Parameter "ubergeben 
wurde. Danach wird - "ahnlich wie bei Konstruktoren - unterschieden, ob neben der aufzurufenden Methode noch andere Argumente "ubergeben wurden, in diesem
Fall wird - wieder wie bei Konstruktoren - ein Array aus jvalues erstellt und je nach Typ des R"uckgabewertes der Methode die entsprechende JNI-Funktion
(Call$<$type$>$MethodA) aufgerufen. Wurden ausser der Methode keine weiteren Parameter mit"ubergeben, wird eine entsprechende Funktion der Signatur
Call$<$type$>$Method (ohne A) aufgerufen. Der R"uckgabewert der aufgerufenen JNI-Funktion wird in einem jvalue gespeichert, der zusammen mit dem
Typen des R"uckgabewertes der Funktion \emph{jvalue\_to\_zval} "ubergeben wird, die letztendlich den zval erzeugt, der an PHP zur"uckgegeben wird.
Im Zuge der Implementation von Methodenaufrufen bei Objekten wurde auch gleich der Aufruf statischer Methoden bei Klassen implementiert, dieser funktioniert exakt 
gleich, nur dass JNI-Funktionen der Signatur CallStatic$<$Type$>$Method(A) aufgerufen werden m"ussen. Zu diesem Zweck wurde die TurpitudeJavaClass um die Methode
\emph{invokeStatic} erweitert.

Da das erzeugen m"ussen von Methoden bevor man sie aufrufen kann doch eher m"uhsam erscheint wurde call-Handler noch derart erweitert, dass wenn keine der
explizit definierten Methoden aufgerufen wurde nicht einfach ein Fehler erzeugt wird, sondern es wird versucht eine Methode gleichen Namens zu finden und diese
aufzurufen. Dazu muss der Anwender allerdings als erstes Argument die Methodensignatur angeben, da es das JNI leider erm"oglicht alle Methoden eines Namens
zu finden, um dann eventuell anhand der weiteren Argumente die richtige Methode zu finden. Ist der erste Parameter also ein String wird versucht eine
Methode zu finden die den Namen der in PHP aufgerufenen Methode tr"agt, und die den "ubergebenen String als Signatur hat. Ist dies der Fall wird einfach 
eine Instanz von TurpitudeJavaMethod erzeugt und an Stelle des Signaturstrings in das Argumentenarray geschrieben. Nun muss nur noch die Funktion aufgerufen
werden die auch die mittels \emph{javaInvoke} aufgerufenen Methoden abhandelt. Folglich kann die Java-Methode \emph{toString()} der Klasse \emph{java.util.Date}
auf diese beiden Arten aufgerufen werden:
\begin{lstlisting}[caption=Zwei Arten die gleiche Methode aufzurufen]
$method = $class->findMethod('toString', '()Ljava/lang/String;');
$string = $date->javaInvoke($method);
oder
$string = $date->toString('()Ljava/lang/String;');
\end{lstlisting}
Weiterhin sollte es dem Anwender erm"oglicht werden, auf Attribute eines Objektes zuzugreifen. Auch Attribute m"ussen mit dem JNI erst erzeugt werden, allerdings
wurde hier auf eine eigene PHP-Klasse verzichtet, sondern es wurden einfach dem TurpitudeJavaObject zwei weitere Methoden hinzugef"ugt: \emph{javaGet()} und
\emph{javaSet()}. \emph{javaGet()} erwartet analog zu Methoden zwei Argumente, den Namen des Attributes und dessen Signatur, beides als Strings, letzteres wieder
JNI-kodiert. Wie bei Methodensignaturen auch wird der Feldsignaturstring geparst, um sp"ater dem R"uckgabewert den richtigen Typen zuweisen zu k"onnen, aber auch
weil auch um ein Attribut eines Java-Objektes auszulesen die richtige JNI-Funktion aufgerufen werden muss. Diese Funktionen haben die Signatur
Get$<$Type$>$Field, und erwarten alle das Objekt dessen Attribut ausgelesen werden soll, sowie eine sogenannte \emph{jfieldID}, die zuvor mittels der Funktion
\emph{GetFieldID} generiert werden muss. Wie bei Methodenaufrufen der R"uckgabewert wird hier der Wert des Attributes in einem jvalue gespeichert, der wieder
in einen zval umgewandelt wird. \emph{javaSet()} erwartet neben den Argumenten die auch \emph{javaGet()} erwartet noch den Wert auf den das Attribut gesetzt werden
soll, daf"ur gibt diese Methode nat"urlich keinen Wert zur"uck. Auch \emph{javaSet()} entscheidet anhand der Signatur welche JNI-Funktion zum Setzen des
Attributes aufgerufen werden soll, welche die Signatur Set$<$Type$>$Field haben, und versucht ebenfalls anhand des "ubergebenen Attributnamens und -Signatur die
entsprechende jfieldID zu finden.

Nachdem man nun Klassen konstruieren, deren Methoden aufrufen und auf deren Attribute zugreiffen konnte wurden die M"oglichkeiten der Fehlerbehandlung
verbessert. Java arbeitet haupts"achlich mit Exceptions, und auch die Turpitude-intern erzeugten Fehler treten in der JVM als Exceptions auf. Folglich mussten dem
Anwender Werkzeuge zur Hand gegeben werden, geworfene Exceptions in PHP zu fangen und zu behandeln, und selbst Java-Exceptions zu erzeugen. Das Werfen von
Exceptions kann der Anwender mittels der Methoden \emph{throw} und \emph{throwNew} des TurpitudeEnvironment bewerkstelligen. Mit \emph{throw} k"onnen Instanzen
der Klasse \emph{java.lang.Throwable} geworfen werden, die der Anwender zuvor wie oben beschrieben erzeugt hat. \emph{throwNew} hingegen erwartet zwei Parameter,
zum einen den Namen der zu werfenden Exception, zum anderen die Nachricht, die die Exception enthalten soll. Will der Anwender also komplizierte Exceptions mit
werfen, die zus"atzlich zur eigentlichen Nachricht noch zus"atzlich Information tragen soll wird er \emph{throw} nutzen, f"ur den gro\ss teil der F"alle 
hingegen reicht \emph{throwNew} v"ollig aus. Um Exceptions auch fangen zu k"onnen wurde die Methode \emph{exceptionOccurred} eingef"uhrt, die die gleichnamige
JNI-Funktion aufruft, und die zuletzt geworfene und noch nicht gefangene Exception zur"uckgibt. Wird keine solche Exception gefunden wird NULL zur"uckgegeben,
derart gefundene Exceptions verbleiben allerdings in diesem Status. Um erfolgreich behandelte Exceptions aus diesem Zustand zu entfernen wurde die Methode
\emph{exceptionClear} implementiert, die ebenfalls keine Parameter entgegennimmt, und ebenfalls die gleichnamige JNI-Funktion aufruft.
Schlussendlich wurde dem TurpitudeEnvironment noch die Methode \emph{instanceOf} hinzugef"ugt die den Java-Operator \emph{instanceof} nachbildet.
Diese Methode erwartet zwei Argumente, zum einen das zu testende Objekt, und zum anderen die Klasse von der der Anwender wissen will ob das Objekt eine Instanz
dieser ist.

Alle hier beschriebenen Methoden erzeugen PHP-Laufzeitfehler sollte beispielsweise die Anzahl der "ubergebenen Argumente nicht stimmen, oder falschen Types sein.
Wichtig ist noch zu bemerken, dass sowohl das Aufrufen von Java-Methoden, als auch das lesen beziehungsweise schreiben von Attributen auch auf nicht-"offentlichen
Methoden und Attributen funktioniert, einerseits da JNI keinerlei M"oglichkeiten bietet Zugriffsmodifikatoren zu erkennen, andererseits da man eigentlich davon
ausgehen k"onnen sollte, dass ein Anwender wenigstens in groben Z"ugen weiss was er tut. 

Mit der geleisteten Vorarbeit war es nun einfach die Anforderungen des JSR nach einem ScripContext umzusetzen. Die von der PHPScriptEngine erweiterte Klasse
AbstactScriptEngine bringt eine Kontextimplementation namens SimpleContext mit. Dieser Kontext wird beim Aufruf der nativen Methode \emph{exec} des PHPCompiledScripts
als jobject "ubergeben und global gespeichert. An diesen Kontext kommt der Anwender in PHP "uber die Methode \emph{getScriptContext} des TurpitudeEnvironment. Im 
entsprechenden Handler wird die Klasse des ScripContext ermittelt, damit eine TurpitudeJavaClass erstellt, und mit dem Kontext-jobject zu einer Instanz von
TurpitudeJavaObject vereinigt. Somit kann der Anwender einfach die entsprechenden Java-Methoden dieses Objektes aufrufen, um an die im Kontext enthaltenen Daten zu
gelangen. Getestet wurde das mit einem Programm das einen java.util.StringBuffer erzeugt, in den Kontext einsetzt, und dann ein PHP-Skript ausf"uhrt, das diesem
StringBuffer einen Text anh"angt. Nachdem das Skript ausgef"uhrt wurde enth"alt der StringBuffer sowohl die per Java, als auch die in PHP angeh"angten Zeichen.

TODO: Invocable

% ********** End of chapter **********
