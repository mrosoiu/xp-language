% ********** Appendix 1 **********
\subsection{Skriptdateien ausf"uhren}
\label{sec:app1:execute}

Wie sich in \ref{sec:app1:hello} gezeigt hat erweist es sich als umst"andlich PHP-Quelltext
in einem Java-Programm einzubetten. Alternativ kann das Skript sich auch in einer Datei befinden,
was den zus"atzlichen Vorteil bringt nicht jedes Mal die Java-Klasse neu "ubersetzen zu m"ussen 
wenn sich das Skript "aendert.

Hierzu muss ein \emph{java.io.Reader} erzeugt werden, aus welchem das Skript geladen werden kann:
\begin{lstlisting}[caption=Laden eines Skriptes aus einer Datei]
FileReader r = new FileReader(filename);
\end{lstlisting}
Diesen Reader kann man nun der ScriptEngine "ubergeben:
\begin{lstlisting}[caption="Ubergabe des Readers]
Object retval = null;
try {
    retval = eng.eval(r);
} catch(PHPCompileException e) {
    System.out.println("Compile Error:");
    e.printStackTrace();
} catch(PHPEvalException e) {
    System.out.println("Eval Error:");
    e.printStackTrace();
} catch(ScriptException e) {
    System.out.println("ScriptException caught:");
    e.printStackTrace();
}
\end{lstlisting}

Hier zeigen sich gleich zwei Besonderheiten die es bei der Benutzung von Turpitude zu beachten
gilt: Neben der vom JSR223-Standard beschriebenen \emph{ScriptException} wirft Turpitude noch 
\emph{PHPCompileException}s und \emph{PHPEvalException}s, was es dem Anwender erlaubt 
zwischen "Ubersetzungs- und Laufzeitfehlern zu unterscheiden.
Ausserdem k"onnen PHP-Skripte einfach mittels "'return"' Werte zur"uckgeben, welche dann in Java
entweder als skalare Typen, oder aber als Instanzen der Klasse \emph{PHPObject} repr"asentiert
werden. Ein PHPObject enth"alt eine \emph{java.util.HashMap} die alle Attribute des PHP-Objektes
unter dem jeweiligen Namen gespeichert hat.

Der Quelltext dieses Programmes befindet sich in der Datei \emph{ScriptExec.java}, und kann
mittels des Befehls \emph{make exec} ausgef"uhrt werden.

% ********** End of appendix **********
