\section{EJB 3.0}
\label{sec:chap2:ejb3}

Obwohl innerhalb der Firma - im Gegensatz zu EJB 2.0 - nur sehr wenig Erfahrung mit der Enterprise Java Bean Specification in der
neuesten Version 3.0 (siehe \cite{EJBHP}) vorhanden war, wurde beschlossen das Projekt unter Einsatz dieser durchzuf"uhren. 
Diese Entscheidung fiel nicht nur um Erfahrungen mit dieser neuen Technologie zu sammeln, sonder auch um das Projekt zukunftssicherer 
zu machen.
Aus diesem Grund sollem an dieser Stelle kurz die Unterschiede zwischen EJB 2.0 und 3.0 umrissen werden, es wird dabei
davon ausgegangen, dass der Leser mit den Programmierkonzepten von EJB 2.0 zumindest im Groben vertraut ist.

Die fr"uheren J2EE 1.4 and EJB 2.1 Spezifikationen sind sehr komplex, Entwickler mussten sich mit dem EJB-Komponentenmodell,
verschiedenen APIs und Entwurfsmustern sowie XML Metainformationsdateien vertraut machen bevor sie auch nur anfangen konnten
benutzbare Softwaresysteme zu entwickeln. Diese Komplexit"at verhinderte nicht nur die schnelle Adaption von J2EE,
sondern f"uhrte auch dazu dass J2EE oft falsch eingesetzt wurde, was wiederum schlechtere anstatt bessere Software zur Folge hatte.
Man erkannte dass das urspr"unglich vorrangige Ziel von EJB - die Gew"ahrleistung transaktioneller Integrit"at "uber verteilte 
Applikationen hinweg - von "'Enterprise Applications"' gar nicht ben"otigt wurde.
Die EJB 3.0 Spezifikation versucht nun sich diesem Komplexit"atsproblem anzunehmen, und aus den Erfahrungen lange eingesetzter
und erfolgreicher Opensource Projekte wie beispielsweise \emph{Hibernate} \cite{HIBERNATEHP} und \emph{XDoclet} \cite{XDOCLETHP}
zu lernen. Sie basiert auf Java-Annotationen und POJOs (Plain Old Java Objects), und ist sehr viel leichter zu Verstehen als
fr"uhere Versionen, ohne jedoch an M"achtigkeit einzub"ussen.

Mit Java Annotationen (siehe \cite{JAVAANNOTATIONS}) wurde Java erstmals in der Version 5 mit der M"oglichkeit ausgestattet 
den Quelltext mit Metadaten zu versehen.
Durch die Verwendung von Annotationen wird in EJB 3.0 zum einen die Anzahl von ben"otigten Klassen und Interfaces reduziert,
und zum anderen werden so Deployment Deskriptoren weitestgehend unn"otig, da f"ur Konfigurationsparameter nun sinnvolle Wertebelegungen
angenommen werden, und davon abweichende Werte durch Annotationen direkt im Quelltext der Java-Klassen untergebracht werden.
Weiterhin werden Annotationen verwendet um Abh"angigkeiten zur Umgebung und JNDI-Zugriffe zu spezifizieren und durch
Dependecy Injection (siehe \cite{DEPINJ}) automatisch aufzul"osen.
Ausserdem wurde die Notwendigkeit abgeschafft von EJB-spezifischen Interfaces zu erben oder diese zu implementieren, Session Beans
ben"otigen kein Home-Interface mehr, Entity Beans sind nun einfach Java-Klassen (POJOs), um Persistenzeigenschaften zu realisieren
verwendet man die neue \emph{Java Persistence Architecture}, welche bessere M"oglichkeiten zur Abfrage, f"ur Mengenoperationen und
Vererbung bietet. Die Implementierung von in fr"uheren Standards vorgeschriebenen Lebenszyklus-Callbackmethoden ist jetzt optional.
Ein weiteres Merkmal von EJB 3.0 sind die sogenannten "'Interceptors"'. Hierbei handelt es sich um Methoden oder Klassen die mittels
Annotationen an Session- und Message Driven Beans und an deren Methoden angeh"angt werden k"onnen. Sobald das annotierte Element 
(englisch "'target"') aufgerufen wird ruft der Application Server automatisch den angeh"angten Interceptor auf.




