\section{Message Driven Beans}
\label{sec:chap2:mdb}

Eine Message Driven Beans ist eine EJB die kein eigentliches Service-Interface implementiert,
und deren Methoden somit nicht direkt aufgerufen werden k"onnen. Vielmehr "'h"ort"' sie auf
Nachrichten in einer JMS Message Queue und bearbeitet diese.  JMS - der Java Messaging Service - 
ist ein Teil des Application Servers, und erlaubt das Senden von Nachrichten (Messages) in
Queues, an welche sich Dienste anh"angen k"onnen um auf diese Nachrichten zu reagieren,
auf diese Art und Weise wird die Realisierung asynchroner Abl"aufe m"oglich.
In fr"uheren EJB Versionen mussten diese Queues umst"andlich "uber XML-Dateien konfiguriert werden,
mit EJB 3.0 werden sie dynamisch erzeugt sobald ein Zuh"orer sich an eine Queue h"angt, oder
sobald ein Sender eine Nachricht in eine Queue schickt. Das Entwickeln einer Message Driven Bean 
gestaltet sich denkbar einfach, es muss lediglich das Interface \texttt{MessageListener} implementiert
werden, welches eine einzige Methode \texttt{onMessage()} definiert.

\subsection{Implementierung}
\label{sec:chap2:mdb:impl}

Die Implementierung der Message Driven Bean bereitete keine grossen Probleme, es musste lediglich
darauf geachtet werden, dass alle Laufzeitfehler die in der \texttt{onMessage()}-Methode auftreten
abgefangen und behandelt werden, da sie aufgrund der asynchronen Natur des Aufrufes nicht an den 
Client weitergereicht werden k"onnen. Die Bean muss mit \texttt{@MessageDriven} annotiert werden.
Diese Annotation kann weiterhin konfiguriert werden, zum einen mit dem Property \texttt{"'destinationType"'}, 
das den Typ der Queue angibt, auf der die Bean h"oren soll, zum anderen mit dem Property \texttt{"'destination"'},
das den Namen der Queue enth"alt.
\begin{lstlisting}[caption=Konfiguration der Message Driven Bean]
@MessageDriven(activationConfig = {
    @ActivationConfigProperty(
        propertyName="destinationType", 
        propertyValue="javax.jms.Queue"),
    @ActivationConfigProperty(
        propertyName="destination", 
        propertyValue="queue/mdb")
    })
public class MDHelloWorld implements MessageListener {
    public void onMessage(Message msg) {
...
\end{lstlisting}
Der PHP-Teil der Implementierung unterscheidet sich kaum von dem der Stateless Session Bean, wieder wird
die PHP-Klasse mittels einer Helper-Funktion instantiiert, weil es aber diesmal kein Service-Interface gibt
wird die entsprechende Methode der PHP-Klasse von Java aus mit der \texttt{invokeMethod()}-Methode des
\texttt{Invocable} Interfaces aufgerufen.
Allerdings ist der Aufruf einer Message Driven Bean f"ur den Client etwas kompliziertes als bei den
vorangegangenen Beanarten, es muss eine JMS-Nachricht erstellt und an die richtige Queue verschickt werden.
Hierzu zun"achst die Queue im Kontext nachgeschlagen werden und eine QueueConnection erstellt werden, mit der
dann eine QueueSession erzeugt werden kann. Mit Hilfe dieser Session wird ein Sender erstellt, der dann
endlich die Nachticht - in diesem Fall eine einfache TextMessage - an die Queue schicken kann. Sobald die Session
nicht mehr gebraucht wird sollte sie geschlossen werden, um sicherzustellen dass etwaige noch gecachte Nachrichten
auch wirklich verschickt werden.
\begin{lstlisting}[caption=Senden einer JMS-Nachricht]
Queue queue = (Queue)ctx.lookup("queue/mdb");
QueueConnectionFactory factory = 
    (QueueConnectionFactory)ctx.lookup("ConnectionFactory");
QueueConnection cnn = factory.createQueueConnection();
QueueSession sess = 
    cnn.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);
TextMessage msg = sess.createTextMessage("TestClient");
QueueSender sender = sess.createSender(queue);
sender.send(msg);
sess.close();
\end{lstlisting}


