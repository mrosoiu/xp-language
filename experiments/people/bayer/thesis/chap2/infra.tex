\section{Infrastruktur}
\label{sec:chap2:infra}

Bevor mit der Bearbeitung der Aufgabe begonnen werden konnte musste zun"achst die n"otige Infrastruktur
geschaffen werden, allem voran die Auswahl des zu verwendenden Application Servers.
Da bei 1\&1 ausschlie\ss lich der Application Server JBoss \cite{JBOSSHP} eingesetzt wird, war der Einsatz
dieses Application Servers eine Vorgabe.
Folglich wurde ein JBoss in der Version 4.0.5 installiert, wobei darauf zu achten war dass der
nicht standardm"a\ss ig mitinstallierte Deployer\footnote{
Ein Deployer ist eine Softwarekomponente, die das eigentliche Ausbringen eines bestimmten Archivtyps "ubernimmt
} f"ur EJB 3.0 Applikationen zus"atzlich ausgew"ahlt wurde.
Direkt nach der Installation konnte der Application Server problemlos gestartet werden.

Nun wurde f"ur das Projekt eine Verzeichnisstruktur aufgebaut wie Sun sie f"ur EJB-Projekte vorschl"agt, mit
eigenen Unterverzeichnissen f"ur die Quelltexte (\textbf{src/}), ben"otigte Bibliotheken (\textbf{lib/}), zus"atzliche 
Deploymentdeskriptoren (\textbf{dd/}) und die beim Buildprozess erzeugten Dateien (\textbf{build/}).
Da es sich um ein reines Java-Projekt handelte wurde als Buildsystem Apache Ant \cite{ANTHP} und nicht
wie f"ur Turpitude selbst \emph{make} gew"ahlt. Ant benutzt die XML-Datei "'build.xml"' wie \emph{make} das "'Makefile"'
benutzt. Der Wurzelknoten muss \texttt{project} hei\ss en. Darunter werden die einzelnen Targets angelegt, die
wiederum andere Targets als Abh"angigkeiten haben k"onnen. Als Name f"ur das Projekt wurde "'phpejb"' gew"ahlt,
die ben"otigten Klassen liegen im Package \texttt{net.xp\_framework.phpejb}. Bevor mit der Programmierung
begonnen werden konnte mussten jedoch Targets f"ur das "Ubersetzen, Packen und Deployen der Anwendung angelegt,
sowie am Anfang der build.xml einige Konfigurationsparameter gesetzt werden.
Das "Ubersetzen geschieht im Target \texttt{compile} und bereitete keine Schwierigkeiten. Die so erzeugten
.class-Dateien werden im Target \texttt{package-ejb} in ein JAR gepackt, das den Namen \emph{phpejb.ejb3} tr"agt,
damit der JBoss erkennen kann welchen Deploymechanismus er verwenden muss. Dieses JAR wird zusammen mit 
dem Deploymentdeskriptor \textbf{application.xml} - in dem lediglich beschrieben wird welche Module enthalten sind - in
das \emph{Enterprise Archive}\footnote{
auch: EAR-Datei. Java EE packt Applikatinen in eine EAR-Datei, um sie leichter ausbringen zu k"onnen. EAR-Dateien
enthalten .JAR- und .WAR-Dateien.
} \textbf{phpejb.ear} zusammengepackt, dies geschieht im Target \texttt{assemble-app}.
Ein weiteres Target namens \texttt{deploy} kopiert dieses in das Verzeichnis in dem der JBoss die auszubringenden
Applikationen erwartet. Schlussendlich wurde noch das Target \texttt{clean}, das die w"ahrend des
Buildprozess erzeugten Dateien l"oscht, sowie das Target \texttt{all} angelegt, welches als erstes Target in der
build.xml steht und deswegen ausgef"uhrt wird wenn Ant ohne Parameter aufgerufen wird, und die n"otigen Schritte
enth"alt die zur Erzeugung der \emph{phpejb.ear} n"otig sind. Somit waren die Grundlagen f"ur die weitere
Entwicklung gelegt, und es konnte ein zwar leeres, aber dennoch valides .ear erzeugt werden.

\subsection{Beispielanwendung}
\label{sec:chap2:infra:example}

Um erste Erfahrungen mit einer EJB 3.0 Anwendung zu sammeln sollte nun ein einfacher Service entwickelt werden.
Damit diese Arbeit auch sp"ater von Nutzen ist wurde beschlossen einen Service zu schreiben der das Verhalten
der in \ref{sec:chap1:impl} vorgestellten Anwendung \texttt{EngineList} nachempfindet, und eine Liste der zur Verf"ugung 
stehenden JSR 223 Implementierungen zur"uckgibt.

Zu jedem EJB Service geh"ort ein beschreibendes Interface, das Interface f"ur diesen Service ist denkbar einfach,
es besteht aus nur einer Methode, \texttt{getList()}. Durch die Annotation \texttt{@Remote} wird angegeben, dass dieses
Interface auch von remote\footnote{
ugs. f"ur "'entfernter Objektaufruf"', im Gegensatz zu zum lokalen Aufruf
} aufgerufen werden kann.

\begin{lstlisting}[caption=Testservice Interface]
@Remote
public interface EngineList {
    public List<String> getList();
}
\end{lstlisting}

Zu diesem Interface musste nun eine implementierende Klasse geschrieben werden. Dadurch, dass der Service auch Ziel eines
entfernten Objektaufrufs sein kann, muss keine lokale Implementierung vorhanden sein, ein Remote-Bean kann sowohl lokal als auch remote
aufgerufen werden. Die simpelste EJB ist die Stateless Session Bean; die Annotation \texttt{@Stateless} gibt an
dass es sich bei dieser Bean um eine solche handelt.

\begin{lstlisting}[caption=Testservice Bean]
@Stateless
public class EngineListBean implements EngineList {
    public List<String> getList() {
    ...
    }
}
\end{lstlisting}

Eine einfache Methode zum Testen einers EJB-Service ist es, einen Client zu schreiben, der in einer anderen JVM
ausgef"uhrt wird als der Application Server. Ein solcher Test zeigt nicht nur ob der Service funktioniert,
sondern auch ob das Deployment korrekt abgelaufen ist, und ob der Service von aussen "uber JNDI aufgefunden und angesprochen
werden kann. Ein solcher JNDI-Lookup geschieht immer "uber einen Kontext, welcher die n"otigen Service-Provider
kennt. Der Lookup resultiert in einem Stub-Objekt, das Aufrufe "uber die Netzverbindung an den Application Server
weiterleitet.

\begin{lstlisting}[caption=Testservice Client]
InitialContext ctx = new InitialContext(env);
EngineList list = 
    (EngineList)ctx.lookup("phpejb/EngineListBean/remote");
List<String> lst = list.getList();
\end{lstlisting}

Der Aufruf ergab als einzige innerhalb des JBoss verf"ugbare JSR 223 Implementierung die standardm"a\ss ig in Java 6
enthaltene Javascript-Engine Rhino von Mozilla. Nun mussten der den JBoss ausf"uhrenden JVM die n"otigen Parameter
mitgegeben werden, damit Turpitude innerhalb des Application Servers verf"ugbar wird (siehe auch \ref{sec:app1:exec}). 
Hierzu wurde ein Shell-Skript geschrieben, das die ben"otigten Umgebungsvariablen (LD\_LIBRARY\_PATH, JAVA\_HOME) setzt, 
und dann das eigentliche JBoss-Startskript \emph{run.sh} mit den n"otigen Parametern ausf"uhrt. 
Danach erschien Turpitude in der Liste der verf"ugbaren ScriptEngines, und es konnte mit der eigenlichen
Aufgabe begonnen werden.

\begin{lstlisting}[caption=JBoss Startskript]
#!/bin/sh
TURP_HOME=<PFAD>
PHP_HOME=<PFAD>
export JBOSS_HOME=/home/nsn/jboss-4.0.5.GA
export JAVA_HOME=/home/nsn/jdk1.6.0
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$PHP_HOME/libs:$TURP_HOME
./run.sh --classpath=$TURP_HOME/turpitude.jar
\end{lstlisting}


