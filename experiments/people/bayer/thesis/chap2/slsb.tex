\section{Stateless Session Beans}
\label{sec:chap2:slsb}

Die einfachste Enterprise Java Bean ist die Stateless Session Bean, weshalb sie als erstes umgesetzt werden sollte.
Stateless Session Beans haben - wie der Name bereits vermuten l"ass t - keinen eigenen Zustand, sie
k"onnen also keine Informationen "uber mehrere Anfragen hinweg vorhalten.

\subsection{Interface}
\label{sec:chap2:slsb:if}
Wie f"ur jede EJB muss auch f"ur die Stateless Session Bean zun"achst ein Interface definiert werden.
Das Interface f"ur diese Beispielanwendung ist sehr einfach, es besteht lediglich aus einer einzigen
Methode, welche einen Namen als String entgegennimmt und einen String zur"uckgibt, der eine
Gru\ss botschaft enth"alt. 

\begin{lstlisting}[caption=Stateless Hello World Interface]
public interface SLHelloWorld {
    public String sayHello(String s);
}
\end{lstlisting}

\subsection{PHP-Implementierung}
\label{sec:chap2:slsb:impl}

Die Implementierung des Bean-Interfaces besteht aus zwei Teilen: zum einen dem Java-Teil, der die
\texttt{ScriptEngine} instanziiert, den PHP-Quelltext l"adt und "ubersetzt sowie die entsprechenden PHP-Funktionen
aufruft, und zum anderen den PHP-Teil, der die eigentliche Interface-Implementierung enth"alt.

\begin{lstlisting}[caption=Java-Teil]
public String sayHello(String s) {
...
    ScriptEngineManager mgr = new ScriptEngineManager();
    ScriptEngine eng = mgr.getEngineByName("turpitude");
    Compilable comp = (Compilable)eng;
    CompiledScript script = comp.compile(/* Source */);
    Invocable inv = (Invocable)script;
    SLHelloWorld hw = 
        inv.getInterface(SLHelloWorld.class);
...
    return hw.sayHello(s);
}
\end{lstlisting}

Obwohl Turpitude viele M"oglichkeiten bietet, die n"otige Funktionalit"at zu implementieren,
wurde eine sehr komplizierte Variante gew"ahlt: das Implementieren des EJB-Interfaces in
PHP, sowie das Aufrufen der PHP-Methoden "uber die Methoden des JSR 223-Interfaces \texttt{javax.script.Invocable}. 
Diese Entscheidung 
wurde vor allem vor dem Hintergrund getroffen, dass die Entwicklung einer PHP-Implementierung eines Java-Interfaces
intuitiver erscheint, als das Entwickeln von PHP-Skripten die sich an eine nicht trivial ersichtliche
Konvention halten m"ussen um vom Java-Teil aufgerufen werden zu k"onnen. Au\ss erdem ist so ein 
generischer Adapter denkbar, der beliebige Java-Interfaces auf passende PHP-Implementierungen adaptiert,
oder zumindest ein Automatismus, der aus einem gegebenen Java-Interface und einer PHP-Implementierung den 
n"otigen Java-Quelltext automatisch erzeugt.

\begin{lstlisting}[caption=PHP-Implementierung]
<?php
class SLHelloWorld {
  function sayHello($s) {
    return 'The PHP-implementation says hello to '.$s;
  }
}
?>
\end{lstlisting}

Der Aufruf des SLHelloWorld-Service unterscheidet sich nicht von dem Aufruf des EngineList-Services, siehe \ref{sec:chap2:infra:example}.

