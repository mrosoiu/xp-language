\section{"Anderungen an Turpitude}
\label{sec:chap2:turp}

Im Laufe der Entwicklung dieser Beispielanwendungen zeigten sich einige Schwachstellen in
Turpitude, die aber behoben werden konnten. Die meisten aufgetretenen Probleme r"uhrten daher,
dass innerhalb eines J2EE Application Servers besondere Bedingungen vorherrschen.
Dieses Kapitel erl"autert diese Probleme und ihre Behebung.

\subsection{finalize}
\label{sec:chap2:turp:final}

Eine Besonderheit f"ur eine Klasse wenn sie innerhalb eines Application Servers aufgerufen wird
ist, dass keine Garantie "uber die Lebenszeit und -zyklen der Instanzen gegeben wird. Ein Objekt kann
- immer entsprechend der J2EE-Spezifikation - mehrfach oder auch nur einfach benutzt werden, und
es besteht keine Kontrolle "uber die Laufzeit der ausf"uhrenden JVM.
Deswegen reichte der in der PHPScriptEngine eingebaut \emph{VMShutdown-Hook} nicht mehr aus um
den PHP-Interpreter aus dem Speicher zu entfernen und auf C-Ebene belegte Resourcen wieder
freizugeben. Java kennt zwar keine Destruktoren, aber jede Klasse erbt von \texttt{Object} die
Methode \texttt{finalize}, die jedesmal aufgerufen wird wenn das Objekt von der \emph{Garbage Collection}
aufger"aumt wird. 
Beim "Uberschreiben dieser Methode ist es angebracht einen \texttt{try-catch-finally}-Block
um die ausgef"uhrten Zeilen zu legen, und im finally-Teil \texttt{super.finalize()} aufzurufen.
Jede in \texttt{finalize} auftretende Exception unterbricht zwar das Aufr"aumen, wird ansonsten
aber ignoriert.
Folglich wurde in der \texttt{PHPScriptEngine} die Methode \texttt{finalize} "uberschrieben, und innerhalb dieser
wird \texttt{shutDown} aufgerufen.

\subsection{Mehrfachinstanziierung}
\label{sec:chap2:turp:multi}

Wird innerhalb eines Java-Threads der PHP-Interpreter mehrfach instanziiert kann es zu Problemen
kommen: Zum einen kann nicht mehr gew"ahrleistet werden, dass die Ausf"uhrung des "ubersetzten
PHP-Quelltextes fehlerfrei abl"auft, da unter Umst"anden w"ahrend der Ausf"uhrung die sogenannten
\emph{Executor Globals} (Skriptvariablen, Aufrufstacks und die Zend-Opcodes selbst) ver"andert werden,
und zum anderen kann der mehrfache Aufruf der \texttt{startUp()}-Methode, in der der PHP-Interpreter
initialisiert wird, zu schweren Fehlern bis hin zu Abst"urzen der JVM f"uhren. Um dies zu verhindern
wurde die PHPScriptEngineFactory derart angepasst, dass sie eine abge"anderte Version des Singleton-Patterns
implementiert um zu verhindern, dass mehrere \texttt{PHPScriptEngines} gleichzeitig existieren. 
Da der Konstruktor der PHPScriptEngine als \texttt{protected} deklariert wurde, kann angenommen werden dass die 
Methode \texttt{getScriptEngine()} der PHPScriptEngineFactory die einzige Stelle ist, an der
ScriptEngine-Instanzen erzeugt werden. So wurde der Factory ein privates und statisches Attribut \texttt{MyEngine} 
hinzugef"ugt, welches die Singleton-Instanz der PHPScriptEngine vorh"alt. Dieses Attribut ist zu Begin
\texttt{null}, und wird beim ersten Aufruf von \texttt{getScriptEngine()} gesetzt, jeder weitere Aufruf
dieser Methode gibt nur noch eine Referenz auf diese einzige ScriptEngine zur"uck. Das Erzeugen des
Singletons wird zus"atzlich durch einen \texttt{synchronized}-Block vor gleichzeitiger
Mehrfachausf"uhrung gesch"utzt.

\begin{lstlisting}[caption=Singleton-Erzeugung]
public ScriptEngine getScriptEngine() {
    if (MyEngine == null) {
        synchronized (PHPScriptEngineFactory.class) {
            if (MyEngine == null)
                MyEngine = new PHPScriptEngine(this);
        }
    }
    return MyEngine;
}
\end{lstlisting}

\subsection{Parameterlose Methodenaufrufe}
\label{sec:chap2:turp:params}

Ein besonders hartn"ackiger und schwer zu findender Fehler f"uhrte zu Abst"urzen der JVM beim Aufrufen
parameterloser Methoden "uber Java-Interfaces, die mittels \texttt{Invocable.getInterface} erzeugt wurden.
Obwohl die InvocationHandler-Methode \texttt{invoke} genau wie die Methoden \texttt{invokeMethod} und \texttt{invokeFunction}
die Methodenparameter mittels der Signatur \texttt{Object... args} "ubergibt, ist \texttt{args} f"ur parameterlose Methoden
bei \texttt{invoke} null, w"ahrend bei \texttt{invokeMethod} und \texttt{invokeFunction} in diesem Fall ein leeres Array 
"ubergeben wird. Die vom nativen Code aufgerufene JNI-Funktion \texttt{GetArrayLength} f"uhrt zu einem Absturz der
JVM wenn ihr ein Nullpointer "ubergeben wird. Um dies zu verhindern wurde in der \texttt{invoke()}-Methode des
\texttt{PHPInvocationHandler}s ein Test eingef"uhrt, ob das Parameterarray \texttt{null} ist. In diesem Fall wird einfach
ein leeres Object-Array erzeugt, und an den nativen Code "ubergeben. So werden Abst"urze der JVM vermieden. 

\subsection{Garbage Collection}
\label{sec:chap2:turp:zendgc}

Anders als bei den Testanwendungen aus Kapitel \ref{sec:chap1} in denen die JVM und der in ihr eingebettete PHP-Interpreter
nur sehr kurz laufen, muss innerhalb eines Application Servers darauf geachtet werden, dass reservierter Speicher
wieder freigegeben wird wenn er nicht mehr ben"otigt wird. Java-Anwendungen k"onnen hierbei auf die Java Garbage Collection
vertrauen, allerdings besteht Turpitude zu einem Gro\ss teil aus nativem Code. Da bei der Entwicklung der Bibliothek schon
auf eine saubere Speicherverwaltung geachtet wurde traten im Turpitude-Code selbst keine Speicherlecks auf, und es ist
davon auszugehen, dass auch der PHP-Interpreter weitestgehend frei von solchen Fehlern ist. Allerdings verbrauchen auch
die PHP-Skripte selbst Speicher. Um PHP-Programmierer von der Speicherverwaltung zu befreien enth"alt die Zend-Engine 
eine eigene Garbage Collection, und jeder \emph{zval} hat ein Attribut \texttt{refcount}, welches die Anzahl der auf ihn gehaltenen
Referenzen angibt. In regelm"a\ss igen Abst"anden wird f"ur jeden \texttt{zval} "uberpr"uft, ob noch Referenzen auf ihn vorhanden sind.
Ist dies nicht der Fall wird er zerst"ort und der von ihm belegte Speicher somit wieder freigegeben.
Jeder von Turpitude als PHPObject an die Java-Applikation weitergegebene \texttt{zval}-Pointer z"ahlt ebenfalls als Referenz.
Wird das PHPObject von der Java Garbage Collection aufger"aumt muss daf"ur gesorgt werden, dass der
PHP-Referenzz"ahler wieder um eins dekrementiert wird.
Hierzu wurde dem PHPObject ebenfalls eine \texttt{finalize()}-Methode hinzugef"ugt. In dieser wird die ebenfalls neue,
native Methode \texttt{destroy()} aufgerufen, in der schlie\ss lich der im ByteBuffer gespeicherte \texttt{zval}-Pointer
ausgelesen, und dessen Referenzz"ahler herabgesetzt wird.



