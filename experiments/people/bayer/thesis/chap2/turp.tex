\section{"Anderungen an Turpitude}
\label{sec:chap2:turp}

Im Laufe der Entwicklung dieser Beispielanwendungen zeigten sich einige Schwachstellen in
Turpitude, die aber behoben werden konnten. Die meisten aufgetretenen Probleme r"uhrten daher,
dass innerhalb eines J2EE Application Servers besondere Bedingungen vorherrschen.
Dieser Abschnitt soll diese Probleme und ihre Behebung erl"autern.

\subsection{finalize}
\label{sec:chap2:turp:final}

Eine Besonderheit f"ur eine Klasse wenn sie innerhalb eines Application Servers aufgerufen wird
ist, dass keine Garantie "uber die Lebenszeit und -Zyklen der Instanzen gegeben wird, ein Objekt kann
- immer entsprechend der J2EE-Spezifikation - mehrfach oder auch nur einfach benutzt werden, und
es besteht keine Kontrolle "uber die Laufzeit der ausf"uhrenden JVM.
Deswegen reichte der in der PHPScriptEngine eingebaut \emph{VMShutdown-Hook} nicht mehr aus um
den PHP-Interpreter aus dem Speicher zu entfernen und auf C-Ebene belegte Resourcen wieder
freizugeben. Java kennt zwar keine Destruktoren, aber jede Klasse erbt von \emph{Object} die
Methode \emph{finalize}, die jedesmal aufgerufen wird wenn das Objekt von der \emph{Garbage Collection}
aufger"aumt wird. 
Beim "uberschreiben dieser Methode ist es angebracht einen \emph{try-catch-finally}-Block
um die ausgef"uhrten Zeilen zu legen, und im finally-Teil \emph{super.finalize()} aufzurufen.
Jede in \emph{finalize} auftretende Exception unterbricht zwar das aufr"aumen, wird ansonsten
aber ignoriert.
Folglich wurde in der PHPScriptEngine die Methode finalize "uberschrieben, und innerhalb dieser
Methode wird \emph{shutDown} aufgerufen.

\subsection{Mehrfachinstanziierung}
\label{sec:chap2:turp:multi}

Wird innerhalb eines Java-Threads der PHP-Interpreter mehrfach instanziiert kann es zu Problemen
kommen: zum einen kann nicht mehr gew"ahrleistet werden dass die Ausf"uhrung des "ubersetzten
PHP-Quelltextes Fehlerfrei abl"auft, da unter Umst"anden w"ahrend der Ausf"uhrung die sogenannten
\emph{Executor Globals} (Skriptvariablen, Aufrufstacks und die Zend-Opcodes selbst) ver"andert werden,
und zum anderen kann der mehrfache Aufruf der \emph{startUp()}-Methode, in der der PHP-Interpreter
initialisiert wird, zu schweren Fehlern bis hin zu Abst"urzen der JVM f"uhren. Um dies zu verhindern
wurde die PHPScriptEngineFactory derart angepasst, dass sie eine abge"anderte Version Singleton-Patterns
implementiert um zu verhindern dass mehrere PHPScriptEngines gleichzeitig existieren. 
Da der Konstruktor der PHPScriptEngine \emph{protected} ist kann angenommen werden dass die 
Methode \emph{getScriptEngine()} der PHPScriptEngineFactory die einzige Stelle ist, an der
ScriptEngine-Instanzen erzeugt werden. So wurde der Factory ein privates, statisches Attribut \emph{MyEngine} 
hinzugef"ugt, welches die Singleton-Instanz der PHPScriptEngine vorh"alt. Dieses Attribut ist zu Begin
\emph{NULL}, und wird beim ersten Aufruf von \emph{getScriptEngine()} gesetzt, jeder weitere Aufruf
dieser Methode gibt nur noch eine Referenz auf diese einzige ScriptEngine zur"uck. Das Erzeugen des
Singletons wird zus"atzlich durch einen \emph{synchronized}-Bl"ock vor gleichzeitiger
Mehrfachausf"uhrung gesch"utzt.
\begin{lstlisting}[caption=Singleton-Erzeugung]
public ScriptEngine getScriptEngine() {
    if (MyEngine == null) {
        synchronized (PHPScriptEngineFactory.class) {
            if (MyEngine == null)
                MyEngine = new PHPScriptEngine(this);
        }
    }
    return MyEngine;
}
\end{lstlisting}

\subsection{Parameterlose Methodenaufrufe}
\label{sec:chap2:turp:params}

Ein besonders hartn"ckiger und schwer zu findender Fehler f"uhrte zu Abst"urzen der JVM beim Aufrufen
parameterloser Methoden "uber Java-Interfaces, die mittels \emph{Invocable.getInterface} erzeugt wurden.
Obwohl die InvocationHandler-Methode \emph{invoke} genau wie die Methoden \emph{invokeMethod} und \emph{invokeFunction}
die Methodenparameter mittels der Signatur \emph{Object... args} "ubergeben, ist args bei parameterlosen Methoden
bei \emph{invoke} null, w"ahrend bei \emph{invokeMethod} und \emph{invokeFunction} in diesem Fall ein leeres Array 
"ubergeben wird. Die vom nativen Code aufgerufene JNI-Funktion \emph{GetArrayLength} f"uhrt zu einem Absturz der
JVM wenn ihr ein Nullpointer "ubergeben wird. Um dies zu verhindern wurde in der \emph{invoke()}-Methode des
\emph{PHPInvocationHandler}s ein Test eingef"uhrt, ob das Parameterarray null ist. In diesem Fall wird einfach
ein leeres Object-Array erzeugt und dieses an den nativen Code "ubergeben.

\subsection{Garbage Collection}
\label{sec:chap2:turp:zendgc}

Anders als bei den Testanwendungen aus Kapitel \ref{sec:chap1} in denen die JVM und der in ihr eingebettete PHP-Interpreter
nur sehr kurz laufen muss innerhalb eines Application Servers darauf geachtet werden, dass reservierter Speicher
wieder freigegeben wird wenn er nichtmehr ben"otigt wird. Java-Anwendungen k"onnen hierbei auf die Java Garbage Collection
vertrauen, allerdings besteht Turpitude zu einem Gro\ss teil aus nativem Code. Da bei der Entwicklung der Bibliothek schon
auf eine saubere Speicherverwaltung geachtet wurde trate in Turpitude-Code selbst keine Speicherlecks auf, und es ist
davon auszugehen dass auch der PHP-Interpreter weitestgehend frei von solchen Fehlern ist, allerdings verbrauchen auch
die PHP-Skripte selbst Speicher. Um PHP-Programmierer von der Speicherverwaltung fern zu halten enth"alt die Zend-Engine 
eine eigene Garbage Collection, und jeder zval hat ein Attribut \emph{refcount}, welches die Anzahl der auf ihn gehaltenen
Referenzen angibt. In Regelm"a\ss igen Abst"anden wird f"ur jeden zval "uberpr"uft, ob noch Referenzen auf ihn vorhanden sind,
und ist dies nicht der Fall wird er zerst"ort und der von ihm belegte Speicher somit wieder freigegeben.
Jeder von Turpitude als PHPObject an die Java-Applikation weitergegebene zval-Pointer z"ahlt ebenfalls als Referenz,
und wird nun das PHPObject von der Java Garbage Collection aufger"aumt muss daf"ur gesorgt werden, dass der
Referenzz"ahler wieder um eins herabgesetzt wird.
Hierzu wurde dem PHPObject ebenfalls eine \emph{finalize()}-Methode hinzugef"ugt, und in dieser wird die ebenfalls neue,
native Methode \emph{destroy()} aufgerufen, in der schlie\ss lich der im ByteBuffer gespeicherte zval-Pointer
ausgelesen, und dessen Referenzz"ahler herabgesetzt wird.



