\section{Fazit}
\label{sec:chap2:fazit}

In diesem Kapitel wurden zun"achst die Unterschiede zwischen EJB 3.0 und fr"uheren Versionen er"ortert, was
das Entwickeln einer Beispielanwendung erlaubte. Hierbei zeigten sich die immensen Vorteile die EJB 3.0 gegen"uber
EJB 2.0 bietet, allen voran die Tatsache dass wenig bis gar keine externe Konfiguration der Applikationen erfolgen
muss, zumindest um eine funktionierende Anwendung zu erhalten. Dies spart nicht nur erheblich Entwicklungszeit,
sondern entbindet den Entwickler auch von implementationsspezifischem Wissen "uber Stuktur und Inhalt diverser
Konfigurationsdateien. Die Entscheidung EJB 3.0 zu benutzen wurde in keinster Weise bereut.

Nachdem es gelungen war den JBoss, wie in \ref{sec:chap2:infra:example} beschrieben, so zu konfigurieren dass
die PHP-Implementierung f"ur alle in ihm deployten Dienste verf"ugbar war, war das eigentliche Entwickeln der
Enterprise Java Beans unerwartet einfach, und beanspruchte weniger Zeit als zuvor gedacht. Diese Zeitersparnis
wurde allerdings leider von den n"otigen "Anderungen an Turpitude wieder aufgebraucht, andererseits war
es ja auch ausdr"ucklich Ziel dieses Kapitels solche Fehler in der Bibliothek zu finden und zu beheben.

Ein weiteres Problem das auftrat und dessen analyse sehr viel Zeit verschlang war ein Fehler in der benutzten JBoss-Version, 
der auftritt wenn man diese in einer Java 6 VM ausf"uhrt:
Um Daten zwischen Client und Server zu "ubertragen serialisiert JBoss die zu "ubertragenden Objekte. Diese
werden dann deserialisiert, und auf der anderen Seite mittels der Methode \emph{loadClass()} des Klassenladers.
Entgegen der Java Language Specification funktionierte diese Methode bis einschliesslich Java 5 auch mit Objektarrays,
dies wurde aber mit Version 6 behoben. Da aber JBoss 4.0.5 diese Methode um Zusammenhang mit Objektarrays noch benutzt
musste w"ahrend der Entwicklung auf den JBoss in der neuesten Version 5 umgestiegen werden, obwohl sich dieser noch
in einem Betastatus befand.

Alles in allem hat sich allerdings gezeigt dass Turpitude durchaus geeignet ist um es im geforderten Kontext
einzusetzen. Es traten - abgesehen von den in \ref{sec:chap2:turp} beschriebenen Fehlern - keine gr"o\ss eren Probleme
auf, und es konnten die geforderten Enterprise Java Beans mit ihrem vollen Funktionsumfang realisiert werden.
Auf eine Implementierung von Entity Beans wurde absichtlich verzichtet, zum einen wegen der neuen Java Persistance Api,
und zum anderen weil es einfach wenig Sinn ergibt dass eine Java-Applikation die Persistierung von Daten in ein
PHP-Skript auslagert, welches dann v"ollig an den Konventionen eines Application Servers vorbei Verbindungen zu Datenbankservern
"offnet oder Dateien manipuliert.
Auch auf den Aspekt einer m"oglichen Automatisierung des Deployments und des Erstellens des n"otigen Java-Quelltextes
wurde eingegangen, und es wurden m"ogliche Ans"atze zur Erf"ullung dieser Anforderungen aufgezeigt.

