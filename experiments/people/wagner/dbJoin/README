dba classmapping experiment
========================================================================
$Id$

==========================
extends class generator
extends experiment dbConstraints
extends experiment dbProjection
extends experiment dbProxy


==========================

Restrictions:

This Join API is to join over tables by constraints only.
So, the database has to be prepared.

When joins are used, projections will be ignored.


==========================

You can do joins by the names of relations, which are defined by the naming
strategy (see experiment "dbConstraints") for that.
A criteria defined like this
  
  Criteria::newInstance()->setFetchMode(Fetchmode::join('ColorColortype.TextureColor'));

would create a query like 

  SELECT
    t0.colortype_id as t0_colortype_id,
    t0.name as t0_name,
    t1.color_id as t1_color_id,
    t1.name as t1_name,
    t1.colortype_id as t1_colortype_id,
    t2.texture_id as t2_texture_id,
    t2.name as t2_name,
    t2.color_id as t2_color_id
  FROM
    Ruben_Test_PS.colortype as t0
    LEFT OUTER JOIN Ruben_Test_PS.color as t1 ON (t0.colortype_id = t1.colortype_id)
    LEFT JOIN Ruben_Test_PS.texture as t2 ON (t1.color_id = t2.color_id)

The queries are dialect dependant, the same criteria used for a
sybase dataset would produce a query like

  SELECT
    t0.colortype_id as t0_colortype_id,
    t0.name as t0_name,
    t1.color_id as t1_color_id,
    t1.name as t1_name,
    t1.colortype_id as t1_colortype_id,
    t2.texture_id as t2_texture_id,
    t2.name as t2_name,
    t2.color_id as t2_color_id
  FROM
    Ruben_Test_PS.colortype as t0,
    Ruben_Test_PS.color as t1,
    Ruben_Test_PS.texture as t2
  WHERE
     t0.colortype_id *= t1.colortype_id
     AND t1.color_id *= t2.color_id



After the query is fired the data of the single objects are collected and the objects
are built and linked together.

You can access the objects like showen in this example. the accessors are the same
like in the "dbConstraints" example. Of course you can not get a real iterator for
sub objects.

  $crit= Criteria::newInstance()->setFetchMode(Fetchmode::join('Color.Colortype'));
  foreach (RubentestTexture::getPeer()->doSelect($crit) as $RubentestTexture) {
    Console::writeLine('==> '.xp::stringOf($RubentestTexture));
    Console::writeLine('====> '.xp::stringOf($RubentestTexture->getColor()));
    Console::writeLine('======> '.xp::stringOf($RubentestTexture->getColor()->getColortype()));
  }



The iterator does work like for simple queries.

  $crit= Criteria::newInstance()
    ->setFetchMode(Fetchmode::join('Author'))
  ;
  $it= Mmessage::getPeer()->iteratorFor($crit);
  while ($it->hasNext()) Console::writeLine(xp::stringOf($it->next()));



If you fetch an iterator for a subobject like in the following example, you will
receive a HashmapIterator over the prebuild object list. This method is just for
style reason there is no memory advantage.

  $crit= Criteria::newInstance()
    ->setFetchMode(Fetchmode::join('Author'))
    ->setFetchMode(Fetchmode::join('Recipient.MmessageAuthor'))
  ;
  $it= Mmessage::getPeer()->iteratorFor($crit);

  while ($it->hasNext()) {
    $ele= $it->next();
    Console::writeLine('==> '.xp::stringOf($ele));
    Console::writeLine('Author =====> '.xp::stringOf($ele->getAuthor()));
    Console::writeLine('Recipient ==> '.xp::stringOf($ele->getRecipient()));
    $authIt= $ele->getRecipient()->getMmessageAuthorIterator();
    while ($authIt->hasNext()) {
      Console::writeLine('Author of ==> '.xp::stringOf($authIt->next()));
    }
    Console::writeLine('=====================================================================================');
  }



Trying to join over an undefined constraint would throw an IllegalArgumentException.

  $crit= Criteria::newInstance()->setFetchMode(Fetchmode::join('RubentestBla'));
  "Exception lang.IllegalArgumentException (RubentestBla: no such role for RubentestColortype - try one of ColorColortype)"

<EOF>
