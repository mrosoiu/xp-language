
Reflection
==========
The XP framework offers its own reflection API.

Classes
-------
The most common entry point is the [class://lang.XPClass XPClass] class.
Instances of it can be retrieved by either using its static <tt>forName()</tt>
method or by calling the instance method <tt>getClass()</tt> on any object.

<code>
  $class= XPClass::forName('util.collections.HashTable');
  $class= create(new HashTable())->getClass();
</code>

<em>Hint: To retrieve an object's class name, you can either use
<tt>$object->getClass()->getName()</tt> or the shortcut <tt>$object->getClassName()</tt>.
The latter is not only shorter but also significantly faster!</em>

With the <tt>XPClass</tt> instance in the <tt>$class</tt> variable, one has
access to all features of a class:

<summary>
Methods
~~~~~~~
Via <tt>getMethods()</tt>, <tt>getMethod()</tt> and <tt>hasMethod()</tt> 
accessors.

<code>
  $method= $class->getMethod('toString');
</code>

The returned [class://lang.reflect.Method Method] instance offers access
to:
<ul>
  <li>*Parameters* - via <tt>getParameters()</tt></li>
  <li>*Return type* - via <tt>getReturnType()</tt></li>
  <li>*Thrown exceptions* - via <tt>getExceptionTypes()</tt></li>
  <li>*Annotations* - via <tt>getAnnotations()</tt></li>
  <li>*Modifiers* - via <tt>getModifiers()</tt></li>
</ul>
...and provides means to invoke the method:

<code>
  with ($class= XPClass::forName('util.log.Logger')); {
    $log= $class->getMethod('getInstance')->invoke(NULL);   // Static
    $str= $class->getMethod('toString')->invoke($log);      // Instance
  }
</code>

</summary>

<summary>
Constructor
~~~~~~~~~~~
Via <tt>getConstructor()</tt> and <tt>hasConstructor()</tt> accessors.

<code>
  $constructor= $class->getConstructor();
</code>

The returned [class://lang.reflect.Constructor Constructor] instance offers access
to:
<ul>
  <li>*Parameters* - via <tt>getParameters()</tt></li>
  <li>*Thrown exceptions* - via <tt>getExceptionTypes()</tt></li>
  <li>*Annotations* - via <tt>getAnnotations()</tt></li>
  <li>*Modifiers* - via <tt>getModifiers()</tt></li>
</ul>
...and provides means to invoke it:

<code>
  with ($class= XPClass::forName('util.Binford')); {
    $binford6100= $class->getConstructor()->invoke(array(6100));
  }
</code>

</summary>

<summary>
Fields
~~~~~~
Via <tt>getFields()</tt>, <tt>getField()</tt> and <tt>hasField()</tt> 
accessors.

<code>
  $field= $class->getField('elements');
</code>

The returned [class://lang.reflect.Field Field] instance offers access
to:
<ul>
  <li>*Type* - via <tt>getType()</tt></li>
  <li>*Modifiers* - via <tt>getModifiers()</tt></li>
</ul>
...and provides means to read its value:

<code>
  with ($class= XPClass::forName('util.Binford')); {
    $power= $class->getField('poweredBy')->get(new Binford(6100));
  }
</code>

</summary>

<summary>
Annotations
~~~~~~~~~~~
Via <tt>getAnnotations()</tt>, <tt>getAnnotation()</tt> and <tt>hasAnnotation()</tt> 
accessors.

<code>
  #[@bean(name= 'contract/history/1.0')]
  class HistoryBean extends Object {
  
  }
  
  $name= XPClass::forName('HistoryBean')->getAnnotation('bean', 'name');
</code>

<em>See also the [doc://core/annotations Annotations documentation]</em>.
</summary>


Packages
--------
Every class resides inside a package. The [class://lang.reflect.Package Package]
class offers methods to reflectively access a package. Instances of it can be
retrieved by <tt>Package::forName()</tt> or by calling the <tt>getPackage()</tt>
on an <tt>XPClass</tt> instance.

<code>
  $package= Package::forName('util.collections');
  $package= create(new HashTable())->getClass()->getPackage();
</code>

Packages are primarily used to load classes and resources:

<code>
  $package= Package::forName('de.thekid.dialog.scriptlet.state');
  $stateName= ucfirst($request->getURL()->getPath());
  
  try {
    $state= $package->loadClass($stateName.'State')->newInstance();
  } catch (ClassNotFoundException $e) {
    throw new HttpScriptletException('File not found', HTTP_NOT_FOUND, $e);
  }
</code>

The nice thing about this piece of code is that it will not let users
inject arbitrary class names but will throw an 
[class://lang.IllegalArgumentException IllegalArgumentException] in case
a class outside of the given package.

To retrieve a <tt>config.ini</tt> inside the same directory as the class
containing the sourcecode one can use the following:

<code>
  $prop= Properties::fromString($this->getClass()
    ->getPackage()
    ->getResource('config.ini')
  );
</code>

