RFC 0052: Make XP its own (compiled) language
========================================================================
$Id$

@authors: friebe
@created: Thu Jan 12 12:09:13 CET 2006
@status: draft
@category: <core>

Scope of Change
---------------
XP will become its own language, that is, PHP with syntax additions, some
of which have been described in RFC #0008. (JIT-)Compilers will be created 
to create PHP4, PHP5 and PHP6 sourcecode from the new language.


Rationale
---------
- Independence from PHP development process and its sometimes idiotic
  decisions (like having to extend built-in Exception for everything
  that should be throwable or decision to throw fatal errors in places
  it's not really required).
- PHP5/PHP6 migration
- Namespaces
- No more syntax cludges
- Rapid development


Functionality
-------------
The suggested functionality is divided into the following parts:
<pre>
1) Execution changes
2) Syntax changes
</pre>

1) Execution changes
~~~~~~~~~~~~~~~~~~~~
Scripts written in the XP language can no longer be run by PHP directly
but will require a preprocessor (the JIT-compiler):

Current:
<pre>
$ php script.php
</pre>

New:
<pre>
$ php -dauto_prepend_file=xp.php script.php
</pre>

Of course, an alias could be created, so one could type:
<pre>
$ xp script.php
</pre>

When PHP is executed from within a webserver, the auto_prepend_file could
be set by the virtual host's configuration or per directory.


2) Syntax changes
~~~~~~~~~~~~~~~~~

Namespaces
~~~~~~~~~~
Namespaces can be simulated by string operations. This has been shown
by our "The patch" [1] and by Jessie Hernandez' namespaces implementation
for PHP-CVS [2].

Class declaration in a package:
<code>
  package util·cmd {
    class Console {
      // ...
    }
  }  
</code>

Importing a class from a package:
<code>
  import util·cmd·Console;
  
  Console::writeLine('Hello');
</code>

What happens technically:
Names are resolved at compile time and prefixed by their namespace.


For PHP4: Compile-time resolved "self" keyword
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A self keyword that works identical to the one used in PHP5.

Example:
<code>
  class Hello {
    public static function usage() {
      // ...
    }
    
    public static function main($args) {
      if ('-?' == $args[1]) {
        self::usage();
        return;
      }
    }
  }
</code>

What happens technically:
Self is resolved at compile time and replaced by the current class' name.
For PHP5, the self keyword is left as-is.


Annotations
~~~~~~~~~~~
Annotations as described in RFC #0016 but without the #-sign, see
http://experiments.xp-framework.net/?arena,php5,syntax/metadata.php
  
Declaring annotations:
<code>
  class CalculatorService {
  
    [@webmethod]
    public function add($a, $b) {
      return $a + $b;
    }
  }
</code>

Annotations can be retrieved via the reflection API.

What happens technically:
Annotations are stored in the xp registry. The reflection API will 
retrieve them from there instead of having to parse the class files
at runtime.


Anonymous class creation
~~~~~~~~~~~~~~~~~~~~~~~~
See http://experiments.xp-framework.net/?arena,php5,syntax/instance_creation.php
for details.
  
Usage:
<code>
  $list->sort(new Comparator() {
    public function compare($a, $b) {
      return strnatcmp($a, $b);
    }
  });
</code>

What happens technically:
This is recompiled to the userland version shown at "Instance creation
expression in PHP4" (http://xp-framework.info/xml/xp.en_US/news/view?60)


With syntactic sugar
~~~~~~~~~~~~~~~~~~~~
A keyword "with" is added.

Usage:
<code>
  with ($tree->addChild(new Node('tagname')) as $node) {
    $node->setAttribute('attribute', 'value');
  }
</code>

What happens technically:
The with statement, essentialy a no-op, is resolved to the following 
sourcecode:
<code>
  $node= &$tree->addChild(new Node('tagname')); {
    $node->setAttribute('attribute', 'value');
  }
</code>


Throws clause
~~~~~~~~~~~~~
Methods will be allowed to have a declarative throws-clause. Unlike the
throws-clause in Java, blocks executing a function or method with a 
throws clause and not handling the list of contained exception will not
lead to a compile-time error. 

Declaration:
<code>
  public function connect() throws IOException, ConnectException {
    // ...
  }
</code>
The thrown exceptions can be retrieved by means of the reflection API.

What happens technically:
The thrown exceptions will be stored in the xp registry. The reflection
API can retrieve them from there.


For PHP4: Dereferencing
~~~~~~~~~~~~~~~~~~~~~~~
Method calls will be allowed to be chained as follows:
<code>
  $date= XPClass::forName('util.Date')->newInstance();
</code>

What happens technically:
See http://experiments.xp-framework.net/?people,friebe,chain

For PHP4: Try/catch syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~
The try/catch syntax will be changed to allow the following:
<code>
  try {
    $class= XPClass::forName($name);
  } catch (ClassNotFoundException $e) {
    // ...
  }
</code>

What happens technically:
For PHP4, try is rewritten to try(); and catch (...) to if (catch(...)). 
For PHP versions with real exception support, the above sourcecode can
remain as-is.


For PHP4: Interfaces
~~~~~~~~~~~~~~~~~~~~
An interface keyword that works identical to the one used in PHP5.

Interface declaration:
<code>
  interface Comparable {
    public function compareTo($cmp);
  }
</code>

Implementing an interface:
<code>
  class Date implements Comparable {
    // ...

    public function compareTo($cmp) {
      return $this->utime == $cmp->utime;
    }
  }
</code>
What happens technically:
For PHP4, the current XP sourcecode with "extends Interface" and
"implements(__FILE__, 'Comparable'))" is generated, see
http://xp-framework.net/content/about.html#10
For PHP5 and above, this is essentially a no-op.


For PHP4: instanceof
~~~~~~~~~~~~~~~~~~~~
An instanceof keyword that works identical to the one used in PHP5.
  
<code>
  if ($instance instanceof Comparable) {
    $instance->compareTo($cmp);
  }
</code>
What happens technically:
For PHP4, we rewrite this to is('Comparable', $instance). For PHP5 and
above, the sourcecode is left untouched.

For PHP4: Type hints
~~~~~~~~~~~~~~~~~~~~
The type hints that were introduced with PHP5 could be emulated, possibly even
improved (by throwing an exception instead of a fatal error, and by allowing
NULL values).

<code>
  public function setTrace(LogCategory &$cat) {
    $this->cat= &$cat;
  }
</code>
What happens technically:
An is() call is being inserted right after the function has been entered
and the passed value is being checked. If the type does not match the
required one, throw an lang.IllegalArgumentException (for example).

Security considerations
-----------------------
n/a


Speed impact
------------
Slower


Dependencies
------------
auto_prepend_file directive

Related documents
-----------------
URLs
~~~~
- [1] http://experiments.xp-framework.net/?arena,php5,packages
- [2] http://phpnamespaces.org/
  
Other resources
~~~~~~~~~~~~~~~
- http://experiments.xp-framework.net/?people,friebe,rfc0052
  Experiment with auto_prepend_file

Comments
--------
- friebe, Sat Jan 28 18:21:05     2006
  Experiment shows this could be done via auto_prepend_file.

- friebe, Sun Jan 29 02:11:23     2006
  Maybe static imports would also be a worth a try?
<code>
  import static util·cmd·Console·writeLine;
  
  writeLine('Hello');
</code>

- kiesel, Tue Jan 31 15:38:38 CET 2006
  The meta-compiler should take care of keeping the current line numbers
  consistent across files. One will be able to associate an error with a
  code line.
  (My) experience shows, this is an important feature.

- kiesel, Tue Jan 31 15:40:24 CET 2006
  One may think about creating multiple compilers - or, one compiler with
  multiple modes: eg. debugging, release. The debug compiler would add
  more checks on type hints or return types while the release compiler
  would skip those in favor of speed.



<EOF>
