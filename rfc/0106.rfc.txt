RFC 0106: Overload array access / foreach iteration in ArrayList
========================================================================
$Id$

@authors: friebe
@created: Mon Jan  8 18:35:00     2007
@status: draft
@category: lang.types

Scope of Change
---------------
The lang.types.ArrayList class will be changed to support array access
(read/write) and foreach() iteration.


Rationale
---------
Easier access to Arraylist's values.


Functionality
-------------
The ArrayList class will implement the "magic" interfaces ArrayAccess 
and IteratorAggregate (provided with the Zend Engine).


ArrayAccess implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~
The ArrayAccess interface requires implementing the following methods:
offsetGet(), offsetSet(), offsetExists() and offsetUnset().

Because the ArrayList class represents a strictly "numeric" array (a
list of elements that is zero-indexed and without gaps), we will need
to take special precautions in offsetSet().
<?php
  // ...
  public function offsetGet($offset) {
    if (!array_key_exists($offset, $this->values)) {
      raise('lang.IndexOutOfBoundsException', 'Offset '.$offset.' out of bounds');
    }
    return $this->values[$offset];
  }

  public function offsetSet($offset, $value) {
    if (is_int($offset)) {
      if ($offset < 0 || $offset > sizeof($this->values)) {
        raise('lang.IndexOutOfBoundsException', 'Offset '.$offset.' out of bounds');
      }
      $this->values[$offset]= $value;
    } else if (NULL === $offset) {
      $this->values[]= $value;
    } else {
      throw new IllegalArgumentException('Incorrect type '.$t.' for index');
    }
  }

  public function offsetExists($offset) {
    return array_key_exists($offset, $this->values);
  }

  public function offsetUnset($offset) {
    unset($this->values[$offset]);
  }
  // ...
?>

IteratorAggregate implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We will define an "inner" class for iteration to not introduce new 
dependencies:
<?php
  // ...
  protected static
    $iterate = NULL;

  static function __static() {
    self::$iterate= newinstance('Iterator', array(), '{
      private $i= 0, $v;
      public function on($v) { $self= new self(); $self->v= $v; return $self; }
      public function current() { return $this->v[$this->i]; }
      public function key() { return $this->i; }
      public function next() { $this->i++; }
      public function rewind() { $this->i= 0; }
      public function valid() { return $this->i < sizeof($this->v); }
    }');
  }

  public function getIterator() {
    return self::$iterate->on($this->values);
  }
  // ...
?>

Security considerations
-----------------------
n/a


Speed impact
------------
Slightly slower (more methods, extra implementation checks)


Dependencies
------------
n/a


Related documents
-----------------
- http://www.php.net/~helly/php/ext/spl/interfaceArrayAccess.html
  Zend-Engine internal interface ArrayAccess

- http://www.php.net/~helly/php/ext/spl/interfaceIteratorAggregate.html
  Zend-Engine internal interface IteratorAggregate

Comments
--------
- friebe, Mon Jan  8 19:09:55     2007
  The ArrayAccess and IteratorAggregate interfaces are part of the Zend
  Engine, not of SPL!

<EOF>
