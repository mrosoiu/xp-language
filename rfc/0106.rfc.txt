RFC 0106: Overload array access / foreach in "array" types / type boxing
========================================================================
$Id$

@authors: friebe
@created: Mon Jan  8 18:35:00     2007
@status: draft
@category: lang.types, util.collections

Scope of Change
---------------
The lang.types.ArrayList class and the relevant classes from util.collections 
will be changed to support array access (read/write) and foreach() iteration. 
The classes from the collections API will furthermore support type boxing.


Rationale
---------
Easier / intuitive interface to "array" types.


Functionality
-------------
The relevant classes will implement the "magic" interfaces ArrayAccess 
and IteratorAggregate (provided with the Zend Engine).

ArrayAccess
~~~~~~~~~~~
The ArrayAccess interface requires implementing the following methods:
offsetGet(), offsetSet(), offsetExists() and offsetUnset().

IteratorAggregate
~~~~~~~~~~~~~~~~~
The IteratorAggregate interface requires implementing a method called
getIterator() which must return an Iterator instance.

ArrayList
~~~~~~~~~
An ArrayList is an immutable, zero-indexed list of values of any type
and most closely resembles an array in Java.
<?php
  with ($a= new ArrayList(1, 2, 3));  {
  
    // Length = 3
    $l= $a->length;
  
    // Element access
    $one= $a[0];    // $one contains "1"
    $a[1]+= 1;      // The second list entry (2) will be increased
    $a[2]= 4;       // The third list entry (3) will be set to 4
    
    // ArrayList is immutable in size!
    $a[-1]= 1;      // Throws an IndexOutOfBoundsException
    $a[3]= 1;       // - " -
    $err= $a[4];    // - " -
    $a[]= 1;        // - " -
    unset($a[0]);   // Throws an IllegalArgumentException
    
    // Keys are integers only!
    $a['foo']= 1;   // Throws an IllegalArgumentException
    $f= $a['foo'];  //  - " -
    
    // Testing
    isset($a[0]);   // TRUE
    isset($a[-1]);  // FALSE
    isset($a[3]);   // FALSE
    
    // foreach-iteration, prints "1 2 3 "
    foreach (new ArrayList(1, 2, 3) as $value) {
      echo $value, ' ';
    }
    
    // Constructing an arraylist from an array
    $a= ArrayList::newInstance(array(1, 2, 3, 4));
    $four= $a->length;
    
    // Constructing an empty arraylist
    $a= ArrayList::newInstance(4);
    $four= $a->length;
  }
?>

Vector
~~~~~~
A Vector is a resizable array of objects.
<?php
  uses('util.collections.Vector');

  with ($v= new Vector()); {
    
    // The add() method and its overloaded equivalent
    $v->add(new String('hello'));
    $v[]= new String('hello');

    // The get() method and its overloaded equivalent
    $hello= $v->get(0);
    $hello= $v[0];

    // The set() method and its overloaded equivalent
    $v->set(0, new String('world'));
    $v[0]= new String('world');
    
    // The remove() method and its overloaded equivalent
    $v->remove(0);
    unset($v[0]);

    // foreach-iteration, prints "1 2 3 "
    foreach (new Vector(array(1, 2, 3)) as $value) {
      echo $value, ' ';
    }
  }
?>

HashTable
~~~~~~~~~
A HashTable is a map where both keys and values are objects.
<?php
  uses('util.collections.HashTable');

  with ($h= new HashTable()); {
  
    // The put() method and its overloaded equivalent
    $h->put(new String('stage-url'), new URL('xp://localhost:6448'));
    $h[new String('stage-url')]= new URL('xp://localhost:6448');
    
    // Primitives in keys are "boxed"
    $h->put('stage-url', new URL('xp://localhost:6448'));
    $h['stage-url']= new URL('xp://localhost:6448');
    
    // The get() method and its overloaded equivalent
    $url= $h->get(new String('stage-url'));
    $url= $h[new String('stage-url')];
    
    // Primitives in keys are "boxed"
    $url= $h->get('stage-url');
    $url= $h['stage-url'];
  }
?>


Security considerations
-----------------------
n/a


Speed impact
------------
Slightly slower (more methods, extra implementation checks)


Dependencies
------------

ArrayList vs. Vector
~~~~~~~~~~~~~~~~~~~~
lang.types.ArrayList's constructor will be changed to accept varargs
instead of an array. The classes that use lang.types.ArrayList will 
be adapted to this change.

A new interface util.collections.IList will be introduced. An 
implementation will exists in form of the new class 
util.collections.Vector.

The distinction between those two is that ArrayList is a thin, immutable
wrapper type without utility functions such as indexOf() or contains(), 
whereas the Vector class provides a full "list" API. 

Related documents
-----------------
- http://www.php.net/~helly/php/ext/spl/interfaceArrayAccess.html
  Zend-Engine internal interface ArrayAccess

- http://www.php.net/~helly/php/ext/spl/interfaceIteratorAggregate.html
  Zend-Engine internal interface IteratorAggregate

- http://xp-framework.net/rfc/contrib/rfc0106-remote.diff
  Patch for remote API (apply in xp/trunk)

- http://experiments.xp-framework.net/?arena,arrayaccess
  Experiment
  
Comments
--------
- friebe, Mon Jan  8 19:09:55     2007
  The ArrayAccess and IteratorAggregate interfaces are part of the Zend
  Engine, not of SPL!

<EOF>
