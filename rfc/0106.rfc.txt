RFC 0106: Overload array access / foreach in "array" types
========================================================================
$Id$

@authors: friebe
@created: Mon Jan  8 18:35:00     2007
@status: draft
@category: lang.types, util.collections

Scope of Change
---------------
The lang.types.ArrayList class and the relevant classes from 
util.collections will be changed to support array access
(read/write) and foreach() iteration.


Rationale
---------
Easier / intuitive interface to "array" types.


Functionality
-------------
The relevant classes will implement the "magic" interfaces ArrayAccess 
and IteratorAggregate (provided with the Zend Engine).

ArrayAccess
~~~~~~~~~~~
The ArrayAccess interface requires implementing the following methods:
offsetGet(), offsetSet(), offsetExists() and offsetUnset().

ArrayList implementation
~~~~~~~~~~~~~~~~~~~~~~~~
Because the ArrayList class represents a strictly "numeric" array (a
list of elements that is zero-indexed and without gaps), we will need
to take special precautions in offsetSet().
<?php
  // ...
  public function offsetGet($offset) {
    if (!array_key_exists($offset, $this->values)) {
      raise('lang.IndexOutOfBoundsException', 'Offset '.$offset.' out of bounds');
    }
    return $this->values[$offset];
  }

  public function offsetSet($offset, $value) {
    if (is_int($offset)) {
      if ($offset < 0 || $offset > sizeof($this->values)) {
        raise('lang.IndexOutOfBoundsException', 'Offset '.$offset.' out of bounds');
      }
      $this->values[$offset]= $value;
    } else if (NULL === $offset) {
      $this->values[]= $value;
    } else {
      throw new IllegalArgumentException('Incorrect type '.$t.' for index');
    }
  }

  public function offsetExists($offset) {
    return array_key_exists($offset, $this->values);
  }

  public function offsetUnset($offset) {
    unset($this->values[$offset]);
  }
  // ...
?>

We will define an "inner" class for iteration to not introduce new 
dependencies:
<?php
  // ...
  protected static
    $iterate = NULL;

  static function __static() {
    self::$iterate= newinstance('Iterator', array(), '{
      private $i= 0, $v;
      public function on($v) { $self= new self(); $self->v= $v; return $self; }
      public function current() { return $this->v[$this->i]; }
      public function key() { return $this->i; }
      public function next() { $this->i++; }
      public function rewind() { $this->i= 0; }
      public function valid() { return $this->i < sizeof($this->v); }
    }');
  }

  public function getIterator() {
    return self::$iterate->on($this->values);
  }
  // ...
?>

HashTable implementation
~~~~~~~~~~~~~~~~~~~~~~~~
The changes to the util.collection.HashTable class are trivial:
<?php
  public function offsetGet($offset) {
    return $this->get($offset);
  }

  public function offsetSet($offset, $value) {
    $this->put($offset, $value);
  }

  public function offsetExists($offset) {
    return $this->containsKey($offset);
  }

  public function offsetUnset($offset) {
    $this->remove($offset);
  }
?>

Examples:
<?php
  with ($h= new HashTable()); {
  
    // Using the put() method
    $h->put(new String('stage-url'), new URL('xp://localhost:6448'));
   
    // The overloaded equivalent 
    $h[new String('stage-url')]= new URL('xp://localhost:6448');
    
    // Using the get() method
    $url= $h->get(new String('stage-url'));
    
    // The overloaded equivalent 
    $url= $h[new String('stage-url')];
  }
?>


Security considerations
-----------------------
n/a


Speed impact
------------
Slightly slower (more methods, extra implementation checks)


Dependencies
------------

ArrayList vs. Vector
~~~~~~~~~~~~~~~~~~~~
lang.types.ArrayList's constructor will be changed to accept varargs
instead of an array. The classes that use lang.types.ArrayList will 
be adapted to this change.

A new interface util.collections.IList will be introduced. An 
implementation will exists in form of the new class 
util.collections.Vector.

The distinction between those two is that ArrayList is a thin, immutable
wrapper type without utility functions such as indexOf() or contains(), 
whereas the Vector class provides a full "list" API. 

Related documents
-----------------
- http://www.php.net/~helly/php/ext/spl/interfaceArrayAccess.html
  Zend-Engine internal interface ArrayAccess

- http://www.php.net/~helly/php/ext/spl/interfaceIteratorAggregate.html
  Zend-Engine internal interface IteratorAggregate

- http://xp-framework.net/rfc/contrib/rfc0106.diff
  Implementing patch (apply in xp/trunk)

- http://experiments.xp-framework.net/?arena,arrayaccess
  Experiment
  
Comments
--------
- friebe, Mon Jan  8 19:09:55     2007
  The ArrayAccess and IteratorAggregate interfaces are part of the Zend
  Engine, not of SPL!

<EOF>
