RFC 0142: I/O Streams to PHP streams wrapper
========================================================================
$Id$

@authors: friebe
@created: Sun Oct 21 16:10:32     2007
@status: draft
@category: io.streams

Scope of Change
---------------
There will be a way to wrap io.streams Streams into PHP streams.


Rationale
---------
Support legacy PHP APIs.


Functionality
-------------

Usage (reading from a MemoryInputStream)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<?php
  $m= new MemoryInputStream('Hello World');
  
  $fd= Streams::forReading($m);
  $helloWorld= fread($fd, 1024);
  fclose($fd);
?>

Usage (writing to a MemoryOutputStream)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<?php
  $m= new MemoryOutputStream();
  
  $fd= Streams::forWriting($m);
  fwrite($fd, 'Hello World');
  fclose($fd);
  
  $helloWorld= $m->getBytes();
?>

Implementation
~~~~~~~~~~~~~~
<?php
  class Streams extends Object {
    private static 
      $streams = array();

    private 
      $id      = NULL;

    public static function wrap($s) { 
      self::$streams[$s->hashCode()]= $s;
      return "iostr://".$s->hashCode(); 
    }

    public static function forReading(InputStream $s) { 
      return fopen(self::wrap($s), 'rb');
    }

    public static function forWriting(OutputStream $s) { 
      return fopen(self::wrap($s), 'wb');
    }

    public function stream_open($path, $mode, $options, $opened_path) {
      sscanf($path, "iostr://%[^$]", $this->id);
      if (!isset(self::$streams[$this->id])) {
        throw new FileNotFoundException("No such iostr ".$this->id);
      }
      return TRUE;
    }

    public function stream_read($count) {
      return self::$streams[$this->id]->read($count);
    }

    public function stream_eof() {
      return 0 === self::$streams[$this->id]->available();
    }

    public function stream_write($data) {
      self::$streams[$this->id]->write($data);
      return strlen($data);
    }

    public function stream_close() {
      self::$streams[$this->id]->close();
      unset(self::$streams[$this->id]);
    }

    public function stream_stat() {
      return array("size" => self::$streams[$this->id]->available());
    }
  }
?>


Security considerations
-----------------------

Speed impact
------------

Dependencies
------------

Related documents
-----------------

Comments
--------

<EOF>
